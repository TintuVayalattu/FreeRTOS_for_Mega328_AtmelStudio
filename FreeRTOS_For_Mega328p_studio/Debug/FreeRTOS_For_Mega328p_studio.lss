
FreeRTOS_For_Mega328p_studio.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800100  00002226  000022ba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002226  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000069d  00800136  00800136  000022f0  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000022f0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000234c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000418  00000000  00000000  0000238c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004f5d  00000000  00000000  000027a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000016bf  00000000  00000000  00007701  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002c7c  00000000  00000000  00008dc0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000c5c  00000000  00000000  0000ba3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000189d  00000000  00000000  0000c698  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004933  00000000  00000000  0000df35  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000440  00000000  00000000  00012868  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 e2 06 	jmp	0xdc4	; 0xdc4 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 91 01 	jmp	0x322	; 0x322 <__vector_18>
      4c:	0c 94 d1 01 	jmp	0x3a2	; 0x3a2 <__vector_19>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e6 e2       	ldi	r30, 0x26	; 38
      7c:	f2 e2       	ldi	r31, 0x22	; 34
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a6 33       	cpi	r26, 0x36	; 54
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	a6 e3       	ldi	r26, 0x36	; 54
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a3 3d       	cpi	r26, 0xD3	; 211
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <main>
      9e:	0c 94 11 11 	jmp	0x2222	; 0x2222 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <ADC_0_init>:
	ADCSRA |= (1 << ADEN);
}

void ADC_0_disable()
{
	ADCSRA &= ~(1 << ADEN);
      a6:	e4 e6       	ldi	r30, 0x64	; 100
      a8:	f0 e0       	ldi	r31, 0x00	; 0
      aa:	80 81       	ld	r24, Z
      ac:	8e 7f       	andi	r24, 0xFE	; 254
      ae:	80 83       	st	Z, r24
      b0:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
      b4:	81 e8       	ldi	r24, 0x81	; 129
      b6:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
      ba:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
      be:	10 92 7e 00 	sts	0x007E, r1	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
      c2:	80 e0       	ldi	r24, 0x00	; 0
      c4:	08 95       	ret

000000c6 <ADC_0_start_conversion>:
}

void ADC_0_start_conversion(adc_0_channel_t channel)
{
	ADMUX &= ~0x0f;
      c6:	ec e7       	ldi	r30, 0x7C	; 124
      c8:	f0 e0       	ldi	r31, 0x00	; 0
      ca:	90 81       	ld	r25, Z
      cc:	90 7f       	andi	r25, 0xF0	; 240
      ce:	90 83       	st	Z, r25
	ADMUX |= channel;
      d0:	90 81       	ld	r25, Z
      d2:	89 2b       	or	r24, r25
      d4:	80 83       	st	Z, r24
	ADCSRA |= (1 << ADSC);
      d6:	ea e7       	ldi	r30, 0x7A	; 122
      d8:	f0 e0       	ldi	r31, 0x00	; 0
      da:	80 81       	ld	r24, Z
      dc:	80 64       	ori	r24, 0x40	; 64
      de:	80 83       	st	Z, r24
      e0:	08 95       	ret

000000e2 <ADC_0_is_conversion_done>:
}

bool ADC_0_is_conversion_done()
{
	return ((ADCSRA & (1 << ADIF)));
      e2:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
}
      e6:	82 95       	swap	r24
      e8:	81 70       	andi	r24, 0x01	; 1
      ea:	08 95       	ret

000000ec <ADC_0_get_conversion_result>:

adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADCL | ADCH << 8);
      ec:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
      f0:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
      f4:	90 e0       	ldi	r25, 0x00	; 0
}
      f6:	92 2b       	or	r25, r18
      f8:	08 95       	ret

000000fa <ADC_0_get_conversion>:

adc_result_t ADC_0_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
      fa:	0e 94 63 00 	call	0xc6	; 0xc6 <ADC_0_start_conversion>
	while (!ADC_0_is_conversion_done())
      fe:	0e 94 71 00 	call	0xe2	; 0xe2 <ADC_0_is_conversion_done>
     102:	88 23       	and	r24, r24
     104:	e1 f3       	breq	.-8      	; 0xfe <ADC_0_get_conversion+0x4>
		;
	res = ADC_0_get_conversion_result();
     106:	0e 94 76 00 	call	0xec	; 0xec <ADC_0_get_conversion_result>
	ADCSRA |= (1 << ADIF);
     10a:	ea e7       	ldi	r30, 0x7A	; 122
     10c:	f0 e0       	ldi	r31, 0x00	; 0
     10e:	20 81       	ld	r18, Z
     110:	20 61       	ori	r18, 0x10	; 16
     112:	20 83       	st	Z, r18
	return res;
}
     114:	08 95       	ret

00000116 <print>:

/*-----------------------------------------------------------*/

void print(char *str,uint16_t len);
void print(char *str,uint16_t len)
{
     116:	0f 93       	push	r16
     118:	1f 93       	push	r17
     11a:	cf 93       	push	r28
     11c:	df 93       	push	r29
	uint16_t i;
	for(i=0;i<len;i++)
     11e:	61 15       	cp	r22, r1
     120:	71 05       	cpc	r23, r1
     122:	71 f0       	breq	.+28     	; 0x140 <print+0x2a>
     124:	8c 01       	movw	r16, r24
     126:	ec 01       	movw	r28, r24
     128:	06 0f       	add	r16, r22
     12a:	17 1f       	adc	r17, r23
		xSerialPutChar( 0, str[i], 0 );
     12c:	69 91       	ld	r22, Y+
     12e:	40 e0       	ldi	r20, 0x00	; 0
     130:	50 e0       	ldi	r21, 0x00	; 0
     132:	80 e0       	ldi	r24, 0x00	; 0
     134:	90 e0       	ldi	r25, 0x00	; 0
     136:	0e 94 74 01 	call	0x2e8	; 0x2e8 <xSerialPutChar>

void print(char *str,uint16_t len);
void print(char *str,uint16_t len)
{
	uint16_t i;
	for(i=0;i<len;i++)
     13a:	c0 17       	cp	r28, r16
     13c:	d1 07       	cpc	r29, r17
     13e:	b1 f7       	brne	.-20     	; 0x12c <print+0x16>
		xSerialPutChar( 0, str[i], 0 );
}
     140:	df 91       	pop	r29
     142:	cf 91       	pop	r28
     144:	1f 91       	pop	r17
     146:	0f 91       	pop	r16
     148:	08 95       	ret

0000014a <DisplayTemp>:
{
	static int res;
	static char MsgBuff[32];
	(void) pvParameters;

	ADC_0_init();
     14a:	0e 94 53 00 	call	0xa6	; 0xa6 <ADC_0_init>
	xSerialPortInitMinimal( mainCOM_TEST_BAUD_RATE, 100 );
     14e:	44 e6       	ldi	r20, 0x64	; 100
     150:	60 e0       	ldi	r22, 0x00	; 0
     152:	76 e9       	ldi	r23, 0x96	; 150
     154:	80 e0       	ldi	r24, 0x00	; 0
     156:	90 e0       	ldi	r25, 0x00	; 0
     158:	0e 94 20 01 	call	0x240	; 0x240 <xSerialPortInitMinimal>
	for(;;)
	{
		vTaskDelay(500);              // wait for a second
		res = ADC_0_get_conversion(0);
		sprintf(MsgBuff,"Temperature = %d *C\r\n",res);
     15c:	02 e0       	ldi	r16, 0x02	; 2
     15e:	11 e0       	ldi	r17, 0x01	; 1
     160:	c6 e3       	ldi	r28, 0x36	; 54
     162:	d1 e0       	ldi	r29, 0x01	; 1

	ADC_0_init();
	xSerialPortInitMinimal( mainCOM_TEST_BAUD_RATE, 100 );
	for(;;)
	{
		vTaskDelay(500);              // wait for a second
     164:	84 ef       	ldi	r24, 0xF4	; 244
     166:	91 e0       	ldi	r25, 0x01	; 1
     168:	0e 94 a8 0c 	call	0x1950	; 0x1950 <vTaskDelay>
		res = ADC_0_get_conversion(0);
     16c:	80 e0       	ldi	r24, 0x00	; 0
     16e:	0e 94 7d 00 	call	0xfa	; 0xfa <ADC_0_get_conversion>
		sprintf(MsgBuff,"Temperature = %d *C\r\n",res);
     172:	9f 93       	push	r25
     174:	8f 93       	push	r24
     176:	1f 93       	push	r17
     178:	0f 93       	push	r16
     17a:	df 93       	push	r29
     17c:	cf 93       	push	r28
     17e:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <sprintf>
		print(MsgBuff,strlen(MsgBuff));
     182:	fe 01       	movw	r30, r28
     184:	01 90       	ld	r0, Z+
     186:	00 20       	and	r0, r0
     188:	e9 f7       	brne	.-6      	; 0x184 <DisplayTemp+0x3a>
     18a:	31 97       	sbiw	r30, 0x01	; 1
     18c:	bf 01       	movw	r22, r30
     18e:	66 53       	subi	r22, 0x36	; 54
     190:	71 40       	sbci	r23, 0x01	; 1
     192:	ce 01       	movw	r24, r28
     194:	0e 94 8b 00 	call	0x116	; 0x116 <print>
     198:	0f 90       	pop	r0
     19a:	0f 90       	pop	r0
     19c:	0f 90       	pop	r0
     19e:	0f 90       	pop	r0
     1a0:	0f 90       	pop	r0
     1a2:	0f 90       	pop	r0
     1a4:	df cf       	rjmp	.-66     	; 0x164 <DisplayTemp+0x1a>

000001a6 <main>:
	}

}
int main( void )
{
     1a6:	ef 92       	push	r14
     1a8:	ff 92       	push	r15
     1aa:	0f 93       	push	r16

	/* Setup the LED's for output. */
	vParTestInitialise();
     1ac:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <vParTestInitialise>

	xTaskCreate( DisplayTemp, "Display", configMINIMAL_STACK_SIZE, NULL, mainCOM_TEST_PRIORITY, NULL );
     1b0:	e1 2c       	mov	r14, r1
     1b2:	f1 2c       	mov	r15, r1
     1b4:	02 e0       	ldi	r16, 0x02	; 2
     1b6:	20 e0       	ldi	r18, 0x00	; 0
     1b8:	30 e0       	ldi	r19, 0x00	; 0
     1ba:	45 e5       	ldi	r20, 0x55	; 85
     1bc:	50 e0       	ldi	r21, 0x00	; 0
     1be:	68 e1       	ldi	r22, 0x18	; 24
     1c0:	71 e0       	ldi	r23, 0x01	; 1
     1c2:	85 ea       	ldi	r24, 0xA5	; 165
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	0e 94 2c 0a 	call	0x1458	; 0x1458 <xTaskCreate>
	
	
	/* Create the co-routines that flash the LED's. */
	vStartFlashCoRoutines( mainNUM_FLASH_COROUTINES ); 
     1ca:	83 e0       	ldi	r24, 0x03	; 3
     1cc:	0e 94 bd 02 	call	0x57a	; 0x57a <vStartFlashCoRoutines>

	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION
	as 1 in portmacro.h.  To use the cooperative scheduler define
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
     1d0:	0e 94 34 0b 	call	0x1668	; 0x1668 <vTaskStartScheduler>

	return 0;
}
     1d4:	80 e0       	ldi	r24, 0x00	; 0
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	0f 91       	pop	r16
     1da:	ff 90       	pop	r15
     1dc:	ef 90       	pop	r14
     1de:	08 95       	ret

000001e0 <vApplicationIdleHook>:
//}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	vCoRoutineSchedule();
     1e0:	0e 94 9e 03 	call	0x73c	; 0x73c <vCoRoutineSchedule>
     1e4:	08 95       	ret

000001e6 <vParTestInitialise>:

			PORTB = ucCurrentOutputValue;
		}
		xTaskResumeAll();
	}
}
     1e6:	8f ef       	ldi	r24, 0xFF	; 255
     1e8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     1ec:	84 b9       	out	0x04, r24	; 4
     1ee:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     1f2:	85 b9       	out	0x05, r24	; 5
     1f4:	08 95       	ret

000001f6 <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     1f6:	cf 93       	push	r28
     1f8:	df 93       	push	r29
unsigned char ucBit;

	if( uxLED <= partstMAX_OUTPUT_LED )
     1fa:	88 30       	cpi	r24, 0x08	; 8
     1fc:	f0 f4       	brcc	.+60     	; 0x23a <vParTestToggleLED+0x44>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
     1fe:	c1 e0       	ldi	r28, 0x01	; 1
     200:	d0 e0       	ldi	r29, 0x00	; 0
     202:	02 c0       	rjmp	.+4      	; 0x208 <vParTestToggleLED+0x12>
     204:	cc 0f       	add	r28, r28
     206:	dd 1f       	adc	r29, r29
     208:	8a 95       	dec	r24
     20a:	e2 f7       	brpl	.-8      	; 0x204 <vParTestToggleLED+0xe>

		vTaskSuspendAll();
     20c:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <vTaskSuspendAll>
		{
			if( ucCurrentOutputValue & ucBit )
     210:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     214:	8c 23       	and	r24, r28
     216:	39 f0       	breq	.+14     	; 0x226 <vParTestToggleLED+0x30>
			{
				ucCurrentOutputValue &= ~ucBit;
     218:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     21c:	c0 95       	com	r28
     21e:	c8 23       	and	r28, r24
     220:	c0 93 00 01 	sts	0x0100, r28	; 0x800100 <__data_start>
     224:	05 c0       	rjmp	.+10     	; 0x230 <vParTestToggleLED+0x3a>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     226:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     22a:	c8 2b       	or	r28, r24
     22c:	c0 93 00 01 	sts	0x0100, r28	; 0x800100 <__data_start>
			}

			PORTB = ucCurrentOutputValue;
     230:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     234:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();			
     236:	0e 94 29 0c 	call	0x1852	; 0x1852 <xTaskResumeAll>
	}
}
     23a:	df 91       	pop	r29
     23c:	cf 91       	pop	r28
     23e:	08 95       	ret

00000240 <xSerialPortInitMinimal>:
		vInterruptOff();
		ucByte = UCSR0B;
		ucByte &= ~serRX_INT_ENABLE;
		UCSR0B = ucByte;
	}
	portEXIT_CRITICAL();
     240:	cf 92       	push	r12
     242:	df 92       	push	r13
     244:	ef 92       	push	r14
     246:	ff 92       	push	r15
     248:	cf 93       	push	r28
     24a:	6b 01       	movw	r12, r22
     24c:	7c 01       	movw	r14, r24
     24e:	c4 2f       	mov	r28, r20
     250:	0f b6       	in	r0, 0x3f	; 63
     252:	f8 94       	cli
     254:	0f 92       	push	r0
     256:	40 e0       	ldi	r20, 0x00	; 0
     258:	61 e0       	ldi	r22, 0x01	; 1
     25a:	8c 2f       	mov	r24, r28
     25c:	0e 94 08 08 	call	0x1010	; 0x1010 <xQueueGenericCreate>
     260:	90 93 59 01 	sts	0x0159, r25	; 0x800159 <xRxedChars+0x1>
     264:	80 93 58 01 	sts	0x0158, r24	; 0x800158 <xRxedChars>
     268:	40 e0       	ldi	r20, 0x00	; 0
     26a:	61 e0       	ldi	r22, 0x01	; 1
     26c:	8c 2f       	mov	r24, r28
     26e:	0e 94 08 08 	call	0x1010	; 0x1010 <xQueueGenericCreate>
     272:	90 93 57 01 	sts	0x0157, r25	; 0x800157 <xCharsForTx+0x1>
     276:	80 93 56 01 	sts	0x0156, r24	; 0x800156 <xCharsForTx>
     27a:	d7 01       	movw	r26, r14
     27c:	c6 01       	movw	r24, r12
     27e:	88 0f       	add	r24, r24
     280:	99 1f       	adc	r25, r25
     282:	aa 1f       	adc	r26, r26
     284:	bb 1f       	adc	r27, r27
     286:	88 0f       	add	r24, r24
     288:	99 1f       	adc	r25, r25
     28a:	aa 1f       	adc	r26, r26
     28c:	bb 1f       	adc	r27, r27
     28e:	9c 01       	movw	r18, r24
     290:	ad 01       	movw	r20, r26
     292:	22 0f       	add	r18, r18
     294:	33 1f       	adc	r19, r19
     296:	44 1f       	adc	r20, r20
     298:	55 1f       	adc	r21, r21
     29a:	22 0f       	add	r18, r18
     29c:	33 1f       	adc	r19, r19
     29e:	44 1f       	adc	r20, r20
     2a0:	55 1f       	adc	r21, r21
     2a2:	60 e0       	ldi	r22, 0x00	; 0
     2a4:	74 e2       	ldi	r23, 0x24	; 36
     2a6:	84 ef       	ldi	r24, 0xF4	; 244
     2a8:	90 e0       	ldi	r25, 0x00	; 0
     2aa:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <__udivmodsi4>
     2ae:	da 01       	movw	r26, r20
     2b0:	c9 01       	movw	r24, r18
     2b2:	01 97       	sbiw	r24, 0x01	; 1
     2b4:	a1 09       	sbc	r26, r1
     2b6:	b1 09       	sbc	r27, r1
     2b8:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
     2bc:	89 2f       	mov	r24, r25
     2be:	9a 2f       	mov	r25, r26
     2c0:	ab 2f       	mov	r26, r27
     2c2:	bb 27       	eor	r27, r27
     2c4:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
     2c8:	88 e9       	ldi	r24, 0x98	; 152
     2ca:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     2ce:	86 e0       	ldi	r24, 0x06	; 6
     2d0:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
     2d4:	0f 90       	pop	r0
     2d6:	0f be       	out	0x3f, r0	; 63
     2d8:	80 e0       	ldi	r24, 0x00	; 0
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	cf 91       	pop	r28
     2de:	ff 90       	pop	r15
     2e0:	ef 90       	pop	r14
     2e2:	df 90       	pop	r13
     2e4:	cf 90       	pop	r12
     2e6:	08 95       	ret

000002e8 <xSerialPutChar>:
     2e8:	cf 93       	push	r28
     2ea:	df 93       	push	r29
     2ec:	1f 92       	push	r1
     2ee:	cd b7       	in	r28, 0x3d	; 61
     2f0:	de b7       	in	r29, 0x3e	; 62
     2f2:	69 83       	std	Y+1, r22	; 0x01
     2f4:	20 e0       	ldi	r18, 0x00	; 0
     2f6:	be 01       	movw	r22, r28
     2f8:	6f 5f       	subi	r22, 0xFF	; 255
     2fa:	7f 4f       	sbci	r23, 0xFF	; 255
     2fc:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <xCharsForTx>
     300:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <xCharsForTx+0x1>
     304:	0e 94 35 08 	call	0x106a	; 0x106a <xQueueGenericSend>
     308:	81 30       	cpi	r24, 0x01	; 1
     30a:	31 f4       	brne	.+12     	; 0x318 <xSerialPutChar+0x30>
     30c:	e1 ec       	ldi	r30, 0xC1	; 193
     30e:	f0 e0       	ldi	r31, 0x00	; 0
     310:	90 81       	ld	r25, Z
     312:	90 62       	ori	r25, 0x20	; 32
     314:	90 83       	st	Z, r25
     316:	01 c0       	rjmp	.+2      	; 0x31a <xSerialPutChar+0x32>
     318:	80 e0       	ldi	r24, 0x00	; 0
     31a:	0f 90       	pop	r0
     31c:	df 91       	pop	r29
     31e:	cf 91       	pop	r28
     320:	08 95       	ret

00000322 <__vector_18>:
}
/*-----------------------------------------------------------*/

SIGNAL( USART_RX_vect )
{
     322:	1f 92       	push	r1
     324:	0f 92       	push	r0
     326:	0f b6       	in	r0, 0x3f	; 63
     328:	0f 92       	push	r0
     32a:	11 24       	eor	r1, r1
     32c:	2f 93       	push	r18
     32e:	3f 93       	push	r19
     330:	4f 93       	push	r20
     332:	5f 93       	push	r21
     334:	6f 93       	push	r22
     336:	7f 93       	push	r23
     338:	8f 93       	push	r24
     33a:	9f 93       	push	r25
     33c:	af 93       	push	r26
     33e:	bf 93       	push	r27
     340:	ef 93       	push	r30
     342:	ff 93       	push	r31
     344:	cf 93       	push	r28
     346:	df 93       	push	r29
     348:	00 d0       	rcall	.+0      	; 0x34a <__vector_18+0x28>
     34a:	cd b7       	in	r28, 0x3d	; 61
     34c:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     34e:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
     350:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     354:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     356:	20 e0       	ldi	r18, 0x00	; 0
     358:	ae 01       	movw	r20, r28
     35a:	4e 5f       	subi	r20, 0xFE	; 254
     35c:	5f 4f       	sbci	r21, 0xFF	; 255
     35e:	be 01       	movw	r22, r28
     360:	6f 5f       	subi	r22, 0xFF	; 255
     362:	7f 4f       	sbci	r23, 0xFF	; 255
     364:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <xRxedChars>
     368:	90 91 59 01 	lds	r25, 0x0159	; 0x800159 <xRxedChars+0x1>
     36c:	0e 94 d6 08 	call	0x11ac	; 0x11ac <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
     370:	8a 81       	ldd	r24, Y+2	; 0x02
     372:	81 11       	cpse	r24, r1
	{
		taskYIELD();
     374:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vPortYield>
	}
}
     378:	0f 90       	pop	r0
     37a:	0f 90       	pop	r0
     37c:	df 91       	pop	r29
     37e:	cf 91       	pop	r28
     380:	ff 91       	pop	r31
     382:	ef 91       	pop	r30
     384:	bf 91       	pop	r27
     386:	af 91       	pop	r26
     388:	9f 91       	pop	r25
     38a:	8f 91       	pop	r24
     38c:	7f 91       	pop	r23
     38e:	6f 91       	pop	r22
     390:	5f 91       	pop	r21
     392:	4f 91       	pop	r20
     394:	3f 91       	pop	r19
     396:	2f 91       	pop	r18
     398:	0f 90       	pop	r0
     39a:	0f be       	out	0x3f, r0	; 63
     39c:	0f 90       	pop	r0
     39e:	1f 90       	pop	r1
     3a0:	18 95       	reti

000003a2 <__vector_19>:
/*-----------------------------------------------------------*/

SIGNAL( USART_UDRE_vect )
{
     3a2:	1f 92       	push	r1
     3a4:	0f 92       	push	r0
     3a6:	0f b6       	in	r0, 0x3f	; 63
     3a8:	0f 92       	push	r0
     3aa:	11 24       	eor	r1, r1
     3ac:	2f 93       	push	r18
     3ae:	3f 93       	push	r19
     3b0:	4f 93       	push	r20
     3b2:	5f 93       	push	r21
     3b4:	6f 93       	push	r22
     3b6:	7f 93       	push	r23
     3b8:	8f 93       	push	r24
     3ba:	9f 93       	push	r25
     3bc:	af 93       	push	r26
     3be:	bf 93       	push	r27
     3c0:	ef 93       	push	r30
     3c2:	ff 93       	push	r31
     3c4:	cf 93       	push	r28
     3c6:	df 93       	push	r29
     3c8:	00 d0       	rcall	.+0      	; 0x3ca <__vector_19+0x28>
     3ca:	cd b7       	in	r28, 0x3d	; 61
     3cc:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     3ce:	ae 01       	movw	r20, r28
     3d0:	4e 5f       	subi	r20, 0xFE	; 254
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	be 01       	movw	r22, r28
     3d6:	6f 5f       	subi	r22, 0xFF	; 255
     3d8:	7f 4f       	sbci	r23, 0xFF	; 255
     3da:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <xCharsForTx>
     3de:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <xCharsForTx+0x1>
     3e2:	0e 94 10 09 	call	0x1220	; 0x1220 <xQueueReceiveFromISR>
     3e6:	81 30       	cpi	r24, 0x01	; 1
     3e8:	21 f4       	brne	.+8      	; 0x3f2 <__vector_19+0x50>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
     3ea:	89 81       	ldd	r24, Y+1	; 0x01
     3ec:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     3f0:	05 c0       	rjmp	.+10     	; 0x3fc <__vector_19+0x5a>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
     3f2:	e1 ec       	ldi	r30, 0xC1	; 193
     3f4:	f0 e0       	ldi	r31, 0x00	; 0
     3f6:	80 81       	ld	r24, Z
     3f8:	8f 7d       	andi	r24, 0xDF	; 223
     3fa:	80 83       	st	Z, r24
	}
}
     3fc:	0f 90       	pop	r0
     3fe:	0f 90       	pop	r0
     400:	df 91       	pop	r29
     402:	cf 91       	pop	r28
     404:	ff 91       	pop	r31
     406:	ef 91       	pop	r30
     408:	bf 91       	pop	r27
     40a:	af 91       	pop	r26
     40c:	9f 91       	pop	r25
     40e:	8f 91       	pop	r24
     410:	7f 91       	pop	r23
     412:	6f 91       	pop	r22
     414:	5f 91       	pop	r21
     416:	4f 91       	pop	r20
     418:	3f 91       	pop	r19
     41a:	2f 91       	pop	r18
     41c:	0f 90       	pop	r0
     41e:	0f be       	out	0x3f, r0	; 63
     420:	0f 90       	pop	r0
     422:	1f 90       	pop	r1
     424:	18 95       	reti

00000426 <prvFlashCoRoutine>:
	crEND();
}
/*-----------------------------------------------------------*/

static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
     426:	0f 93       	push	r16
     428:	1f 93       	push	r17
     42a:	cf 93       	push	r28
     42c:	df 93       	push	r29
     42e:	1f 92       	push	r1
     430:	cd b7       	in	r28, 0x3d	; 61
     432:	de b7       	in	r29, 0x3e	; 62
     434:	8c 01       	movw	r16, r24
static as we do not need it to maintain their state between blocks. */
BaseType_t xResult;
UBaseType_t uxLEDToFlash;

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
     436:	fc 01       	movw	r30, r24
     438:	80 8d       	ldd	r24, Z+24	; 0x18
     43a:	91 8d       	ldd	r25, Z+25	; 0x19
     43c:	82 3c       	cpi	r24, 0xC2	; 194
     43e:	f1 e0       	ldi	r31, 0x01	; 1
     440:	9f 07       	cpc	r25, r31
     442:	c9 f0       	breq	.+50     	; 0x476 <prvFlashCoRoutine+0x50>
     444:	83 3c       	cpi	r24, 0xC3	; 195
     446:	21 e0       	ldi	r18, 0x01	; 1
     448:	92 07       	cpc	r25, r18
     44a:	41 f1       	breq	.+80     	; 0x49c <prvFlashCoRoutine+0x76>
     44c:	89 2b       	or	r24, r25
     44e:	81 f5       	brne	.+96     	; 0x4b0 <prvFlashCoRoutine+0x8a>
	( void ) uxIndex;
	
	for( ;; )
	{
		/* Block to wait for the number of the LED to flash. */
		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );		
     450:	4f ef       	ldi	r20, 0xFF	; 255
     452:	5f ef       	ldi	r21, 0xFF	; 255
     454:	be 01       	movw	r22, r28
     456:	6f 5f       	subi	r22, 0xFF	; 255
     458:	7f 4f       	sbci	r23, 0xFF	; 255
     45a:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <xFlashQueue>
     45e:	90 91 5b 01 	lds	r25, 0x015B	; 0x80015b <xFlashQueue+0x1>
     462:	0e 94 80 09 	call	0x1300	; 0x1300 <xQueueCRReceive>
     466:	8c 3f       	cpi	r24, 0xFC	; 252
     468:	89 f4       	brne	.+34     	; 0x48c <prvFlashCoRoutine+0x66>
     46a:	82 ec       	ldi	r24, 0xC2	; 194
     46c:	91 e0       	ldi	r25, 0x01	; 1
     46e:	f8 01       	movw	r30, r16
     470:	91 8f       	std	Z+25, r25	; 0x19
     472:	80 8f       	std	Z+24, r24	; 0x18
     474:	1d c0       	rjmp	.+58     	; 0x4b0 <prvFlashCoRoutine+0x8a>
     476:	40 e0       	ldi	r20, 0x00	; 0
     478:	50 e0       	ldi	r21, 0x00	; 0
     47a:	be 01       	movw	r22, r28
     47c:	6f 5f       	subi	r22, 0xFF	; 255
     47e:	7f 4f       	sbci	r23, 0xFF	; 255
     480:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <xFlashQueue>
     484:	90 91 5b 01 	lds	r25, 0x015B	; 0x80015b <xFlashQueue+0x1>
     488:	0e 94 80 09 	call	0x1300	; 0x1300 <xQueueCRReceive>
     48c:	8b 3f       	cpi	r24, 0xFB	; 251
     48e:	39 f4       	brne	.+14     	; 0x49e <prvFlashCoRoutine+0x78>
     490:	83 ec       	ldi	r24, 0xC3	; 195
     492:	91 e0       	ldi	r25, 0x01	; 1
     494:	f8 01       	movw	r30, r16
     496:	91 8f       	std	Z+25, r25	; 0x19
     498:	80 8f       	std	Z+24, r24	; 0x18
     49a:	0a c0       	rjmp	.+20     	; 0x4b0 <prvFlashCoRoutine+0x8a>
     49c:	81 e0       	ldi	r24, 0x01	; 1

		if( xResult != pdPASS )
     49e:	81 30       	cpi	r24, 0x01	; 1
     4a0:	19 f0       	breq	.+6      	; 0x4a8 <prvFlashCoRoutine+0x82>
		{
			/* We would not expect to wake unless we received something. */
			xCoRoutineFlashStatus = pdFAIL;
     4a2:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <xCoRoutineFlashStatus>
     4a6:	d4 cf       	rjmp	.-88     	; 0x450 <prvFlashCoRoutine+0x2a>
		}
		else
		{
			/* We received the number of an LED to flash - flash it! */
			vParTestToggleLED( uxLEDToFlash );
     4a8:	89 81       	ldd	r24, Y+1	; 0x01
     4aa:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <vParTestToggleLED>
     4ae:	d0 cf       	rjmp	.-96     	; 0x450 <prvFlashCoRoutine+0x2a>
		}
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
     4b0:	0f 90       	pop	r0
     4b2:	df 91       	pop	r29
     4b4:	cf 91       	pop	r28
     4b6:	1f 91       	pop	r17
     4b8:	0f 91       	pop	r16
     4ba:	08 95       	ret

000004bc <prvFixedDelayCoRoutine>:
	}
}
/*-----------------------------------------------------------*/

static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
     4bc:	0f 93       	push	r16
     4be:	1f 93       	push	r17
     4c0:	cf 93       	push	r28
     4c2:	df 93       	push	r29
     4c4:	1f 92       	push	r1
     4c6:	cd b7       	in	r28, 0x3d	; 61
     4c8:	de b7       	in	r29, 0x3e	; 62
     4ca:	8c 01       	movw	r16, r24
     4cc:	69 83       	std	Y+1, r22	; 0x01
																400 / portTICK_PERIOD_MS,
																450 / portTICK_PERIOD_MS,
																500  / portTICK_PERIOD_MS };

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
     4ce:	fc 01       	movw	r30, r24
     4d0:	80 8d       	ldd	r24, Z+24	; 0x18
     4d2:	91 8d       	ldd	r25, Z+25	; 0x19
     4d4:	82 38       	cpi	r24, 0x82	; 130
     4d6:	f1 e0       	ldi	r31, 0x01	; 1
     4d8:	9f 07       	cpc	r25, r31
     4da:	f1 f0       	breq	.+60     	; 0x518 <prvFixedDelayCoRoutine+0x5c>
     4dc:	18 f4       	brcc	.+6      	; 0x4e4 <prvFixedDelayCoRoutine+0x28>
     4de:	89 2b       	or	r24, r25
     4e0:	41 f0       	breq	.+16     	; 0x4f2 <prvFixedDelayCoRoutine+0x36>
     4e2:	45 c0       	rjmp	.+138    	; 0x56e <prvFixedDelayCoRoutine+0xb2>
     4e4:	83 38       	cpi	r24, 0x83	; 131
     4e6:	e1 e0       	ldi	r30, 0x01	; 1
     4e8:	9e 07       	cpc	r25, r30
     4ea:	49 f1       	breq	.+82     	; 0x53e <prvFixedDelayCoRoutine+0x82>
     4ec:	86 39       	cpi	r24, 0x96	; 150
     4ee:	91 40       	sbci	r25, 0x01	; 1
     4f0:	f1 f5       	brne	.+124    	; 0x56e <prvFixedDelayCoRoutine+0xb2>

	for( ;; )
	{
		/* Post our uxIndex value onto the queue.  This is used as the LED to
		flash. */
		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
     4f2:	40 e0       	ldi	r20, 0x00	; 0
     4f4:	50 e0       	ldi	r21, 0x00	; 0
     4f6:	be 01       	movw	r22, r28
     4f8:	6f 5f       	subi	r22, 0xFF	; 255
     4fa:	7f 4f       	sbci	r23, 0xFF	; 255
     4fc:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <xFlashQueue>
     500:	90 91 5b 01 	lds	r25, 0x015B	; 0x80015b <xFlashQueue+0x1>
     504:	0e 94 47 09 	call	0x128e	; 0x128e <xQueueCRSend>
     508:	8c 3f       	cpi	r24, 0xFC	; 252
     50a:	89 f4       	brne	.+34     	; 0x52e <prvFixedDelayCoRoutine+0x72>
     50c:	82 e8       	ldi	r24, 0x82	; 130
     50e:	91 e0       	ldi	r25, 0x01	; 1
     510:	f8 01       	movw	r30, r16
     512:	91 8f       	std	Z+25, r25	; 0x19
     514:	80 8f       	std	Z+24, r24	; 0x18
     516:	2b c0       	rjmp	.+86     	; 0x56e <prvFixedDelayCoRoutine+0xb2>
     518:	40 e0       	ldi	r20, 0x00	; 0
     51a:	50 e0       	ldi	r21, 0x00	; 0
     51c:	be 01       	movw	r22, r28
     51e:	6f 5f       	subi	r22, 0xFF	; 255
     520:	7f 4f       	sbci	r23, 0xFF	; 255
     522:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <xFlashQueue>
     526:	90 91 5b 01 	lds	r25, 0x015B	; 0x80015b <xFlashQueue+0x1>
     52a:	0e 94 47 09 	call	0x128e	; 0x128e <xQueueCRSend>
     52e:	8b 3f       	cpi	r24, 0xFB	; 251
     530:	39 f4       	brne	.+14     	; 0x540 <prvFixedDelayCoRoutine+0x84>
     532:	83 e8       	ldi	r24, 0x83	; 131
     534:	91 e0       	ldi	r25, 0x01	; 1
     536:	f8 01       	movw	r30, r16
     538:	91 8f       	std	Z+25, r25	; 0x19
     53a:	80 8f       	std	Z+24, r24	; 0x18
     53c:	18 c0       	rjmp	.+48     	; 0x56e <prvFixedDelayCoRoutine+0xb2>
     53e:	81 e0       	ldi	r24, 0x01	; 1

		if( xResult != pdPASS )
     540:	81 30       	cpi	r24, 0x01	; 1
     542:	11 f0       	breq	.+4      	; 0x548 <prvFixedDelayCoRoutine+0x8c>
		{
			/* For the reasons stated at the top of the file we should always
			find that we can post to the queue.  If we could not then an error
			has occurred. */
			xCoRoutineFlashStatus = pdFAIL;
     544:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <xCoRoutineFlashStatus>
		}

		crDELAY( xHandle, xFlashRates[ uxIndex ] );
     548:	e9 81       	ldd	r30, Y+1	; 0x01
     54a:	f0 e0       	ldi	r31, 0x00	; 0
     54c:	ee 0f       	add	r30, r30
     54e:	ff 1f       	adc	r31, r31
     550:	e0 5e       	subi	r30, 0xE0	; 224
     552:	fe 4f       	sbci	r31, 0xFE	; 254
     554:	80 81       	ld	r24, Z
     556:	91 81       	ldd	r25, Z+1	; 0x01
     558:	00 97       	sbiw	r24, 0x00	; 0
     55a:	21 f0       	breq	.+8      	; 0x564 <prvFixedDelayCoRoutine+0xa8>
     55c:	60 e0       	ldi	r22, 0x00	; 0
     55e:	70 e0       	ldi	r23, 0x00	; 0
     560:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vCoRoutineAddToDelayedList>
     564:	86 e9       	ldi	r24, 0x96	; 150
     566:	91 e0       	ldi	r25, 0x01	; 1
     568:	f8 01       	movw	r30, r16
     56a:	91 8f       	std	Z+25, r25	; 0x19
     56c:	80 8f       	std	Z+24, r24	; 0x18
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
     56e:	0f 90       	pop	r0
     570:	df 91       	pop	r29
     572:	cf 91       	pop	r28
     574:	1f 91       	pop	r17
     576:	0f 91       	pop	r16
     578:	08 95       	ret

0000057a <vStartFlashCoRoutines>:

/*
 * See the header file for details.
 */
void vStartFlashCoRoutines( UBaseType_t uxNumberToCreate )
{
     57a:	cf 93       	push	r28
     57c:	df 93       	push	r29
     57e:	d8 2f       	mov	r29, r24
     580:	89 30       	cpi	r24, 0x09	; 9
     582:	08 f0       	brcs	.+2      	; 0x586 <vStartFlashCoRoutines+0xc>
     584:	d8 e0       	ldi	r29, 0x08	; 8
	{
		uxNumberToCreate = crfMAX_FLASH_TASKS;
	}

	/* Create the queue used to pass data between the co-routines. */
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );
     586:	40 e0       	ldi	r20, 0x00	; 0
     588:	61 e0       	ldi	r22, 0x01	; 1
     58a:	81 e0       	ldi	r24, 0x01	; 1
     58c:	0e 94 08 08 	call	0x1010	; 0x1010 <xQueueGenericCreate>
     590:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <xFlashQueue+0x1>
     594:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <xFlashQueue>

	if( xFlashQueue )
     598:	89 2b       	or	r24, r25
     59a:	91 f0       	breq	.+36     	; 0x5c0 <vStartFlashCoRoutines+0x46>
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
     59c:	dd 23       	and	r29, r29
     59e:	51 f0       	breq	.+20     	; 0x5b4 <vStartFlashCoRoutines+0x3a>
     5a0:	c0 e0       	ldi	r28, 0x00	; 0
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
     5a2:	4c 2f       	mov	r20, r28
     5a4:	60 e0       	ldi	r22, 0x00	; 0
     5a6:	8e e5       	ldi	r24, 0x5E	; 94
     5a8:	92 e0       	ldi	r25, 0x02	; 2
     5aa:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <xCoRoutineCreate>
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );

	if( xFlashQueue )
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
     5ae:	cf 5f       	subi	r28, 0xFF	; 255
     5b0:	dc 13       	cpse	r29, r28
     5b2:	f7 cf       	rjmp	.-18     	; 0x5a2 <vStartFlashCoRoutines+0x28>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
     5b4:	40 e0       	ldi	r20, 0x00	; 0
     5b6:	61 e0       	ldi	r22, 0x01	; 1
     5b8:	83 e1       	ldi	r24, 0x13	; 19
     5ba:	92 e0       	ldi	r25, 0x02	; 2
     5bc:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <xCoRoutineCreate>
	}
}
     5c0:	df 91       	pop	r29
     5c2:	cf 91       	pop	r28
     5c4:	08 95       	ret

000005c6 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     5c6:	cf 92       	push	r12
     5c8:	df 92       	push	r13
     5ca:	ef 92       	push	r14
     5cc:	ff 92       	push	r15
     5ce:	1f 93       	push	r17
     5d0:	cf 93       	push	r28
     5d2:	df 93       	push	r29
     5d4:	6c 01       	movw	r12, r24
     5d6:	16 2f       	mov	r17, r22
     5d8:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     5da:	8a e1       	ldi	r24, 0x1A	; 26
     5dc:	90 e0       	ldi	r25, 0x00	; 0
     5de:	0e 94 e5 06 	call	0xdca	; 0xdca <pvPortMalloc>
     5e2:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
     5e4:	89 2b       	or	r24, r25
     5e6:	09 f4       	brne	.+2      	; 0x5ea <xCoRoutineCreate+0x24>
     5e8:	5d c0       	rjmp	.+186    	; 0x6a4 <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     5ea:	80 91 63 01 	lds	r24, 0x0163	; 0x800163 <pxCurrentCoRoutine>
     5ee:	90 91 64 01 	lds	r25, 0x0164	; 0x800164 <pxCurrentCoRoutine+0x1>
     5f2:	89 2b       	or	r24, r25
     5f4:	21 f5       	brne	.+72     	; 0x63e <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     5f6:	d0 93 64 01 	sts	0x0164, r29	; 0x800164 <pxCurrentCoRoutine+0x1>
     5fa:	c0 93 63 01 	sts	0x0163, r28	; 0x800163 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     5fe:	84 e8       	ldi	r24, 0x84	; 132
     600:	91 e0       	ldi	r25, 0x01	; 1
     602:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
     606:	8d e8       	ldi	r24, 0x8D	; 141
     608:	91 e0       	ldi	r25, 0x01	; 1
     60a:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     60e:	8b e7       	ldi	r24, 0x7B	; 123
     610:	91 e0       	ldi	r25, 0x01	; 1
     612:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     616:	82 e7       	ldi	r24, 0x72	; 114
     618:	91 e0       	ldi	r25, 0x01	; 1
     61a:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     61e:	85 e6       	ldi	r24, 0x65	; 101
     620:	91 e0       	ldi	r25, 0x01	; 1
     622:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     626:	8b e7       	ldi	r24, 0x7B	; 123
     628:	91 e0       	ldi	r25, 0x01	; 1
     62a:	90 93 71 01 	sts	0x0171, r25	; 0x800171 <pxDelayedCoRoutineList+0x1>
     62e:	80 93 70 01 	sts	0x0170, r24	; 0x800170 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     632:	82 e7       	ldi	r24, 0x72	; 114
     634:	91 e0       	ldi	r25, 0x01	; 1
     636:	90 93 6f 01 	sts	0x016F, r25	; 0x80016f <pxOverflowDelayedCoRoutineList+0x1>
     63a:	80 93 6e 01 	sts	0x016E, r24	; 0x80016e <pxOverflowDelayedCoRoutineList>
     63e:	11 11       	cpse	r17, r1
     640:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     642:	19 8e       	std	Y+25, r1	; 0x19
     644:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     646:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     648:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     64a:	fe 01       	movw	r30, r28
     64c:	c1 92       	st	Z+, r12
     64e:	d1 92       	st	Z+, r13
     650:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     652:	cf 01       	movw	r24, r30
     654:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     658:	ce 01       	movw	r24, r28
     65a:	0c 96       	adiw	r24, 0x0c	; 12
     65c:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     660:	d9 87       	std	Y+9, r29	; 0x09
     662:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     664:	db 8b       	std	Y+19, r29	; 0x13
     666:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     668:	82 e0       	ldi	r24, 0x02	; 2
     66a:	90 e0       	ldi	r25, 0x00	; 0
     66c:	81 1b       	sub	r24, r17
     66e:	91 09       	sbc	r25, r1
     670:	9d 87       	std	Y+13, r25	; 0x0d
     672:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     674:	8e 89       	ldd	r24, Y+22	; 0x16
     676:	90 91 62 01 	lds	r25, 0x0162	; 0x800162 <uxTopCoRoutineReadyPriority>
     67a:	98 17       	cp	r25, r24
     67c:	10 f4       	brcc	.+4      	; 0x682 <xCoRoutineCreate+0xbc>
     67e:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <uxTopCoRoutineReadyPriority>
     682:	90 e0       	ldi	r25, 0x00	; 0
     684:	9c 01       	movw	r18, r24
     686:	22 0f       	add	r18, r18
     688:	33 1f       	adc	r19, r19
     68a:	22 0f       	add	r18, r18
     68c:	33 1f       	adc	r19, r19
     68e:	22 0f       	add	r18, r18
     690:	33 1f       	adc	r19, r19
     692:	82 0f       	add	r24, r18
     694:	93 1f       	adc	r25, r19
     696:	b7 01       	movw	r22, r14
     698:	8c 57       	subi	r24, 0x7C	; 124
     69a:	9e 4f       	sbci	r25, 0xFE	; 254
     69c:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsertEnd>

		xReturn = pdPASS;
     6a0:	81 e0       	ldi	r24, 0x01	; 1
     6a2:	01 c0       	rjmp	.+2      	; 0x6a6 <xCoRoutineCreate+0xe0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     6a4:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
     6a6:	df 91       	pop	r29
     6a8:	cf 91       	pop	r28
     6aa:	1f 91       	pop	r17
     6ac:	ff 90       	pop	r15
     6ae:	ef 90       	pop	r14
     6b0:	df 90       	pop	r13
     6b2:	cf 90       	pop	r12
     6b4:	08 95       	ret

000006b6 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     6b6:	0f 93       	push	r16
     6b8:	1f 93       	push	r17
     6ba:	cf 93       	push	r28
     6bc:	df 93       	push	r29
     6be:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     6c0:	c0 91 60 01 	lds	r28, 0x0160	; 0x800160 <xCoRoutineTickCount>
     6c4:	d0 91 61 01 	lds	r29, 0x0161	; 0x800161 <xCoRoutineTickCount+0x1>
     6c8:	c8 0f       	add	r28, r24
     6ca:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     6cc:	80 91 63 01 	lds	r24, 0x0163	; 0x800163 <pxCurrentCoRoutine>
     6d0:	90 91 64 01 	lds	r25, 0x0164	; 0x800164 <pxCurrentCoRoutine+0x1>
     6d4:	02 96       	adiw	r24, 0x02	; 2
     6d6:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     6da:	e0 91 63 01 	lds	r30, 0x0163	; 0x800163 <pxCurrentCoRoutine>
     6de:	f0 91 64 01 	lds	r31, 0x0164	; 0x800164 <pxCurrentCoRoutine+0x1>
     6e2:	d3 83       	std	Z+3, r29	; 0x03
     6e4:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     6e6:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <xCoRoutineTickCount>
     6ea:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <xCoRoutineTickCount+0x1>
     6ee:	c8 17       	cp	r28, r24
     6f0:	d9 07       	cpc	r29, r25
     6f2:	50 f4       	brcc	.+20     	; 0x708 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     6f4:	bf 01       	movw	r22, r30
     6f6:	6e 5f       	subi	r22, 0xFE	; 254
     6f8:	7f 4f       	sbci	r23, 0xFF	; 255
     6fa:	80 91 6e 01 	lds	r24, 0x016E	; 0x80016e <pxOverflowDelayedCoRoutineList>
     6fe:	90 91 6f 01 	lds	r25, 0x016F	; 0x80016f <pxOverflowDelayedCoRoutineList+0x1>
     702:	0e 94 30 05 	call	0xa60	; 0xa60 <vListInsert>
     706:	09 c0       	rjmp	.+18     	; 0x71a <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     708:	bf 01       	movw	r22, r30
     70a:	6e 5f       	subi	r22, 0xFE	; 254
     70c:	7f 4f       	sbci	r23, 0xFF	; 255
     70e:	80 91 70 01 	lds	r24, 0x0170	; 0x800170 <pxDelayedCoRoutineList>
     712:	90 91 71 01 	lds	r25, 0x0171	; 0x800171 <pxDelayedCoRoutineList+0x1>
     716:	0e 94 30 05 	call	0xa60	; 0xa60 <vListInsert>
	}

	if( pxEventList )
     71a:	01 15       	cp	r16, r1
     71c:	11 05       	cpc	r17, r1
     71e:	49 f0       	breq	.+18     	; 0x732 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     720:	60 91 63 01 	lds	r22, 0x0163	; 0x800163 <pxCurrentCoRoutine>
     724:	70 91 64 01 	lds	r23, 0x0164	; 0x800164 <pxCurrentCoRoutine+0x1>
     728:	64 5f       	subi	r22, 0xF4	; 244
     72a:	7f 4f       	sbci	r23, 0xFF	; 255
     72c:	c8 01       	movw	r24, r16
     72e:	0e 94 30 05 	call	0xa60	; 0xa60 <vListInsert>
	}
}
     732:	df 91       	pop	r29
     734:	cf 91       	pop	r28
     736:	1f 91       	pop	r17
     738:	0f 91       	pop	r16
     73a:	08 95       	ret

0000073c <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     73c:	ef 92       	push	r14
     73e:	ff 92       	push	r15
     740:	0f 93       	push	r16
     742:	1f 93       	push	r17
     744:	cf 93       	push	r28
     746:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     748:	80 91 65 01 	lds	r24, 0x0165	; 0x800165 <xPendingReadyCoRoutineList>
     74c:	88 23       	and	r24, r24
     74e:	99 f1       	breq	.+102    	; 0x7b6 <vCoRoutineSchedule+0x7a>
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     750:	0f 2e       	mov	r0, r31
     752:	f5 e6       	ldi	r31, 0x65	; 101
     754:	ef 2e       	mov	r14, r31
     756:	f1 e0       	ldi	r31, 0x01	; 1
     758:	ff 2e       	mov	r15, r31
     75a:	f0 2d       	mov	r31, r0
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     75c:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     75e:	d7 01       	movw	r26, r14
     760:	15 96       	adiw	r26, 0x05	; 5
     762:	ed 91       	ld	r30, X+
     764:	fc 91       	ld	r31, X
     766:	16 97       	sbiw	r26, 0x06	; 6
     768:	c6 81       	ldd	r28, Z+6	; 0x06
     76a:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     76c:	ce 01       	movw	r24, r28
     76e:	0c 96       	adiw	r24, 0x0c	; 12
     770:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     774:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     776:	8e 01       	movw	r16, r28
     778:	0e 5f       	subi	r16, 0xFE	; 254
     77a:	1f 4f       	sbci	r17, 0xFF	; 255
     77c:	c8 01       	movw	r24, r16
     77e:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     782:	8e 89       	ldd	r24, Y+22	; 0x16
     784:	90 91 62 01 	lds	r25, 0x0162	; 0x800162 <uxTopCoRoutineReadyPriority>
     788:	98 17       	cp	r25, r24
     78a:	10 f4       	brcc	.+4      	; 0x790 <vCoRoutineSchedule+0x54>
     78c:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <uxTopCoRoutineReadyPriority>
     790:	90 e0       	ldi	r25, 0x00	; 0
     792:	9c 01       	movw	r18, r24
     794:	22 0f       	add	r18, r18
     796:	33 1f       	adc	r19, r19
     798:	22 0f       	add	r18, r18
     79a:	33 1f       	adc	r19, r19
     79c:	22 0f       	add	r18, r18
     79e:	33 1f       	adc	r19, r19
     7a0:	82 0f       	add	r24, r18
     7a2:	93 1f       	adc	r25, r19
     7a4:	b8 01       	movw	r22, r16
     7a6:	8c 57       	subi	r24, 0x7C	; 124
     7a8:	9e 4f       	sbci	r25, 0xFE	; 254
     7aa:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     7ae:	f7 01       	movw	r30, r14
     7b0:	80 81       	ld	r24, Z
     7b2:	81 11       	cpse	r24, r1
     7b4:	d3 cf       	rjmp	.-90     	; 0x75c <vCoRoutineSchedule+0x20>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     7b6:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <xTaskGetTickCount>
     7ba:	20 91 5e 01 	lds	r18, 0x015E	; 0x80015e <xLastTickCount>
     7be:	30 91 5f 01 	lds	r19, 0x015F	; 0x80015f <xLastTickCount+0x1>
     7c2:	82 1b       	sub	r24, r18
     7c4:	93 0b       	sbc	r25, r19
     7c6:	90 93 5d 01 	sts	0x015D, r25	; 0x80015d <xPassedTicks+0x1>
     7ca:	80 93 5c 01 	sts	0x015C, r24	; 0x80015c <xPassedTicks>
     7ce:	6f c0       	rjmp	.+222    	; 0x8ae <vCoRoutineSchedule+0x172>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     7d0:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <xCoRoutineTickCount>
     7d4:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <xCoRoutineTickCount+0x1>
     7d8:	01 96       	adiw	r24, 0x01	; 1
     7da:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <xCoRoutineTickCount+0x1>
     7de:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <xCoRoutineTickCount>
		xPassedTicks--;
     7e2:	21 50       	subi	r18, 0x01	; 1
     7e4:	31 09       	sbc	r19, r1
     7e6:	30 93 5d 01 	sts	0x015D, r19	; 0x80015d <xPassedTicks+0x1>
     7ea:	20 93 5c 01 	sts	0x015C, r18	; 0x80015c <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     7ee:	00 97       	sbiw	r24, 0x00	; 0
     7f0:	81 f4       	brne	.+32     	; 0x812 <vCoRoutineSchedule+0xd6>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     7f2:	20 91 70 01 	lds	r18, 0x0170	; 0x800170 <pxDelayedCoRoutineList>
     7f6:	30 91 71 01 	lds	r19, 0x0171	; 0x800171 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     7fa:	40 91 6e 01 	lds	r20, 0x016E	; 0x80016e <pxOverflowDelayedCoRoutineList>
     7fe:	50 91 6f 01 	lds	r21, 0x016F	; 0x80016f <pxOverflowDelayedCoRoutineList+0x1>
     802:	50 93 71 01 	sts	0x0171, r21	; 0x800171 <pxDelayedCoRoutineList+0x1>
     806:	40 93 70 01 	sts	0x0170, r20	; 0x800170 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
     80a:	30 93 6f 01 	sts	0x016F, r19	; 0x80016f <pxOverflowDelayedCoRoutineList+0x1>
     80e:	20 93 6e 01 	sts	0x016E, r18	; 0x80016e <pxOverflowDelayedCoRoutineList>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     812:	e0 91 70 01 	lds	r30, 0x0170	; 0x800170 <pxDelayedCoRoutineList>
     816:	f0 91 71 01 	lds	r31, 0x0171	; 0x800171 <pxDelayedCoRoutineList+0x1>
     81a:	20 81       	ld	r18, Z
     81c:	22 23       	and	r18, r18
     81e:	09 f4       	brne	.+2      	; 0x822 <vCoRoutineSchedule+0xe6>
     820:	46 c0       	rjmp	.+140    	; 0x8ae <vCoRoutineSchedule+0x172>
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     822:	05 80       	ldd	r0, Z+5	; 0x05
     824:	f6 81       	ldd	r31, Z+6	; 0x06
     826:	e0 2d       	mov	r30, r0
     828:	c6 81       	ldd	r28, Z+6	; 0x06
     82a:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     82c:	2a 81       	ldd	r18, Y+2	; 0x02
     82e:	3b 81       	ldd	r19, Y+3	; 0x03
     830:	82 17       	cp	r24, r18
     832:	93 07       	cpc	r25, r19
     834:	78 f4       	brcc	.+30     	; 0x854 <vCoRoutineSchedule+0x118>
     836:	3b c0       	rjmp	.+118    	; 0x8ae <vCoRoutineSchedule+0x172>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     838:	05 80       	ldd	r0, Z+5	; 0x05
     83a:	f6 81       	ldd	r31, Z+6	; 0x06
     83c:	e0 2d       	mov	r30, r0
     83e:	c6 81       	ldd	r28, Z+6	; 0x06
     840:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     842:	2a 81       	ldd	r18, Y+2	; 0x02
     844:	3b 81       	ldd	r19, Y+3	; 0x03
     846:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <xCoRoutineTickCount>
     84a:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <xCoRoutineTickCount+0x1>
     84e:	82 17       	cp	r24, r18
     850:	93 07       	cpc	r25, r19
     852:	68 f1       	brcs	.+90     	; 0x8ae <vCoRoutineSchedule+0x172>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     854:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     856:	8e 01       	movw	r16, r28
     858:	0e 5f       	subi	r16, 0xFE	; 254
     85a:	1f 4f       	sbci	r17, 0xFF	; 255
     85c:	c8 01       	movw	r24, r16
     85e:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     862:	8c 89       	ldd	r24, Y+20	; 0x14
     864:	9d 89       	ldd	r25, Y+21	; 0x15
     866:	89 2b       	or	r24, r25
     868:	21 f0       	breq	.+8      	; 0x872 <vCoRoutineSchedule+0x136>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     86a:	ce 01       	movw	r24, r28
     86c:	0c 96       	adiw	r24, 0x0c	; 12
     86e:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     872:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     874:	8e 89       	ldd	r24, Y+22	; 0x16
     876:	90 91 62 01 	lds	r25, 0x0162	; 0x800162 <uxTopCoRoutineReadyPriority>
     87a:	98 17       	cp	r25, r24
     87c:	10 f4       	brcc	.+4      	; 0x882 <vCoRoutineSchedule+0x146>
     87e:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <uxTopCoRoutineReadyPriority>
     882:	90 e0       	ldi	r25, 0x00	; 0
     884:	9c 01       	movw	r18, r24
     886:	22 0f       	add	r18, r18
     888:	33 1f       	adc	r19, r19
     88a:	22 0f       	add	r18, r18
     88c:	33 1f       	adc	r19, r19
     88e:	22 0f       	add	r18, r18
     890:	33 1f       	adc	r19, r19
     892:	82 0f       	add	r24, r18
     894:	93 1f       	adc	r25, r19
     896:	b8 01       	movw	r22, r16
     898:	8c 57       	subi	r24, 0x7C	; 124
     89a:	9e 4f       	sbci	r25, 0xFE	; 254
     89c:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     8a0:	e0 91 70 01 	lds	r30, 0x0170	; 0x800170 <pxDelayedCoRoutineList>
     8a4:	f0 91 71 01 	lds	r31, 0x0171	; 0x800171 <pxDelayedCoRoutineList+0x1>
     8a8:	80 81       	ld	r24, Z
     8aa:	81 11       	cpse	r24, r1
     8ac:	c5 cf       	rjmp	.-118    	; 0x838 <vCoRoutineSchedule+0xfc>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     8ae:	20 91 5c 01 	lds	r18, 0x015C	; 0x80015c <xPassedTicks>
     8b2:	30 91 5d 01 	lds	r19, 0x015D	; 0x80015d <xPassedTicks+0x1>
     8b6:	21 15       	cp	r18, r1
     8b8:	31 05       	cpc	r19, r1
     8ba:	09 f0       	breq	.+2      	; 0x8be <vCoRoutineSchedule+0x182>
     8bc:	89 cf       	rjmp	.-238    	; 0x7d0 <vCoRoutineSchedule+0x94>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     8be:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <xCoRoutineTickCount>
     8c2:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <xCoRoutineTickCount+0x1>
     8c6:	90 93 5f 01 	sts	0x015F, r25	; 0x80015f <xLastTickCount+0x1>
     8ca:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <xLastTickCount>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     8ce:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <uxTopCoRoutineReadyPriority>
     8d2:	28 2f       	mov	r18, r24
     8d4:	30 e0       	ldi	r19, 0x00	; 0
     8d6:	f9 01       	movw	r30, r18
     8d8:	ee 0f       	add	r30, r30
     8da:	ff 1f       	adc	r31, r31
     8dc:	ee 0f       	add	r30, r30
     8de:	ff 1f       	adc	r31, r31
     8e0:	ee 0f       	add	r30, r30
     8e2:	ff 1f       	adc	r31, r31
     8e4:	e2 0f       	add	r30, r18
     8e6:	f3 1f       	adc	r31, r19
     8e8:	ec 57       	subi	r30, 0x7C	; 124
     8ea:	fe 4f       	sbci	r31, 0xFE	; 254
     8ec:	90 81       	ld	r25, Z
     8ee:	91 11       	cpse	r25, r1
     8f0:	1b c0       	rjmp	.+54     	; 0x928 <__stack+0x29>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     8f2:	81 11       	cpse	r24, r1
     8f4:	06 c0       	rjmp	.+12     	; 0x902 <__stack+0x3>
     8f6:	55 c0       	rjmp	.+170    	; 0x9a2 <__stack+0xa3>
     8f8:	81 11       	cpse	r24, r1
     8fa:	03 c0       	rjmp	.+6      	; 0x902 <__stack+0x3>
     8fc:	10 92 62 01 	sts	0x0162, r1	; 0x800162 <uxTopCoRoutineReadyPriority>
     900:	50 c0       	rjmp	.+160    	; 0x9a2 <__stack+0xa3>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     902:	81 50       	subi	r24, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     904:	28 2f       	mov	r18, r24
     906:	30 e0       	ldi	r19, 0x00	; 0
     908:	f9 01       	movw	r30, r18
     90a:	ee 0f       	add	r30, r30
     90c:	ff 1f       	adc	r31, r31
     90e:	ee 0f       	add	r30, r30
     910:	ff 1f       	adc	r31, r31
     912:	ee 0f       	add	r30, r30
     914:	ff 1f       	adc	r31, r31
     916:	e2 0f       	add	r30, r18
     918:	f3 1f       	adc	r31, r19
     91a:	ec 57       	subi	r30, 0x7C	; 124
     91c:	fe 4f       	sbci	r31, 0xFE	; 254
     91e:	90 81       	ld	r25, Z
     920:	99 23       	and	r25, r25
     922:	51 f3       	breq	.-44     	; 0x8f8 <vCoRoutineSchedule+0x1bc>
     924:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <uxTopCoRoutineReadyPriority>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     928:	c9 01       	movw	r24, r18
     92a:	88 0f       	add	r24, r24
     92c:	99 1f       	adc	r25, r25
     92e:	88 0f       	add	r24, r24
     930:	99 1f       	adc	r25, r25
     932:	88 0f       	add	r24, r24
     934:	99 1f       	adc	r25, r25
     936:	82 0f       	add	r24, r18
     938:	93 1f       	adc	r25, r19
     93a:	dc 01       	movw	r26, r24
     93c:	ac 57       	subi	r26, 0x7C	; 124
     93e:	be 4f       	sbci	r27, 0xFE	; 254
     940:	11 96       	adiw	r26, 0x01	; 1
     942:	ed 91       	ld	r30, X+
     944:	fc 91       	ld	r31, X
     946:	12 97       	sbiw	r26, 0x02	; 2
     948:	02 80       	ldd	r0, Z+2	; 0x02
     94a:	f3 81       	ldd	r31, Z+3	; 0x03
     94c:	e0 2d       	mov	r30, r0
     94e:	12 96       	adiw	r26, 0x02	; 2
     950:	fc 93       	st	X, r31
     952:	ee 93       	st	-X, r30
     954:	11 97       	sbiw	r26, 0x01	; 1
     956:	89 57       	subi	r24, 0x79	; 121
     958:	9e 4f       	sbci	r25, 0xFE	; 254
     95a:	e8 17       	cp	r30, r24
     95c:	f9 07       	cpc	r31, r25
     95e:	29 f4       	brne	.+10     	; 0x96a <__stack+0x6b>
     960:	82 81       	ldd	r24, Z+2	; 0x02
     962:	93 81       	ldd	r25, Z+3	; 0x03
     964:	fd 01       	movw	r30, r26
     966:	92 83       	std	Z+2, r25	; 0x02
     968:	81 83       	std	Z+1, r24	; 0x01
     96a:	f9 01       	movw	r30, r18
     96c:	ee 0f       	add	r30, r30
     96e:	ff 1f       	adc	r31, r31
     970:	ee 0f       	add	r30, r30
     972:	ff 1f       	adc	r31, r31
     974:	ee 0f       	add	r30, r30
     976:	ff 1f       	adc	r31, r31
     978:	2e 0f       	add	r18, r30
     97a:	3f 1f       	adc	r19, r31
     97c:	f9 01       	movw	r30, r18
     97e:	ec 57       	subi	r30, 0x7C	; 124
     980:	fe 4f       	sbci	r31, 0xFE	; 254
     982:	01 80       	ldd	r0, Z+1	; 0x01
     984:	f2 81       	ldd	r31, Z+2	; 0x02
     986:	e0 2d       	mov	r30, r0
     988:	86 81       	ldd	r24, Z+6	; 0x06
     98a:	97 81       	ldd	r25, Z+7	; 0x07
     98c:	90 93 64 01 	sts	0x0164, r25	; 0x800164 <pxCurrentCoRoutine+0x1>
     990:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     994:	dc 01       	movw	r26, r24
     996:	ed 91       	ld	r30, X+
     998:	fc 91       	ld	r31, X
     99a:	11 97       	sbiw	r26, 0x01	; 1
     99c:	57 96       	adiw	r26, 0x17	; 23
     99e:	6c 91       	ld	r22, X
     9a0:	09 95       	icall

	return;
}
     9a2:	df 91       	pop	r29
     9a4:	cf 91       	pop	r28
     9a6:	1f 91       	pop	r17
     9a8:	0f 91       	pop	r16
     9aa:	ff 90       	pop	r15
     9ac:	ef 90       	pop	r14
     9ae:	08 95       	ret

000009b0 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     9b0:	0f 93       	push	r16
     9b2:	1f 93       	push	r17
     9b4:	cf 93       	push	r28
     9b6:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     9b8:	dc 01       	movw	r26, r24
     9ba:	15 96       	adiw	r26, 0x05	; 5
     9bc:	ed 91       	ld	r30, X+
     9be:	fc 91       	ld	r31, X
     9c0:	16 97       	sbiw	r26, 0x06	; 6
     9c2:	c6 81       	ldd	r28, Z+6	; 0x06
     9c4:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     9c6:	8e 01       	movw	r16, r28
     9c8:	04 5f       	subi	r16, 0xF4	; 244
     9ca:	1f 4f       	sbci	r17, 0xFF	; 255
     9cc:	c8 01       	movw	r24, r16
     9ce:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     9d2:	b8 01       	movw	r22, r16
     9d4:	85 e6       	ldi	r24, 0x65	; 101
     9d6:	91 e0       	ldi	r25, 0x01	; 1
     9d8:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     9dc:	e0 91 63 01 	lds	r30, 0x0163	; 0x800163 <pxCurrentCoRoutine>
     9e0:	f0 91 64 01 	lds	r31, 0x0164	; 0x800164 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	2e 89       	ldd	r18, Y+22	; 0x16
     9e8:	96 89       	ldd	r25, Z+22	; 0x16
     9ea:	29 17       	cp	r18, r25
     9ec:	08 f4       	brcc	.+2      	; 0x9f0 <xCoRoutineRemoveFromEventList+0x40>
     9ee:	80 e0       	ldi	r24, 0x00	; 0
}
     9f0:	df 91       	pop	r29
     9f2:	cf 91       	pop	r28
     9f4:	1f 91       	pop	r17
     9f6:	0f 91       	pop	r16
     9f8:	08 95       	ret

000009fa <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     9fa:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9fc:	03 96       	adiw	r24, 0x03	; 3
     9fe:	92 83       	std	Z+2, r25	; 0x02
     a00:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     a02:	2f ef       	ldi	r18, 0xFF	; 255
     a04:	3f ef       	ldi	r19, 0xFF	; 255
     a06:	34 83       	std	Z+4, r19	; 0x04
     a08:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a0a:	96 83       	std	Z+6, r25	; 0x06
     a0c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a0e:	90 87       	std	Z+8, r25	; 0x08
     a10:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     a12:	10 82       	st	Z, r1
     a14:	08 95       	ret

00000a16 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     a16:	fc 01       	movw	r30, r24
     a18:	11 86       	std	Z+9, r1	; 0x09
     a1a:	10 86       	std	Z+8, r1	; 0x08
     a1c:	08 95       	ret

00000a1e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a1e:	cf 93       	push	r28
     a20:	df 93       	push	r29
     a22:	9c 01       	movw	r18, r24
     a24:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     a26:	dc 01       	movw	r26, r24
     a28:	11 96       	adiw	r26, 0x01	; 1
     a2a:	cd 91       	ld	r28, X+
     a2c:	dc 91       	ld	r29, X
     a2e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     a30:	d3 83       	std	Z+3, r29	; 0x03
     a32:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     a34:	8c 81       	ldd	r24, Y+4	; 0x04
     a36:	9d 81       	ldd	r25, Y+5	; 0x05
     a38:	95 83       	std	Z+5, r25	; 0x05
     a3a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     a3c:	8c 81       	ldd	r24, Y+4	; 0x04
     a3e:	9d 81       	ldd	r25, Y+5	; 0x05
     a40:	dc 01       	movw	r26, r24
     a42:	13 96       	adiw	r26, 0x03	; 3
     a44:	7c 93       	st	X, r23
     a46:	6e 93       	st	-X, r22
     a48:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     a4a:	7d 83       	std	Y+5, r23	; 0x05
     a4c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a4e:	31 87       	std	Z+9, r19	; 0x09
     a50:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     a52:	f9 01       	movw	r30, r18
     a54:	80 81       	ld	r24, Z
     a56:	8f 5f       	subi	r24, 0xFF	; 255
     a58:	80 83       	st	Z, r24
}
     a5a:	df 91       	pop	r29
     a5c:	cf 91       	pop	r28
     a5e:	08 95       	ret

00000a60 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a60:	cf 93       	push	r28
     a62:	df 93       	push	r29
     a64:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     a66:	48 81       	ld	r20, Y
     a68:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     a6a:	4f 3f       	cpi	r20, 0xFF	; 255
     a6c:	2f ef       	ldi	r18, 0xFF	; 255
     a6e:	52 07       	cpc	r21, r18
     a70:	21 f4       	brne	.+8      	; 0xa7a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     a72:	fc 01       	movw	r30, r24
     a74:	a7 81       	ldd	r26, Z+7	; 0x07
     a76:	b0 85       	ldd	r27, Z+8	; 0x08
     a78:	0d c0       	rjmp	.+26     	; 0xa94 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a7a:	dc 01       	movw	r26, r24
     a7c:	13 96       	adiw	r26, 0x03	; 3
     a7e:	01 c0       	rjmp	.+2      	; 0xa82 <vListInsert+0x22>
     a80:	df 01       	movw	r26, r30
     a82:	12 96       	adiw	r26, 0x02	; 2
     a84:	ed 91       	ld	r30, X+
     a86:	fc 91       	ld	r31, X
     a88:	13 97       	sbiw	r26, 0x03	; 3
     a8a:	20 81       	ld	r18, Z
     a8c:	31 81       	ldd	r19, Z+1	; 0x01
     a8e:	42 17       	cp	r20, r18
     a90:	53 07       	cpc	r21, r19
     a92:	b0 f7       	brcc	.-20     	; 0xa80 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a94:	12 96       	adiw	r26, 0x02	; 2
     a96:	ed 91       	ld	r30, X+
     a98:	fc 91       	ld	r31, X
     a9a:	13 97       	sbiw	r26, 0x03	; 3
     a9c:	fb 83       	std	Y+3, r31	; 0x03
     a9e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     aa0:	d5 83       	std	Z+5, r29	; 0x05
     aa2:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     aa4:	bd 83       	std	Y+5, r27	; 0x05
     aa6:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     aa8:	13 96       	adiw	r26, 0x03	; 3
     aaa:	dc 93       	st	X, r29
     aac:	ce 93       	st	-X, r28
     aae:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     ab0:	99 87       	std	Y+9, r25	; 0x09
     ab2:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     ab4:	fc 01       	movw	r30, r24
     ab6:	20 81       	ld	r18, Z
     ab8:	2f 5f       	subi	r18, 0xFF	; 255
     aba:	20 83       	st	Z, r18
}
     abc:	df 91       	pop	r29
     abe:	cf 91       	pop	r28
     ac0:	08 95       	ret

00000ac2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     ac2:	cf 93       	push	r28
     ac4:	df 93       	push	r29
     ac6:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     ac8:	a0 85       	ldd	r26, Z+8	; 0x08
     aca:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     acc:	c2 81       	ldd	r28, Z+2	; 0x02
     ace:	d3 81       	ldd	r29, Z+3	; 0x03
     ad0:	84 81       	ldd	r24, Z+4	; 0x04
     ad2:	95 81       	ldd	r25, Z+5	; 0x05
     ad4:	9d 83       	std	Y+5, r25	; 0x05
     ad6:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     ad8:	c4 81       	ldd	r28, Z+4	; 0x04
     ada:	d5 81       	ldd	r29, Z+5	; 0x05
     adc:	82 81       	ldd	r24, Z+2	; 0x02
     ade:	93 81       	ldd	r25, Z+3	; 0x03
     ae0:	9b 83       	std	Y+3, r25	; 0x03
     ae2:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ae4:	11 96       	adiw	r26, 0x01	; 1
     ae6:	8d 91       	ld	r24, X+
     ae8:	9c 91       	ld	r25, X
     aea:	12 97       	sbiw	r26, 0x02	; 2
     aec:	e8 17       	cp	r30, r24
     aee:	f9 07       	cpc	r31, r25
     af0:	31 f4       	brne	.+12     	; 0xafe <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     af2:	84 81       	ldd	r24, Z+4	; 0x04
     af4:	95 81       	ldd	r25, Z+5	; 0x05
     af6:	12 96       	adiw	r26, 0x02	; 2
     af8:	9c 93       	st	X, r25
     afa:	8e 93       	st	-X, r24
     afc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     afe:	11 86       	std	Z+9, r1	; 0x09
     b00:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     b02:	8c 91       	ld	r24, X
     b04:	81 50       	subi	r24, 0x01	; 1
     b06:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     b08:	df 91       	pop	r29
     b0a:	cf 91       	pop	r28
     b0c:	08 95       	ret

00000b0e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     b0e:	31 e1       	ldi	r19, 0x11	; 17
     b10:	fc 01       	movw	r30, r24
     b12:	30 83       	st	Z, r19
     b14:	31 97       	sbiw	r30, 0x01	; 1
     b16:	22 e2       	ldi	r18, 0x22	; 34
     b18:	20 83       	st	Z, r18
     b1a:	31 97       	sbiw	r30, 0x01	; 1
     b1c:	a3 e3       	ldi	r26, 0x33	; 51
     b1e:	a0 83       	st	Z, r26
     b20:	31 97       	sbiw	r30, 0x01	; 1
     b22:	60 83       	st	Z, r22
     b24:	31 97       	sbiw	r30, 0x01	; 1
     b26:	70 83       	st	Z, r23
     b28:	31 97       	sbiw	r30, 0x01	; 1
     b2a:	10 82       	st	Z, r1
     b2c:	31 97       	sbiw	r30, 0x01	; 1
     b2e:	60 e8       	ldi	r22, 0x80	; 128
     b30:	60 83       	st	Z, r22
     b32:	31 97       	sbiw	r30, 0x01	; 1
     b34:	10 82       	st	Z, r1
     b36:	31 97       	sbiw	r30, 0x01	; 1
     b38:	62 e0       	ldi	r22, 0x02	; 2
     b3a:	60 83       	st	Z, r22
     b3c:	31 97       	sbiw	r30, 0x01	; 1
     b3e:	63 e0       	ldi	r22, 0x03	; 3
     b40:	60 83       	st	Z, r22
     b42:	31 97       	sbiw	r30, 0x01	; 1
     b44:	64 e0       	ldi	r22, 0x04	; 4
     b46:	60 83       	st	Z, r22
     b48:	31 97       	sbiw	r30, 0x01	; 1
     b4a:	65 e0       	ldi	r22, 0x05	; 5
     b4c:	60 83       	st	Z, r22
     b4e:	31 97       	sbiw	r30, 0x01	; 1
     b50:	66 e0       	ldi	r22, 0x06	; 6
     b52:	60 83       	st	Z, r22
     b54:	31 97       	sbiw	r30, 0x01	; 1
     b56:	67 e0       	ldi	r22, 0x07	; 7
     b58:	60 83       	st	Z, r22
     b5a:	31 97       	sbiw	r30, 0x01	; 1
     b5c:	68 e0       	ldi	r22, 0x08	; 8
     b5e:	60 83       	st	Z, r22
     b60:	31 97       	sbiw	r30, 0x01	; 1
     b62:	69 e0       	ldi	r22, 0x09	; 9
     b64:	60 83       	st	Z, r22
     b66:	31 97       	sbiw	r30, 0x01	; 1
     b68:	60 e1       	ldi	r22, 0x10	; 16
     b6a:	60 83       	st	Z, r22
     b6c:	31 97       	sbiw	r30, 0x01	; 1
     b6e:	30 83       	st	Z, r19
     b70:	31 97       	sbiw	r30, 0x01	; 1
     b72:	32 e1       	ldi	r19, 0x12	; 18
     b74:	30 83       	st	Z, r19
     b76:	31 97       	sbiw	r30, 0x01	; 1
     b78:	33 e1       	ldi	r19, 0x13	; 19
     b7a:	30 83       	st	Z, r19
     b7c:	31 97       	sbiw	r30, 0x01	; 1
     b7e:	34 e1       	ldi	r19, 0x14	; 20
     b80:	30 83       	st	Z, r19
     b82:	31 97       	sbiw	r30, 0x01	; 1
     b84:	35 e1       	ldi	r19, 0x15	; 21
     b86:	30 83       	st	Z, r19
     b88:	31 97       	sbiw	r30, 0x01	; 1
     b8a:	36 e1       	ldi	r19, 0x16	; 22
     b8c:	30 83       	st	Z, r19
     b8e:	31 97       	sbiw	r30, 0x01	; 1
     b90:	37 e1       	ldi	r19, 0x17	; 23
     b92:	30 83       	st	Z, r19
     b94:	31 97       	sbiw	r30, 0x01	; 1
     b96:	38 e1       	ldi	r19, 0x18	; 24
     b98:	30 83       	st	Z, r19
     b9a:	31 97       	sbiw	r30, 0x01	; 1
     b9c:	39 e1       	ldi	r19, 0x19	; 25
     b9e:	30 83       	st	Z, r19
     ba0:	31 97       	sbiw	r30, 0x01	; 1
     ba2:	30 e2       	ldi	r19, 0x20	; 32
     ba4:	30 83       	st	Z, r19
     ba6:	31 97       	sbiw	r30, 0x01	; 1
     ba8:	31 e2       	ldi	r19, 0x21	; 33
     baa:	30 83       	st	Z, r19
     bac:	31 97       	sbiw	r30, 0x01	; 1
     bae:	20 83       	st	Z, r18
     bb0:	31 97       	sbiw	r30, 0x01	; 1
     bb2:	23 e2       	ldi	r18, 0x23	; 35
     bb4:	20 83       	st	Z, r18
     bb6:	31 97       	sbiw	r30, 0x01	; 1
     bb8:	40 83       	st	Z, r20
     bba:	31 97       	sbiw	r30, 0x01	; 1
     bbc:	50 83       	st	Z, r21
     bbe:	31 97       	sbiw	r30, 0x01	; 1
     bc0:	26 e2       	ldi	r18, 0x26	; 38
     bc2:	20 83       	st	Z, r18
     bc4:	31 97       	sbiw	r30, 0x01	; 1
     bc6:	27 e2       	ldi	r18, 0x27	; 39
     bc8:	20 83       	st	Z, r18
     bca:	31 97       	sbiw	r30, 0x01	; 1
     bcc:	28 e2       	ldi	r18, 0x28	; 40
     bce:	20 83       	st	Z, r18
     bd0:	31 97       	sbiw	r30, 0x01	; 1
     bd2:	29 e2       	ldi	r18, 0x29	; 41
     bd4:	20 83       	st	Z, r18
     bd6:	31 97       	sbiw	r30, 0x01	; 1
     bd8:	20 e3       	ldi	r18, 0x30	; 48
     bda:	20 83       	st	Z, r18
     bdc:	31 97       	sbiw	r30, 0x01	; 1
     bde:	21 e3       	ldi	r18, 0x31	; 49
     be0:	20 83       	st	Z, r18
     be2:	86 97       	sbiw	r24, 0x26	; 38
     be4:	08 95       	ret

00000be6 <xPortStartScheduler>:
     be6:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     bea:	89 ef       	ldi	r24, 0xF9	; 249
     bec:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     bf0:	8b e0       	ldi	r24, 0x0B	; 11
     bf2:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     bf6:	ef e6       	ldi	r30, 0x6F	; 111
     bf8:	f0 e0       	ldi	r31, 0x00	; 0
     bfa:	80 81       	ld	r24, Z
     bfc:	82 60       	ori	r24, 0x02	; 2
     bfe:	80 83       	st	Z, r24
     c00:	a0 91 d1 07 	lds	r26, 0x07D1	; 0x8007d1 <pxCurrentTCB>
     c04:	b0 91 d2 07 	lds	r27, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
     c08:	cd 91       	ld	r28, X+
     c0a:	cd bf       	out	0x3d, r28	; 61
     c0c:	dd 91       	ld	r29, X+
     c0e:	de bf       	out	0x3e, r29	; 62
     c10:	ff 91       	pop	r31
     c12:	ef 91       	pop	r30
     c14:	df 91       	pop	r29
     c16:	cf 91       	pop	r28
     c18:	bf 91       	pop	r27
     c1a:	af 91       	pop	r26
     c1c:	9f 91       	pop	r25
     c1e:	8f 91       	pop	r24
     c20:	7f 91       	pop	r23
     c22:	6f 91       	pop	r22
     c24:	5f 91       	pop	r21
     c26:	4f 91       	pop	r20
     c28:	3f 91       	pop	r19
     c2a:	2f 91       	pop	r18
     c2c:	1f 91       	pop	r17
     c2e:	0f 91       	pop	r16
     c30:	ff 90       	pop	r15
     c32:	ef 90       	pop	r14
     c34:	df 90       	pop	r13
     c36:	cf 90       	pop	r12
     c38:	bf 90       	pop	r11
     c3a:	af 90       	pop	r10
     c3c:	9f 90       	pop	r9
     c3e:	8f 90       	pop	r8
     c40:	7f 90       	pop	r7
     c42:	6f 90       	pop	r6
     c44:	5f 90       	pop	r5
     c46:	4f 90       	pop	r4
     c48:	3f 90       	pop	r3
     c4a:	2f 90       	pop	r2
     c4c:	1f 90       	pop	r1
     c4e:	0f 90       	pop	r0
     c50:	0f be       	out	0x3f, r0	; 63
     c52:	0f 90       	pop	r0
     c54:	08 95       	ret
     c56:	81 e0       	ldi	r24, 0x01	; 1
     c58:	08 95       	ret

00000c5a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     c5a:	0f 92       	push	r0
     c5c:	0f b6       	in	r0, 0x3f	; 63
     c5e:	f8 94       	cli
     c60:	0f 92       	push	r0
     c62:	1f 92       	push	r1
     c64:	11 24       	eor	r1, r1
     c66:	2f 92       	push	r2
     c68:	3f 92       	push	r3
     c6a:	4f 92       	push	r4
     c6c:	5f 92       	push	r5
     c6e:	6f 92       	push	r6
     c70:	7f 92       	push	r7
     c72:	8f 92       	push	r8
     c74:	9f 92       	push	r9
     c76:	af 92       	push	r10
     c78:	bf 92       	push	r11
     c7a:	cf 92       	push	r12
     c7c:	df 92       	push	r13
     c7e:	ef 92       	push	r14
     c80:	ff 92       	push	r15
     c82:	0f 93       	push	r16
     c84:	1f 93       	push	r17
     c86:	2f 93       	push	r18
     c88:	3f 93       	push	r19
     c8a:	4f 93       	push	r20
     c8c:	5f 93       	push	r21
     c8e:	6f 93       	push	r22
     c90:	7f 93       	push	r23
     c92:	8f 93       	push	r24
     c94:	9f 93       	push	r25
     c96:	af 93       	push	r26
     c98:	bf 93       	push	r27
     c9a:	cf 93       	push	r28
     c9c:	df 93       	push	r29
     c9e:	ef 93       	push	r30
     ca0:	ff 93       	push	r31
     ca2:	a0 91 d1 07 	lds	r26, 0x07D1	; 0x8007d1 <pxCurrentTCB>
     ca6:	b0 91 d2 07 	lds	r27, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
     caa:	0d b6       	in	r0, 0x3d	; 61
     cac:	0d 92       	st	X+, r0
     cae:	0e b6       	in	r0, 0x3e	; 62
     cb0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     cb2:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     cb6:	a0 91 d1 07 	lds	r26, 0x07D1	; 0x8007d1 <pxCurrentTCB>
     cba:	b0 91 d2 07 	lds	r27, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
     cbe:	cd 91       	ld	r28, X+
     cc0:	cd bf       	out	0x3d, r28	; 61
     cc2:	dd 91       	ld	r29, X+
     cc4:	de bf       	out	0x3e, r29	; 62
     cc6:	ff 91       	pop	r31
     cc8:	ef 91       	pop	r30
     cca:	df 91       	pop	r29
     ccc:	cf 91       	pop	r28
     cce:	bf 91       	pop	r27
     cd0:	af 91       	pop	r26
     cd2:	9f 91       	pop	r25
     cd4:	8f 91       	pop	r24
     cd6:	7f 91       	pop	r23
     cd8:	6f 91       	pop	r22
     cda:	5f 91       	pop	r21
     cdc:	4f 91       	pop	r20
     cde:	3f 91       	pop	r19
     ce0:	2f 91       	pop	r18
     ce2:	1f 91       	pop	r17
     ce4:	0f 91       	pop	r16
     ce6:	ff 90       	pop	r15
     ce8:	ef 90       	pop	r14
     cea:	df 90       	pop	r13
     cec:	cf 90       	pop	r12
     cee:	bf 90       	pop	r11
     cf0:	af 90       	pop	r10
     cf2:	9f 90       	pop	r9
     cf4:	8f 90       	pop	r8
     cf6:	7f 90       	pop	r7
     cf8:	6f 90       	pop	r6
     cfa:	5f 90       	pop	r5
     cfc:	4f 90       	pop	r4
     cfe:	3f 90       	pop	r3
     d00:	2f 90       	pop	r2
     d02:	1f 90       	pop	r1
     d04:	0f 90       	pop	r0
     d06:	0f be       	out	0x3f, r0	; 63
     d08:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d0a:	08 95       	ret

00000d0c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     d0c:	0f 92       	push	r0
     d0e:	0f b6       	in	r0, 0x3f	; 63
     d10:	f8 94       	cli
     d12:	0f 92       	push	r0
     d14:	1f 92       	push	r1
     d16:	11 24       	eor	r1, r1
     d18:	2f 92       	push	r2
     d1a:	3f 92       	push	r3
     d1c:	4f 92       	push	r4
     d1e:	5f 92       	push	r5
     d20:	6f 92       	push	r6
     d22:	7f 92       	push	r7
     d24:	8f 92       	push	r8
     d26:	9f 92       	push	r9
     d28:	af 92       	push	r10
     d2a:	bf 92       	push	r11
     d2c:	cf 92       	push	r12
     d2e:	df 92       	push	r13
     d30:	ef 92       	push	r14
     d32:	ff 92       	push	r15
     d34:	0f 93       	push	r16
     d36:	1f 93       	push	r17
     d38:	2f 93       	push	r18
     d3a:	3f 93       	push	r19
     d3c:	4f 93       	push	r20
     d3e:	5f 93       	push	r21
     d40:	6f 93       	push	r22
     d42:	7f 93       	push	r23
     d44:	8f 93       	push	r24
     d46:	9f 93       	push	r25
     d48:	af 93       	push	r26
     d4a:	bf 93       	push	r27
     d4c:	cf 93       	push	r28
     d4e:	df 93       	push	r29
     d50:	ef 93       	push	r30
     d52:	ff 93       	push	r31
     d54:	a0 91 d1 07 	lds	r26, 0x07D1	; 0x8007d1 <pxCurrentTCB>
     d58:	b0 91 d2 07 	lds	r27, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
     d5c:	0d b6       	in	r0, 0x3d	; 61
     d5e:	0d 92       	st	X+, r0
     d60:	0e b6       	in	r0, 0x3e	; 62
     d62:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     d64:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <xTaskIncrementTick>
     d68:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     d6a:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     d6e:	a0 91 d1 07 	lds	r26, 0x07D1	; 0x8007d1 <pxCurrentTCB>
     d72:	b0 91 d2 07 	lds	r27, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
     d76:	cd 91       	ld	r28, X+
     d78:	cd bf       	out	0x3d, r28	; 61
     d7a:	dd 91       	ld	r29, X+
     d7c:	de bf       	out	0x3e, r29	; 62
     d7e:	ff 91       	pop	r31
     d80:	ef 91       	pop	r30
     d82:	df 91       	pop	r29
     d84:	cf 91       	pop	r28
     d86:	bf 91       	pop	r27
     d88:	af 91       	pop	r26
     d8a:	9f 91       	pop	r25
     d8c:	8f 91       	pop	r24
     d8e:	7f 91       	pop	r23
     d90:	6f 91       	pop	r22
     d92:	5f 91       	pop	r21
     d94:	4f 91       	pop	r20
     d96:	3f 91       	pop	r19
     d98:	2f 91       	pop	r18
     d9a:	1f 91       	pop	r17
     d9c:	0f 91       	pop	r16
     d9e:	ff 90       	pop	r15
     da0:	ef 90       	pop	r14
     da2:	df 90       	pop	r13
     da4:	cf 90       	pop	r12
     da6:	bf 90       	pop	r11
     da8:	af 90       	pop	r10
     daa:	9f 90       	pop	r9
     dac:	8f 90       	pop	r8
     dae:	7f 90       	pop	r7
     db0:	6f 90       	pop	r6
     db2:	5f 90       	pop	r5
     db4:	4f 90       	pop	r4
     db6:	3f 90       	pop	r3
     db8:	2f 90       	pop	r2
     dba:	1f 90       	pop	r1
     dbc:	0f 90       	pop	r0
     dbe:	0f be       	out	0x3f, r0	; 63
     dc0:	0f 90       	pop	r0

	asm volatile ( "ret" );
     dc2:	08 95       	ret

00000dc4 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     dc4:	0e 94 86 06 	call	0xd0c	; 0xd0c <vPortYieldFromTick>
		asm volatile ( "reti" );
     dc8:	18 95       	reti

00000dca <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     dca:	cf 93       	push	r28
     dcc:	df 93       	push	r29
     dce:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     dd0:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     dd4:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <pucAlignedHeap.2068>
     dd8:	90 91 97 01 	lds	r25, 0x0197	; 0x800197 <pucAlignedHeap.2068+0x1>
     ddc:	89 2b       	or	r24, r25
     dde:	31 f4       	brne	.+12     	; 0xdec <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     de0:	8b e9       	ldi	r24, 0x9B	; 155
     de2:	91 e0       	ldi	r25, 0x01	; 1
     de4:	90 93 97 01 	sts	0x0197, r25	; 0x800197 <pucAlignedHeap.2068+0x1>
     de8:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <pucAlignedHeap.2068>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     dec:	20 91 98 01 	lds	r18, 0x0198	; 0x800198 <xNextFreeByte>
     df0:	30 91 99 01 	lds	r19, 0x0199	; 0x800199 <xNextFreeByte+0x1>
     df4:	c9 01       	movw	r24, r18
     df6:	8c 0f       	add	r24, r28
     df8:	9d 1f       	adc	r25, r29
     dfa:	8b 3d       	cpi	r24, 0xDB	; 219
     dfc:	45 e0       	ldi	r20, 0x05	; 5
     dfe:	94 07       	cpc	r25, r20
     e00:	70 f4       	brcc	.+28     	; 0xe1e <pvPortMalloc+0x54>
     e02:	28 17       	cp	r18, r24
     e04:	39 07       	cpc	r19, r25
     e06:	70 f4       	brcc	.+28     	; 0xe24 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     e08:	c0 91 96 01 	lds	r28, 0x0196	; 0x800196 <pucAlignedHeap.2068>
     e0c:	d0 91 97 01 	lds	r29, 0x0197	; 0x800197 <pucAlignedHeap.2068+0x1>
     e10:	c2 0f       	add	r28, r18
     e12:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     e14:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <xNextFreeByte+0x1>
     e18:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <xNextFreeByte>
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     e1e:	c0 e0       	ldi	r28, 0x00	; 0
     e20:	d0 e0       	ldi	r29, 0x00	; 0
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <pvPortMalloc+0x5e>
     e24:	c0 e0       	ldi	r28, 0x00	; 0
     e26:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     e28:	0e 94 29 0c 	call	0x1852	; 0x1852 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     e2c:	ce 01       	movw	r24, r28
     e2e:	df 91       	pop	r29
     e30:	cf 91       	pop	r28
     e32:	08 95       	ret

00000e34 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     e34:	08 95       	ret

00000e36 <prvCopyDataToQueue>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     e36:	0f 93       	push	r16
     e38:	1f 93       	push	r17
     e3a:	cf 93       	push	r28
     e3c:	df 93       	push	r29
     e3e:	ec 01       	movw	r28, r24
     e40:	04 2f       	mov	r16, r20
     e42:	1a 8d       	ldd	r17, Y+26	; 0x1a
     e44:	4c 8d       	ldd	r20, Y+28	; 0x1c
     e46:	44 23       	and	r20, r20
     e48:	b9 f1       	breq	.+110    	; 0xeb8 <prvCopyDataToQueue+0x82>
     e4a:	01 11       	cpse	r16, r1
     e4c:	16 c0       	rjmp	.+44     	; 0xe7a <prvCopyDataToQueue+0x44>
     e4e:	50 e0       	ldi	r21, 0x00	; 0
     e50:	8c 81       	ldd	r24, Y+4	; 0x04
     e52:	9d 81       	ldd	r25, Y+5	; 0x05
     e54:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <memcpy>
     e58:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e5a:	8c 81       	ldd	r24, Y+4	; 0x04
     e5c:	9d 81       	ldd	r25, Y+5	; 0x05
     e5e:	82 0f       	add	r24, r18
     e60:	91 1d       	adc	r25, r1
     e62:	9d 83       	std	Y+5, r25	; 0x05
     e64:	8c 83       	std	Y+4, r24	; 0x04
     e66:	2a 81       	ldd	r18, Y+2	; 0x02
     e68:	3b 81       	ldd	r19, Y+3	; 0x03
     e6a:	82 17       	cp	r24, r18
     e6c:	93 07       	cpc	r25, r19
     e6e:	20 f1       	brcs	.+72     	; 0xeb8 <prvCopyDataToQueue+0x82>
     e70:	88 81       	ld	r24, Y
     e72:	99 81       	ldd	r25, Y+1	; 0x01
     e74:	9d 83       	std	Y+5, r25	; 0x05
     e76:	8c 83       	std	Y+4, r24	; 0x04
     e78:	1f c0       	rjmp	.+62     	; 0xeb8 <prvCopyDataToQueue+0x82>
     e7a:	50 e0       	ldi	r21, 0x00	; 0
     e7c:	8e 81       	ldd	r24, Y+6	; 0x06
     e7e:	9f 81       	ldd	r25, Y+7	; 0x07
     e80:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <memcpy>
     e84:	8c 8d       	ldd	r24, Y+28	; 0x1c
     e86:	90 e0       	ldi	r25, 0x00	; 0
     e88:	91 95       	neg	r25
     e8a:	81 95       	neg	r24
     e8c:	91 09       	sbc	r25, r1
     e8e:	2e 81       	ldd	r18, Y+6	; 0x06
     e90:	3f 81       	ldd	r19, Y+7	; 0x07
     e92:	28 0f       	add	r18, r24
     e94:	39 1f       	adc	r19, r25
     e96:	3f 83       	std	Y+7, r19	; 0x07
     e98:	2e 83       	std	Y+6, r18	; 0x06
     e9a:	48 81       	ld	r20, Y
     e9c:	59 81       	ldd	r21, Y+1	; 0x01
     e9e:	24 17       	cp	r18, r20
     ea0:	35 07       	cpc	r19, r21
     ea2:	30 f4       	brcc	.+12     	; 0xeb0 <prvCopyDataToQueue+0x7a>
     ea4:	2a 81       	ldd	r18, Y+2	; 0x02
     ea6:	3b 81       	ldd	r19, Y+3	; 0x03
     ea8:	82 0f       	add	r24, r18
     eaa:	93 1f       	adc	r25, r19
     eac:	9f 83       	std	Y+7, r25	; 0x07
     eae:	8e 83       	std	Y+6, r24	; 0x06
     eb0:	02 30       	cpi	r16, 0x02	; 2
     eb2:	11 f4       	brne	.+4      	; 0xeb8 <prvCopyDataToQueue+0x82>
     eb4:	11 11       	cpse	r17, r1
     eb6:	11 50       	subi	r17, 0x01	; 1
     eb8:	1f 5f       	subi	r17, 0xFF	; 255
     eba:	1a 8f       	std	Y+26, r17	; 0x1a
     ebc:	80 e0       	ldi	r24, 0x00	; 0
     ebe:	df 91       	pop	r29
     ec0:	cf 91       	pop	r28
     ec2:	1f 91       	pop	r17
     ec4:	0f 91       	pop	r16
     ec6:	08 95       	ret

00000ec8 <prvCopyDataFromQueue>:
     ec8:	fc 01       	movw	r30, r24
     eca:	44 8d       	ldd	r20, Z+28	; 0x1c
     ecc:	44 23       	and	r20, r20
     ece:	a9 f0       	breq	.+42     	; 0xefa <prvCopyDataFromQueue+0x32>
     ed0:	50 e0       	ldi	r21, 0x00	; 0
     ed2:	26 81       	ldd	r18, Z+6	; 0x06
     ed4:	37 81       	ldd	r19, Z+7	; 0x07
     ed6:	24 0f       	add	r18, r20
     ed8:	35 1f       	adc	r19, r21
     eda:	37 83       	std	Z+7, r19	; 0x07
     edc:	26 83       	std	Z+6, r18	; 0x06
     ede:	82 81       	ldd	r24, Z+2	; 0x02
     ee0:	93 81       	ldd	r25, Z+3	; 0x03
     ee2:	28 17       	cp	r18, r24
     ee4:	39 07       	cpc	r19, r25
     ee6:	20 f0       	brcs	.+8      	; 0xef0 <prvCopyDataFromQueue+0x28>
     ee8:	80 81       	ld	r24, Z
     eea:	91 81       	ldd	r25, Z+1	; 0x01
     eec:	97 83       	std	Z+7, r25	; 0x07
     eee:	86 83       	std	Z+6, r24	; 0x06
     ef0:	cb 01       	movw	r24, r22
     ef2:	66 81       	ldd	r22, Z+6	; 0x06
     ef4:	77 81       	ldd	r23, Z+7	; 0x07
     ef6:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <memcpy>
     efa:	08 95       	ret

00000efc <prvUnlockQueue>:
     efc:	ef 92       	push	r14
     efe:	ff 92       	push	r15
     f00:	0f 93       	push	r16
     f02:	1f 93       	push	r17
     f04:	cf 93       	push	r28
     f06:	8c 01       	movw	r16, r24
     f08:	0f b6       	in	r0, 0x3f	; 63
     f0a:	f8 94       	cli
     f0c:	0f 92       	push	r0
     f0e:	fc 01       	movw	r30, r24
     f10:	c6 8d       	ldd	r28, Z+30	; 0x1e
     f12:	1c 16       	cp	r1, r28
     f14:	ac f4       	brge	.+42     	; 0xf40 <prvUnlockQueue+0x44>
     f16:	81 89       	ldd	r24, Z+17	; 0x11
     f18:	81 11       	cpse	r24, r1
     f1a:	06 c0       	rjmp	.+12     	; 0xf28 <prvUnlockQueue+0x2c>
     f1c:	11 c0       	rjmp	.+34     	; 0xf40 <prvUnlockQueue+0x44>
     f1e:	f8 01       	movw	r30, r16
     f20:	81 89       	ldd	r24, Z+17	; 0x11
     f22:	81 11       	cpse	r24, r1
     f24:	05 c0       	rjmp	.+10     	; 0xf30 <prvUnlockQueue+0x34>
     f26:	0c c0       	rjmp	.+24     	; 0xf40 <prvUnlockQueue+0x44>
     f28:	78 01       	movw	r14, r16
     f2a:	f1 e1       	ldi	r31, 0x11	; 17
     f2c:	ef 0e       	add	r14, r31
     f2e:	f1 1c       	adc	r15, r1
     f30:	c7 01       	movw	r24, r14
     f32:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <xTaskRemoveFromEventList>
     f36:	81 11       	cpse	r24, r1
     f38:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <vTaskMissedYield>
     f3c:	c1 50       	subi	r28, 0x01	; 1
     f3e:	79 f7       	brne	.-34     	; 0xf1e <prvUnlockQueue+0x22>
     f40:	8f ef       	ldi	r24, 0xFF	; 255
     f42:	f8 01       	movw	r30, r16
     f44:	86 8f       	std	Z+30, r24	; 0x1e
     f46:	0f 90       	pop	r0
     f48:	0f be       	out	0x3f, r0	; 63
     f4a:	0f b6       	in	r0, 0x3f	; 63
     f4c:	f8 94       	cli
     f4e:	0f 92       	push	r0
     f50:	c5 8d       	ldd	r28, Z+29	; 0x1d
     f52:	1c 16       	cp	r1, r28
     f54:	ac f4       	brge	.+42     	; 0xf80 <prvUnlockQueue+0x84>
     f56:	80 85       	ldd	r24, Z+8	; 0x08
     f58:	81 11       	cpse	r24, r1
     f5a:	06 c0       	rjmp	.+12     	; 0xf68 <prvUnlockQueue+0x6c>
     f5c:	11 c0       	rjmp	.+34     	; 0xf80 <prvUnlockQueue+0x84>
     f5e:	f8 01       	movw	r30, r16
     f60:	80 85       	ldd	r24, Z+8	; 0x08
     f62:	81 11       	cpse	r24, r1
     f64:	05 c0       	rjmp	.+10     	; 0xf70 <prvUnlockQueue+0x74>
     f66:	0c c0       	rjmp	.+24     	; 0xf80 <prvUnlockQueue+0x84>
     f68:	78 01       	movw	r14, r16
     f6a:	f8 e0       	ldi	r31, 0x08	; 8
     f6c:	ef 0e       	add	r14, r31
     f6e:	f1 1c       	adc	r15, r1
     f70:	c7 01       	movw	r24, r14
     f72:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <xTaskRemoveFromEventList>
     f76:	81 11       	cpse	r24, r1
     f78:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <vTaskMissedYield>
     f7c:	c1 50       	subi	r28, 0x01	; 1
     f7e:	79 f7       	brne	.-34     	; 0xf5e <prvUnlockQueue+0x62>
     f80:	8f ef       	ldi	r24, 0xFF	; 255
     f82:	f8 01       	movw	r30, r16
     f84:	85 8f       	std	Z+29, r24	; 0x1d
     f86:	0f 90       	pop	r0
     f88:	0f be       	out	0x3f, r0	; 63
     f8a:	cf 91       	pop	r28
     f8c:	1f 91       	pop	r17
     f8e:	0f 91       	pop	r16
     f90:	ff 90       	pop	r15
     f92:	ef 90       	pop	r14
     f94:	08 95       	ret

00000f96 <xQueueGenericReset>:
     f96:	cf 93       	push	r28
     f98:	df 93       	push	r29
     f9a:	ec 01       	movw	r28, r24
     f9c:	0f b6       	in	r0, 0x3f	; 63
     f9e:	f8 94       	cli
     fa0:	0f 92       	push	r0
     fa2:	48 81       	ld	r20, Y
     fa4:	59 81       	ldd	r21, Y+1	; 0x01
     fa6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     fa8:	30 e0       	ldi	r19, 0x00	; 0
     faa:	7b 8d       	ldd	r23, Y+27	; 0x1b
     fac:	72 9f       	mul	r23, r18
     fae:	c0 01       	movw	r24, r0
     fb0:	73 9f       	mul	r23, r19
     fb2:	90 0d       	add	r25, r0
     fb4:	11 24       	eor	r1, r1
     fb6:	fa 01       	movw	r30, r20
     fb8:	e8 0f       	add	r30, r24
     fba:	f9 1f       	adc	r31, r25
     fbc:	fb 83       	std	Y+3, r31	; 0x03
     fbe:	ea 83       	std	Y+2, r30	; 0x02
     fc0:	1a 8e       	std	Y+26, r1	; 0x1a
     fc2:	5d 83       	std	Y+5, r21	; 0x05
     fc4:	4c 83       	std	Y+4, r20	; 0x04
     fc6:	82 1b       	sub	r24, r18
     fc8:	93 0b       	sbc	r25, r19
     fca:	84 0f       	add	r24, r20
     fcc:	95 1f       	adc	r25, r21
     fce:	9f 83       	std	Y+7, r25	; 0x07
     fd0:	8e 83       	std	Y+6, r24	; 0x06
     fd2:	8f ef       	ldi	r24, 0xFF	; 255
     fd4:	8d 8f       	std	Y+29, r24	; 0x1d
     fd6:	8e 8f       	std	Y+30, r24	; 0x1e
     fd8:	61 11       	cpse	r22, r1
     fda:	0c c0       	rjmp	.+24     	; 0xff4 <xQueueGenericReset+0x5e>
     fdc:	88 85       	ldd	r24, Y+8	; 0x08
     fde:	88 23       	and	r24, r24
     fe0:	89 f0       	breq	.+34     	; 0x1004 <xQueueGenericReset+0x6e>
     fe2:	ce 01       	movw	r24, r28
     fe4:	08 96       	adiw	r24, 0x08	; 8
     fe6:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <xTaskRemoveFromEventList>
     fea:	88 23       	and	r24, r24
     fec:	59 f0       	breq	.+22     	; 0x1004 <xQueueGenericReset+0x6e>
     fee:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vPortYield>
     ff2:	08 c0       	rjmp	.+16     	; 0x1004 <xQueueGenericReset+0x6e>
     ff4:	ce 01       	movw	r24, r28
     ff6:	08 96       	adiw	r24, 0x08	; 8
     ff8:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
     ffc:	ce 01       	movw	r24, r28
     ffe:	41 96       	adiw	r24, 0x11	; 17
    1000:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
    1004:	0f 90       	pop	r0
    1006:	0f be       	out	0x3f, r0	; 63
    1008:	81 e0       	ldi	r24, 0x01	; 1
    100a:	df 91       	pop	r29
    100c:	cf 91       	pop	r28
    100e:	08 95       	ret

00001010 <xQueueGenericCreate>:
    1010:	0f 93       	push	r16
    1012:	1f 93       	push	r17
    1014:	cf 93       	push	r28
    1016:	df 93       	push	r29
    1018:	08 2f       	mov	r16, r24
    101a:	16 2f       	mov	r17, r22
    101c:	66 23       	and	r22, r22
    101e:	c1 f0       	breq	.+48     	; 0x1050 <xQueueGenericCreate+0x40>
    1020:	86 9f       	mul	r24, r22
    1022:	c0 01       	movw	r24, r0
    1024:	11 24       	eor	r1, r1
    1026:	4f 96       	adiw	r24, 0x1f	; 31
    1028:	0e 94 e5 06 	call	0xdca	; 0xdca <pvPortMalloc>
    102c:	ec 01       	movw	r28, r24
    102e:	00 97       	sbiw	r24, 0x00	; 0
    1030:	41 f4       	brne	.+16     	; 0x1042 <xQueueGenericCreate+0x32>
    1032:	15 c0       	rjmp	.+42     	; 0x105e <xQueueGenericCreate+0x4e>
    1034:	0b 8f       	std	Y+27, r16	; 0x1b
    1036:	1c 8f       	std	Y+28, r17	; 0x1c
    1038:	61 e0       	ldi	r22, 0x01	; 1
    103a:	ce 01       	movw	r24, r28
    103c:	0e 94 cb 07 	call	0xf96	; 0xf96 <xQueueGenericReset>
    1040:	0e c0       	rjmp	.+28     	; 0x105e <xQueueGenericCreate+0x4e>
    1042:	4f 96       	adiw	r24, 0x1f	; 31
    1044:	99 83       	std	Y+1, r25	; 0x01
    1046:	88 83       	st	Y, r24
    1048:	f5 cf       	rjmp	.-22     	; 0x1034 <xQueueGenericCreate+0x24>
    104a:	d9 83       	std	Y+1, r29	; 0x01
    104c:	c8 83       	st	Y, r28
    104e:	f2 cf       	rjmp	.-28     	; 0x1034 <xQueueGenericCreate+0x24>
    1050:	8f e1       	ldi	r24, 0x1F	; 31
    1052:	90 e0       	ldi	r25, 0x00	; 0
    1054:	0e 94 e5 06 	call	0xdca	; 0xdca <pvPortMalloc>
    1058:	ec 01       	movw	r28, r24
    105a:	89 2b       	or	r24, r25
    105c:	b1 f7       	brne	.-20     	; 0x104a <xQueueGenericCreate+0x3a>
    105e:	ce 01       	movw	r24, r28
    1060:	df 91       	pop	r29
    1062:	cf 91       	pop	r28
    1064:	1f 91       	pop	r17
    1066:	0f 91       	pop	r16
    1068:	08 95       	ret

0000106a <xQueueGenericSend>:
    106a:	9f 92       	push	r9
    106c:	af 92       	push	r10
    106e:	bf 92       	push	r11
    1070:	cf 92       	push	r12
    1072:	df 92       	push	r13
    1074:	ef 92       	push	r14
    1076:	ff 92       	push	r15
    1078:	0f 93       	push	r16
    107a:	1f 93       	push	r17
    107c:	cf 93       	push	r28
    107e:	df 93       	push	r29
    1080:	00 d0       	rcall	.+0      	; 0x1082 <xQueueGenericSend+0x18>
    1082:	00 d0       	rcall	.+0      	; 0x1084 <xQueueGenericSend+0x1a>
    1084:	1f 92       	push	r1
    1086:	cd b7       	in	r28, 0x3d	; 61
    1088:	de b7       	in	r29, 0x3e	; 62
    108a:	8c 01       	movw	r16, r24
    108c:	6b 01       	movw	r12, r22
    108e:	5d 83       	std	Y+5, r21	; 0x05
    1090:	4c 83       	std	Y+4, r20	; 0x04
    1092:	a2 2e       	mov	r10, r18
    1094:	b1 2c       	mov	r11, r1
    1096:	99 24       	eor	r9, r9
    1098:	93 94       	inc	r9
    109a:	7c 01       	movw	r14, r24
    109c:	88 e0       	ldi	r24, 0x08	; 8
    109e:	e8 0e       	add	r14, r24
    10a0:	f1 1c       	adc	r15, r1
    10a2:	0f b6       	in	r0, 0x3f	; 63
    10a4:	f8 94       	cli
    10a6:	0f 92       	push	r0
    10a8:	f8 01       	movw	r30, r16
    10aa:	92 8d       	ldd	r25, Z+26	; 0x1a
    10ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    10ae:	98 17       	cp	r25, r24
    10b0:	18 f0       	brcs	.+6      	; 0x10b8 <xQueueGenericSend+0x4e>
    10b2:	f2 e0       	ldi	r31, 0x02	; 2
    10b4:	af 12       	cpse	r10, r31
    10b6:	19 c0       	rjmp	.+50     	; 0x10ea <xQueueGenericSend+0x80>
    10b8:	4a 2d       	mov	r20, r10
    10ba:	b6 01       	movw	r22, r12
    10bc:	c8 01       	movw	r24, r16
    10be:	0e 94 1b 07 	call	0xe36	; 0xe36 <prvCopyDataToQueue>
    10c2:	f8 01       	movw	r30, r16
    10c4:	91 89       	ldd	r25, Z+17	; 0x11
    10c6:	99 23       	and	r25, r25
    10c8:	49 f0       	breq	.+18     	; 0x10dc <xQueueGenericSend+0x72>
    10ca:	c8 01       	movw	r24, r16
    10cc:	41 96       	adiw	r24, 0x11	; 17
    10ce:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <xTaskRemoveFromEventList>
    10d2:	88 23       	and	r24, r24
    10d4:	31 f0       	breq	.+12     	; 0x10e2 <xQueueGenericSend+0x78>
    10d6:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vPortYield>
    10da:	03 c0       	rjmp	.+6      	; 0x10e2 <xQueueGenericSend+0x78>
    10dc:	81 11       	cpse	r24, r1
    10de:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vPortYield>
    10e2:	0f 90       	pop	r0
    10e4:	0f be       	out	0x3f, r0	; 63
    10e6:	81 e0       	ldi	r24, 0x01	; 1
    10e8:	50 c0       	rjmp	.+160    	; 0x118a <xQueueGenericSend+0x120>
    10ea:	8c 81       	ldd	r24, Y+4	; 0x04
    10ec:	9d 81       	ldd	r25, Y+5	; 0x05
    10ee:	89 2b       	or	r24, r25
    10f0:	21 f4       	brne	.+8      	; 0x10fa <xQueueGenericSend+0x90>
    10f2:	0f 90       	pop	r0
    10f4:	0f be       	out	0x3f, r0	; 63
    10f6:	80 e0       	ldi	r24, 0x00	; 0
    10f8:	48 c0       	rjmp	.+144    	; 0x118a <xQueueGenericSend+0x120>
    10fa:	b1 10       	cpse	r11, r1
    10fc:	05 c0       	rjmp	.+10     	; 0x1108 <xQueueGenericSend+0x9e>
    10fe:	ce 01       	movw	r24, r28
    1100:	01 96       	adiw	r24, 0x01	; 1
    1102:	0e 94 bb 0d 	call	0x1b76	; 0x1b76 <vTaskSetTimeOutState>
    1106:	b9 2c       	mov	r11, r9
    1108:	0f 90       	pop	r0
    110a:	0f be       	out	0x3f, r0	; 63
    110c:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <vTaskSuspendAll>
    1110:	0f b6       	in	r0, 0x3f	; 63
    1112:	f8 94       	cli
    1114:	0f 92       	push	r0
    1116:	f8 01       	movw	r30, r16
    1118:	85 8d       	ldd	r24, Z+29	; 0x1d
    111a:	8f 3f       	cpi	r24, 0xFF	; 255
    111c:	09 f4       	brne	.+2      	; 0x1120 <xQueueGenericSend+0xb6>
    111e:	15 8e       	std	Z+29, r1	; 0x1d
    1120:	f8 01       	movw	r30, r16
    1122:	86 8d       	ldd	r24, Z+30	; 0x1e
    1124:	8f 3f       	cpi	r24, 0xFF	; 255
    1126:	09 f4       	brne	.+2      	; 0x112a <xQueueGenericSend+0xc0>
    1128:	16 8e       	std	Z+30, r1	; 0x1e
    112a:	0f 90       	pop	r0
    112c:	0f be       	out	0x3f, r0	; 63
    112e:	be 01       	movw	r22, r28
    1130:	6c 5f       	subi	r22, 0xFC	; 252
    1132:	7f 4f       	sbci	r23, 0xFF	; 255
    1134:	ce 01       	movw	r24, r28
    1136:	01 96       	adiw	r24, 0x01	; 1
    1138:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <xTaskCheckForTimeOut>
    113c:	81 11       	cpse	r24, r1
    113e:	1f c0       	rjmp	.+62     	; 0x117e <xQueueGenericSend+0x114>
    1140:	0f b6       	in	r0, 0x3f	; 63
    1142:	f8 94       	cli
    1144:	0f 92       	push	r0
    1146:	f8 01       	movw	r30, r16
    1148:	92 8d       	ldd	r25, Z+26	; 0x1a
    114a:	0f 90       	pop	r0
    114c:	0f be       	out	0x3f, r0	; 63
    114e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1150:	98 13       	cpse	r25, r24
    1152:	0f c0       	rjmp	.+30     	; 0x1172 <xQueueGenericSend+0x108>
    1154:	6c 81       	ldd	r22, Y+4	; 0x04
    1156:	7d 81       	ldd	r23, Y+5	; 0x05
    1158:	c7 01       	movw	r24, r14
    115a:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <vTaskPlaceOnEventList>
    115e:	c8 01       	movw	r24, r16
    1160:	0e 94 7e 07 	call	0xefc	; 0xefc <prvUnlockQueue>
    1164:	0e 94 29 0c 	call	0x1852	; 0x1852 <xTaskResumeAll>
    1168:	81 11       	cpse	r24, r1
    116a:	9b cf       	rjmp	.-202    	; 0x10a2 <xQueueGenericSend+0x38>
    116c:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vPortYield>
    1170:	98 cf       	rjmp	.-208    	; 0x10a2 <xQueueGenericSend+0x38>
    1172:	c8 01       	movw	r24, r16
    1174:	0e 94 7e 07 	call	0xefc	; 0xefc <prvUnlockQueue>
    1178:	0e 94 29 0c 	call	0x1852	; 0x1852 <xTaskResumeAll>
    117c:	92 cf       	rjmp	.-220    	; 0x10a2 <xQueueGenericSend+0x38>
    117e:	c8 01       	movw	r24, r16
    1180:	0e 94 7e 07 	call	0xefc	; 0xefc <prvUnlockQueue>
    1184:	0e 94 29 0c 	call	0x1852	; 0x1852 <xTaskResumeAll>
    1188:	80 e0       	ldi	r24, 0x00	; 0
    118a:	0f 90       	pop	r0
    118c:	0f 90       	pop	r0
    118e:	0f 90       	pop	r0
    1190:	0f 90       	pop	r0
    1192:	0f 90       	pop	r0
    1194:	df 91       	pop	r29
    1196:	cf 91       	pop	r28
    1198:	1f 91       	pop	r17
    119a:	0f 91       	pop	r16
    119c:	ff 90       	pop	r15
    119e:	ef 90       	pop	r14
    11a0:	df 90       	pop	r13
    11a2:	cf 90       	pop	r12
    11a4:	bf 90       	pop	r11
    11a6:	af 90       	pop	r10
    11a8:	9f 90       	pop	r9
    11aa:	08 95       	ret

000011ac <xQueueGenericSendFromISR>:
    11ac:	ef 92       	push	r14
    11ae:	ff 92       	push	r15
    11b0:	0f 93       	push	r16
    11b2:	1f 93       	push	r17
    11b4:	cf 93       	push	r28
    11b6:	df 93       	push	r29
    11b8:	8a 01       	movw	r16, r20
    11ba:	fc 01       	movw	r30, r24
    11bc:	52 8d       	ldd	r21, Z+26	; 0x1a
    11be:	33 8d       	ldd	r19, Z+27	; 0x1b
    11c0:	53 17       	cp	r21, r19
    11c2:	10 f0       	brcs	.+4      	; 0x11c8 <xQueueGenericSendFromISR+0x1c>
    11c4:	22 30       	cpi	r18, 0x02	; 2
    11c6:	f1 f4       	brne	.+60     	; 0x1204 <xQueueGenericSendFromISR+0x58>
    11c8:	42 2f       	mov	r20, r18
    11ca:	78 01       	movw	r14, r16
    11cc:	ec 01       	movw	r28, r24
    11ce:	1e 8d       	ldd	r17, Y+30	; 0x1e
    11d0:	0e 94 1b 07 	call	0xe36	; 0xe36 <prvCopyDataToQueue>
    11d4:	1f 3f       	cpi	r17, 0xFF	; 255
    11d6:	81 f4       	brne	.+32     	; 0x11f8 <xQueueGenericSendFromISR+0x4c>
    11d8:	89 89       	ldd	r24, Y+17	; 0x11
    11da:	88 23       	and	r24, r24
    11dc:	a9 f0       	breq	.+42     	; 0x1208 <xQueueGenericSendFromISR+0x5c>
    11de:	ce 01       	movw	r24, r28
    11e0:	41 96       	adiw	r24, 0x11	; 17
    11e2:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <xTaskRemoveFromEventList>
    11e6:	88 23       	and	r24, r24
    11e8:	89 f0       	breq	.+34     	; 0x120c <xQueueGenericSendFromISR+0x60>
    11ea:	e1 14       	cp	r14, r1
    11ec:	f1 04       	cpc	r15, r1
    11ee:	81 f0       	breq	.+32     	; 0x1210 <xQueueGenericSendFromISR+0x64>
    11f0:	81 e0       	ldi	r24, 0x01	; 1
    11f2:	f7 01       	movw	r30, r14
    11f4:	80 83       	st	Z, r24
    11f6:	0d c0       	rjmp	.+26     	; 0x1212 <xQueueGenericSendFromISR+0x66>
    11f8:	ff 24       	eor	r15, r15
    11fa:	f3 94       	inc	r15
    11fc:	f1 0e       	add	r15, r17
    11fe:	fe 8e       	std	Y+30, r15	; 0x1e
    1200:	81 e0       	ldi	r24, 0x01	; 1
    1202:	07 c0       	rjmp	.+14     	; 0x1212 <xQueueGenericSendFromISR+0x66>
    1204:	80 e0       	ldi	r24, 0x00	; 0
    1206:	05 c0       	rjmp	.+10     	; 0x1212 <xQueueGenericSendFromISR+0x66>
    1208:	81 e0       	ldi	r24, 0x01	; 1
    120a:	03 c0       	rjmp	.+6      	; 0x1212 <xQueueGenericSendFromISR+0x66>
    120c:	81 e0       	ldi	r24, 0x01	; 1
    120e:	01 c0       	rjmp	.+2      	; 0x1212 <xQueueGenericSendFromISR+0x66>
    1210:	81 e0       	ldi	r24, 0x01	; 1
    1212:	df 91       	pop	r29
    1214:	cf 91       	pop	r28
    1216:	1f 91       	pop	r17
    1218:	0f 91       	pop	r16
    121a:	ff 90       	pop	r15
    121c:	ef 90       	pop	r14
    121e:	08 95       	ret

00001220 <xQueueReceiveFromISR>:
    1220:	ef 92       	push	r14
    1222:	ff 92       	push	r15
    1224:	0f 93       	push	r16
    1226:	1f 93       	push	r17
    1228:	cf 93       	push	r28
    122a:	df 93       	push	r29
    122c:	fc 01       	movw	r30, r24
    122e:	c2 8d       	ldd	r28, Z+26	; 0x1a
    1230:	cc 23       	and	r28, r28
    1232:	f9 f0       	breq	.+62     	; 0x1272 <xQueueReceiveFromISR+0x52>
    1234:	7a 01       	movw	r14, r20
    1236:	8c 01       	movw	r16, r24
    1238:	d5 8d       	ldd	r29, Z+29	; 0x1d
    123a:	0e 94 64 07 	call	0xec8	; 0xec8 <prvCopyDataFromQueue>
    123e:	c1 50       	subi	r28, 0x01	; 1
    1240:	f8 01       	movw	r30, r16
    1242:	c2 8f       	std	Z+26, r28	; 0x1a
    1244:	df 3f       	cpi	r29, 0xFF	; 255
    1246:	81 f4       	brne	.+32     	; 0x1268 <xQueueReceiveFromISR+0x48>
    1248:	80 85       	ldd	r24, Z+8	; 0x08
    124a:	88 23       	and	r24, r24
    124c:	a1 f0       	breq	.+40     	; 0x1276 <xQueueReceiveFromISR+0x56>
    124e:	c8 01       	movw	r24, r16
    1250:	08 96       	adiw	r24, 0x08	; 8
    1252:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <xTaskRemoveFromEventList>
    1256:	88 23       	and	r24, r24
    1258:	81 f0       	breq	.+32     	; 0x127a <xQueueReceiveFromISR+0x5a>
    125a:	e1 14       	cp	r14, r1
    125c:	f1 04       	cpc	r15, r1
    125e:	79 f0       	breq	.+30     	; 0x127e <xQueueReceiveFromISR+0x5e>
    1260:	81 e0       	ldi	r24, 0x01	; 1
    1262:	f7 01       	movw	r30, r14
    1264:	80 83       	st	Z, r24
    1266:	0c c0       	rjmp	.+24     	; 0x1280 <xQueueReceiveFromISR+0x60>
    1268:	df 5f       	subi	r29, 0xFF	; 255
    126a:	f8 01       	movw	r30, r16
    126c:	d5 8f       	std	Z+29, r29	; 0x1d
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	07 c0       	rjmp	.+14     	; 0x1280 <xQueueReceiveFromISR+0x60>
    1272:	80 e0       	ldi	r24, 0x00	; 0
    1274:	05 c0       	rjmp	.+10     	; 0x1280 <xQueueReceiveFromISR+0x60>
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	03 c0       	rjmp	.+6      	; 0x1280 <xQueueReceiveFromISR+0x60>
    127a:	81 e0       	ldi	r24, 0x01	; 1
    127c:	01 c0       	rjmp	.+2      	; 0x1280 <xQueueReceiveFromISR+0x60>
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	df 91       	pop	r29
    1282:	cf 91       	pop	r28
    1284:	1f 91       	pop	r17
    1286:	0f 91       	pop	r16
    1288:	ff 90       	pop	r15
    128a:	ef 90       	pop	r14
    128c:	08 95       	ret

0000128e <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    128e:	cf 93       	push	r28
    1290:	df 93       	push	r29
    1292:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1294:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1296:	0f b6       	in	r0, 0x3f	; 63
    1298:	f8 94       	cli
    129a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    129c:	2a 8d       	ldd	r18, Y+26	; 0x1a
    129e:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12a0:	0f 90       	pop	r0
    12a2:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    12a4:	29 13       	cpse	r18, r25
    12a6:	0f c0       	rjmp	.+30     	; 0x12c6 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    12a8:	41 15       	cp	r20, r1
    12aa:	51 05       	cpc	r21, r1
    12ac:	49 f0       	breq	.+18     	; 0x12c0 <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    12ae:	be 01       	movw	r22, r28
    12b0:	68 5f       	subi	r22, 0xF8	; 248
    12b2:	7f 4f       	sbci	r23, 0xFF	; 255
    12b4:	ca 01       	movw	r24, r20
    12b6:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    12ba:	78 94       	sei
					return errQUEUE_BLOCKED;
    12bc:	8c ef       	ldi	r24, 0xFC	; 252
    12be:	1d c0       	rjmp	.+58     	; 0x12fa <xQueueCRSend+0x6c>
				}
				else
				{
					portENABLE_INTERRUPTS();
    12c0:	78 94       	sei
					return errQUEUE_FULL;
    12c2:	80 e0       	ldi	r24, 0x00	; 0
    12c4:	1a c0       	rjmp	.+52     	; 0x12fa <xQueueCRSend+0x6c>
				}
			}
		}
		portENABLE_INTERRUPTS();
    12c6:	78 94       	sei

		portDISABLE_INTERRUPTS();
    12c8:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    12ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    12cc:	89 17       	cp	r24, r25
    12ce:	78 f4       	brcc	.+30     	; 0x12ee <xQueueCRSend+0x60>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    12d0:	40 e0       	ldi	r20, 0x00	; 0
    12d2:	ce 01       	movw	r24, r28
    12d4:	0e 94 1b 07 	call	0xe36	; 0xe36 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12d8:	89 89       	ldd	r24, Y+17	; 0x11
    12da:	88 23       	and	r24, r24
    12dc:	51 f0       	breq	.+20     	; 0x12f2 <xQueueCRSend+0x64>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12de:	ce 01       	movw	r24, r28
    12e0:	41 96       	adiw	r24, 0x11	; 17
    12e2:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <xCoRoutineRemoveFromEventList>
    12e6:	88 23       	and	r24, r24
    12e8:	31 f0       	breq	.+12     	; 0x12f6 <xQueueCRSend+0x68>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    12ea:	8b ef       	ldi	r24, 0xFB	; 251
    12ec:	05 c0       	rjmp	.+10     	; 0x12f8 <xQueueCRSend+0x6a>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    12ee:	80 e0       	ldi	r24, 0x00	; 0
    12f0:	03 c0       	rjmp	.+6      	; 0x12f8 <xQueueCRSend+0x6a>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    12f2:	81 e0       	ldi	r24, 0x01	; 1
    12f4:	01 c0       	rjmp	.+2      	; 0x12f8 <xQueueCRSend+0x6a>
    12f6:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    12f8:	78 94       	sei

		return xReturn;
	}
    12fa:	df 91       	pop	r29
    12fc:	cf 91       	pop	r28
    12fe:	08 95       	ret

00001300 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1300:	cf 93       	push	r28
    1302:	df 93       	push	r29
    1304:	ec 01       	movw	r28, r24
    1306:	9b 01       	movw	r18, r22
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1308:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    130a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    130c:	91 11       	cpse	r25, r1
    130e:	0f c0       	rjmp	.+30     	; 0x132e <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1310:	41 15       	cp	r20, r1
    1312:	51 05       	cpc	r21, r1
    1314:	49 f0       	breq	.+18     	; 0x1328 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1316:	be 01       	movw	r22, r28
    1318:	6f 5e       	subi	r22, 0xEF	; 239
    131a:	7f 4f       	sbci	r23, 0xFF	; 255
    131c:	ca 01       	movw	r24, r20
    131e:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1322:	78 94       	sei
					return errQUEUE_BLOCKED;
    1324:	8c ef       	ldi	r24, 0xFC	; 252
    1326:	32 c0       	rjmp	.+100    	; 0x138c <xQueueCRReceive+0x8c>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1328:	78 94       	sei
					return errQUEUE_FULL;
    132a:	80 e0       	ldi	r24, 0x00	; 0
    132c:	2f c0       	rjmp	.+94     	; 0x138c <xQueueCRReceive+0x8c>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    132e:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1330:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1332:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1334:	88 23       	and	r24, r24
    1336:	21 f1       	breq	.+72     	; 0x1380 <xQueueCRReceive+0x80>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1338:	4c 8d       	ldd	r20, Y+28	; 0x1c
    133a:	50 e0       	ldi	r21, 0x00	; 0
    133c:	8e 81       	ldd	r24, Y+6	; 0x06
    133e:	9f 81       	ldd	r25, Y+7	; 0x07
    1340:	84 0f       	add	r24, r20
    1342:	95 1f       	adc	r25, r21
    1344:	9f 83       	std	Y+7, r25	; 0x07
    1346:	8e 83       	std	Y+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1348:	6a 81       	ldd	r22, Y+2	; 0x02
    134a:	7b 81       	ldd	r23, Y+3	; 0x03
    134c:	86 17       	cp	r24, r22
    134e:	97 07       	cpc	r25, r23
    1350:	20 f0       	brcs	.+8      	; 0x135a <xQueueCRReceive+0x5a>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1352:	88 81       	ld	r24, Y
    1354:	99 81       	ldd	r25, Y+1	; 0x01
    1356:	9f 83       	std	Y+7, r25	; 0x07
    1358:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    135a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    135c:	81 50       	subi	r24, 0x01	; 1
    135e:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1360:	6e 81       	ldd	r22, Y+6	; 0x06
    1362:	7f 81       	ldd	r23, Y+7	; 0x07
    1364:	c9 01       	movw	r24, r18
    1366:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    136a:	88 85       	ldd	r24, Y+8	; 0x08
    136c:	88 23       	and	r24, r24
    136e:	51 f0       	breq	.+20     	; 0x1384 <xQueueCRReceive+0x84>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1370:	ce 01       	movw	r24, r28
    1372:	08 96       	adiw	r24, 0x08	; 8
    1374:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <xCoRoutineRemoveFromEventList>
    1378:	88 23       	and	r24, r24
    137a:	31 f0       	breq	.+12     	; 0x1388 <xQueueCRReceive+0x88>
					{
						xReturn = errQUEUE_YIELD;
    137c:	8b ef       	ldi	r24, 0xFB	; 251
    137e:	05 c0       	rjmp	.+10     	; 0x138a <xQueueCRReceive+0x8a>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1380:	80 e0       	ldi	r24, 0x00	; 0
    1382:	03 c0       	rjmp	.+6      	; 0x138a <xQueueCRReceive+0x8a>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	01 c0       	rjmp	.+2      	; 0x138a <xQueueCRReceive+0x8a>
    1388:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    138a:	78 94       	sei

		return xReturn;
	}
    138c:	df 91       	pop	r29
    138e:	cf 91       	pop	r28
    1390:	08 95       	ret

00001392 <prvResetNextTaskUnblockTime>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1392:	e0 91 99 07 	lds	r30, 0x0799	; 0x800799 <pxDelayedTaskList>
    1396:	f0 91 9a 07 	lds	r31, 0x079A	; 0x80079a <pxDelayedTaskList+0x1>
    139a:	80 81       	ld	r24, Z
    139c:	81 11       	cpse	r24, r1
    139e:	07 c0       	rjmp	.+14     	; 0x13ae <prvResetNextTaskUnblockTime+0x1c>
    13a0:	8f ef       	ldi	r24, 0xFF	; 255
    13a2:	9f ef       	ldi	r25, 0xFF	; 255
    13a4:	90 93 7a 07 	sts	0x077A, r25	; 0x80077a <xNextTaskUnblockTime+0x1>
    13a8:	80 93 79 07 	sts	0x0779, r24	; 0x800779 <xNextTaskUnblockTime>
    13ac:	08 95       	ret
    13ae:	e0 91 99 07 	lds	r30, 0x0799	; 0x800799 <pxDelayedTaskList>
    13b2:	f0 91 9a 07 	lds	r31, 0x079A	; 0x80079a <pxDelayedTaskList+0x1>
    13b6:	05 80       	ldd	r0, Z+5	; 0x05
    13b8:	f6 81       	ldd	r31, Z+6	; 0x06
    13ba:	e0 2d       	mov	r30, r0
    13bc:	06 80       	ldd	r0, Z+6	; 0x06
    13be:	f7 81       	ldd	r31, Z+7	; 0x07
    13c0:	e0 2d       	mov	r30, r0
    13c2:	82 81       	ldd	r24, Z+2	; 0x02
    13c4:	93 81       	ldd	r25, Z+3	; 0x03
    13c6:	90 93 7a 07 	sts	0x077A, r25	; 0x80077a <xNextTaskUnblockTime+0x1>
    13ca:	80 93 79 07 	sts	0x0779, r24	; 0x800779 <xNextTaskUnblockTime>
    13ce:	08 95       	ret

000013d0 <prvAddCurrentTaskToDelayedList>:
    13d0:	0f 93       	push	r16
    13d2:	1f 93       	push	r17
    13d4:	cf 93       	push	r28
    13d6:	df 93       	push	r29
    13d8:	ec 01       	movw	r28, r24
    13da:	00 91 81 07 	lds	r16, 0x0781	; 0x800781 <xTickCount>
    13de:	10 91 82 07 	lds	r17, 0x0782	; 0x800782 <xTickCount+0x1>
    13e2:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <pxCurrentTCB>
    13e6:	90 91 d2 07 	lds	r25, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
    13ea:	02 96       	adiw	r24, 0x02	; 2
    13ec:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>
    13f0:	c0 0f       	add	r28, r16
    13f2:	d1 1f       	adc	r29, r17
    13f4:	e0 91 d1 07 	lds	r30, 0x07D1	; 0x8007d1 <pxCurrentTCB>
    13f8:	f0 91 d2 07 	lds	r31, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
    13fc:	d3 83       	std	Z+3, r29	; 0x03
    13fe:	c2 83       	std	Z+2, r28	; 0x02
    1400:	c0 17       	cp	r28, r16
    1402:	d1 07       	cpc	r29, r17
    1404:	68 f4       	brcc	.+26     	; 0x1420 <prvAddCurrentTaskToDelayedList+0x50>
    1406:	60 91 d1 07 	lds	r22, 0x07D1	; 0x8007d1 <pxCurrentTCB>
    140a:	70 91 d2 07 	lds	r23, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
    140e:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <pxOverflowDelayedTaskList>
    1412:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <pxOverflowDelayedTaskList+0x1>
    1416:	6e 5f       	subi	r22, 0xFE	; 254
    1418:	7f 4f       	sbci	r23, 0xFF	; 255
    141a:	0e 94 30 05 	call	0xa60	; 0xa60 <vListInsert>
    141e:	17 c0       	rjmp	.+46     	; 0x144e <prvAddCurrentTaskToDelayedList+0x7e>
    1420:	60 91 d1 07 	lds	r22, 0x07D1	; 0x8007d1 <pxCurrentTCB>
    1424:	70 91 d2 07 	lds	r23, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
    1428:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <pxDelayedTaskList>
    142c:	90 91 9a 07 	lds	r25, 0x079A	; 0x80079a <pxDelayedTaskList+0x1>
    1430:	6e 5f       	subi	r22, 0xFE	; 254
    1432:	7f 4f       	sbci	r23, 0xFF	; 255
    1434:	0e 94 30 05 	call	0xa60	; 0xa60 <vListInsert>
    1438:	80 91 79 07 	lds	r24, 0x0779	; 0x800779 <xNextTaskUnblockTime>
    143c:	90 91 7a 07 	lds	r25, 0x077A	; 0x80077a <xNextTaskUnblockTime+0x1>
    1440:	c8 17       	cp	r28, r24
    1442:	d9 07       	cpc	r29, r25
    1444:	20 f4       	brcc	.+8      	; 0x144e <prvAddCurrentTaskToDelayedList+0x7e>
    1446:	d0 93 7a 07 	sts	0x077A, r29	; 0x80077a <xNextTaskUnblockTime+0x1>
    144a:	c0 93 79 07 	sts	0x0779, r28	; 0x800779 <xNextTaskUnblockTime>
    144e:	df 91       	pop	r29
    1450:	cf 91       	pop	r28
    1452:	1f 91       	pop	r17
    1454:	0f 91       	pop	r16
    1456:	08 95       	ret

00001458 <xTaskCreate>:
    1458:	4f 92       	push	r4
    145a:	5f 92       	push	r5
    145c:	6f 92       	push	r6
    145e:	7f 92       	push	r7
    1460:	8f 92       	push	r8
    1462:	9f 92       	push	r9
    1464:	af 92       	push	r10
    1466:	bf 92       	push	r11
    1468:	cf 92       	push	r12
    146a:	df 92       	push	r13
    146c:	ef 92       	push	r14
    146e:	ff 92       	push	r15
    1470:	0f 93       	push	r16
    1472:	cf 93       	push	r28
    1474:	df 93       	push	r29
    1476:	4c 01       	movw	r8, r24
    1478:	6b 01       	movw	r12, r22
    147a:	5a 01       	movw	r10, r20
    147c:	29 01       	movw	r4, r18
    147e:	ca 01       	movw	r24, r20
    1480:	0e 94 e5 06 	call	0xdca	; 0xdca <pvPortMalloc>
    1484:	3c 01       	movw	r6, r24
    1486:	89 2b       	or	r24, r25
    1488:	09 f4       	brne	.+2      	; 0x148c <xTaskCreate+0x34>
    148a:	dd c0       	rjmp	.+442    	; 0x1646 <xTaskCreate+0x1ee>
    148c:	86 e2       	ldi	r24, 0x26	; 38
    148e:	90 e0       	ldi	r25, 0x00	; 0
    1490:	0e 94 e5 06 	call	0xdca	; 0xdca <pvPortMalloc>
    1494:	ec 01       	movw	r28, r24
    1496:	89 2b       	or	r24, r25
    1498:	71 f0       	breq	.+28     	; 0x14b6 <xTaskCreate+0x5e>
    149a:	78 8e       	std	Y+24, r7	; 0x18
    149c:	6f 8a       	std	Y+23, r6	; 0x17
    149e:	81 e0       	ldi	r24, 0x01	; 1
    14a0:	a8 1a       	sub	r10, r24
    14a2:	b1 08       	sbc	r11, r1
    14a4:	a6 0c       	add	r10, r6
    14a6:	b7 1c       	adc	r11, r7
    14a8:	d6 01       	movw	r26, r12
    14aa:	8c 91       	ld	r24, X
    14ac:	89 8f       	std	Y+25, r24	; 0x19
    14ae:	8c 91       	ld	r24, X
    14b0:	81 11       	cpse	r24, r1
    14b2:	05 c0       	rjmp	.+10     	; 0x14be <xTaskCreate+0x66>
    14b4:	18 c0       	rjmp	.+48     	; 0x14e6 <xTaskCreate+0x8e>
    14b6:	c3 01       	movw	r24, r6
    14b8:	0e 94 1a 07 	call	0xe34	; 0xe34 <vPortFree>
    14bc:	c4 c0       	rjmp	.+392    	; 0x1646 <xTaskCreate+0x1ee>
    14be:	ae 01       	movw	r20, r28
    14c0:	46 5e       	subi	r20, 0xE6	; 230
    14c2:	5f 4f       	sbci	r21, 0xFF	; 255
    14c4:	f6 01       	movw	r30, r12
    14c6:	31 96       	adiw	r30, 0x01	; 1
    14c8:	b8 e0       	ldi	r27, 0x08	; 8
    14ca:	cb 0e       	add	r12, r27
    14cc:	d1 1c       	adc	r13, r1
    14ce:	cf 01       	movw	r24, r30
    14d0:	21 91       	ld	r18, Z+
    14d2:	da 01       	movw	r26, r20
    14d4:	2d 93       	st	X+, r18
    14d6:	ad 01       	movw	r20, r26
    14d8:	dc 01       	movw	r26, r24
    14da:	8c 91       	ld	r24, X
    14dc:	88 23       	and	r24, r24
    14de:	19 f0       	breq	.+6      	; 0x14e6 <xTaskCreate+0x8e>
    14e0:	ec 15       	cp	r30, r12
    14e2:	fd 05       	cpc	r31, r13
    14e4:	a1 f7       	brne	.-24     	; 0x14ce <xTaskCreate+0x76>
    14e6:	18 a2       	std	Y+32, r1	; 0x20
    14e8:	04 30       	cpi	r16, 0x04	; 4
    14ea:	08 f0       	brcs	.+2      	; 0x14ee <xTaskCreate+0x96>
    14ec:	03 e0       	ldi	r16, 0x03	; 3
    14ee:	0e 8b       	std	Y+22, r16	; 0x16
    14f0:	6e 01       	movw	r12, r28
    14f2:	b2 e0       	ldi	r27, 0x02	; 2
    14f4:	cb 0e       	add	r12, r27
    14f6:	d1 1c       	adc	r13, r1
    14f8:	c6 01       	movw	r24, r12
    14fa:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInitialiseItem>
    14fe:	ce 01       	movw	r24, r28
    1500:	0c 96       	adiw	r24, 0x0c	; 12
    1502:	0e 94 0b 05 	call	0xa16	; 0xa16 <vListInitialiseItem>
    1506:	d9 87       	std	Y+9, r29	; 0x09
    1508:	c8 87       	std	Y+8, r28	; 0x08
    150a:	84 e0       	ldi	r24, 0x04	; 4
    150c:	90 e0       	ldi	r25, 0x00	; 0
    150e:	80 1b       	sub	r24, r16
    1510:	91 09       	sbc	r25, r1
    1512:	9d 87       	std	Y+13, r25	; 0x0d
    1514:	8c 87       	std	Y+12, r24	; 0x0c
    1516:	db 8b       	std	Y+19, r29	; 0x13
    1518:	ca 8b       	std	Y+18, r28	; 0x12
    151a:	19 a2       	std	Y+33, r1	; 0x21
    151c:	1a a2       	std	Y+34, r1	; 0x22
    151e:	1b a2       	std	Y+35, r1	; 0x23
    1520:	1c a2       	std	Y+36, r1	; 0x24
    1522:	1d a2       	std	Y+37, r1	; 0x25
    1524:	a2 01       	movw	r20, r4
    1526:	b4 01       	movw	r22, r8
    1528:	c5 01       	movw	r24, r10
    152a:	0e 94 87 05 	call	0xb0e	; 0xb0e <pxPortInitialiseStack>
    152e:	99 83       	std	Y+1, r25	; 0x01
    1530:	88 83       	st	Y, r24
    1532:	e1 14       	cp	r14, r1
    1534:	f1 04       	cpc	r15, r1
    1536:	19 f0       	breq	.+6      	; 0x153e <xTaskCreate+0xe6>
    1538:	f7 01       	movw	r30, r14
    153a:	d1 83       	std	Z+1, r29	; 0x01
    153c:	c0 83       	st	Z, r28
    153e:	0f b6       	in	r0, 0x3f	; 63
    1540:	f8 94       	cli
    1542:	0f 92       	push	r0
    1544:	80 91 83 07 	lds	r24, 0x0783	; 0x800783 <uxCurrentNumberOfTasks>
    1548:	8f 5f       	subi	r24, 0xFF	; 255
    154a:	80 93 83 07 	sts	0x0783, r24	; 0x800783 <uxCurrentNumberOfTasks>
    154e:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <pxCurrentTCB>
    1552:	90 91 d2 07 	lds	r25, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
    1556:	89 2b       	or	r24, r25
    1558:	a9 f5       	brne	.+106    	; 0x15c4 <xTaskCreate+0x16c>
    155a:	d0 93 d2 07 	sts	0x07D2, r29	; 0x8007d2 <pxCurrentTCB+0x1>
    155e:	c0 93 d1 07 	sts	0x07D1, r28	; 0x8007d1 <pxCurrentTCB>
    1562:	80 91 83 07 	lds	r24, 0x0783	; 0x800783 <uxCurrentNumberOfTasks>
    1566:	81 30       	cpi	r24, 0x01	; 1
    1568:	e9 f5       	brne	.+122    	; 0x15e4 <xTaskCreate+0x18c>
    156a:	8d ea       	ldi	r24, 0xAD	; 173
    156c:	97 e0       	ldi	r25, 0x07	; 7
    156e:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
    1572:	86 eb       	ldi	r24, 0xB6	; 182
    1574:	97 e0       	ldi	r25, 0x07	; 7
    1576:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
    157a:	8f eb       	ldi	r24, 0xBF	; 191
    157c:	97 e0       	ldi	r25, 0x07	; 7
    157e:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
    1582:	88 ec       	ldi	r24, 0xC8	; 200
    1584:	97 e0       	ldi	r25, 0x07	; 7
    1586:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
    158a:	84 ea       	ldi	r24, 0xA4	; 164
    158c:	97 e0       	ldi	r25, 0x07	; 7
    158e:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
    1592:	8b e9       	ldi	r24, 0x9B	; 155
    1594:	97 e0       	ldi	r25, 0x07	; 7
    1596:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
    159a:	8e e8       	ldi	r24, 0x8E	; 142
    159c:	97 e0       	ldi	r25, 0x07	; 7
    159e:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
    15a2:	85 e8       	ldi	r24, 0x85	; 133
    15a4:	97 e0       	ldi	r25, 0x07	; 7
    15a6:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInitialise>
    15aa:	84 ea       	ldi	r24, 0xA4	; 164
    15ac:	97 e0       	ldi	r25, 0x07	; 7
    15ae:	90 93 9a 07 	sts	0x079A, r25	; 0x80079a <pxDelayedTaskList+0x1>
    15b2:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <pxDelayedTaskList>
    15b6:	8b e9       	ldi	r24, 0x9B	; 155
    15b8:	97 e0       	ldi	r25, 0x07	; 7
    15ba:	90 93 98 07 	sts	0x0798, r25	; 0x800798 <pxOverflowDelayedTaskList+0x1>
    15be:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <pxOverflowDelayedTaskList>
    15c2:	10 c0       	rjmp	.+32     	; 0x15e4 <xTaskCreate+0x18c>
    15c4:	80 91 7f 07 	lds	r24, 0x077F	; 0x80077f <xSchedulerRunning>
    15c8:	81 11       	cpse	r24, r1
    15ca:	0c c0       	rjmp	.+24     	; 0x15e4 <xTaskCreate+0x18c>
    15cc:	e0 91 d1 07 	lds	r30, 0x07D1	; 0x8007d1 <pxCurrentTCB>
    15d0:	f0 91 d2 07 	lds	r31, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
    15d4:	96 89       	ldd	r25, Z+22	; 0x16
    15d6:	8e 89       	ldd	r24, Y+22	; 0x16
    15d8:	89 17       	cp	r24, r25
    15da:	20 f0       	brcs	.+8      	; 0x15e4 <xTaskCreate+0x18c>
    15dc:	d0 93 d2 07 	sts	0x07D2, r29	; 0x8007d2 <pxCurrentTCB+0x1>
    15e0:	c0 93 d1 07 	sts	0x07D1, r28	; 0x8007d1 <pxCurrentTCB>
    15e4:	80 91 7b 07 	lds	r24, 0x077B	; 0x80077b <uxTaskNumber>
    15e8:	8f 5f       	subi	r24, 0xFF	; 255
    15ea:	80 93 7b 07 	sts	0x077B, r24	; 0x80077b <uxTaskNumber>
    15ee:	8e 89       	ldd	r24, Y+22	; 0x16
    15f0:	90 91 80 07 	lds	r25, 0x0780	; 0x800780 <uxTopReadyPriority>
    15f4:	98 17       	cp	r25, r24
    15f6:	10 f4       	brcc	.+4      	; 0x15fc <xTaskCreate+0x1a4>
    15f8:	80 93 80 07 	sts	0x0780, r24	; 0x800780 <uxTopReadyPriority>
    15fc:	90 e0       	ldi	r25, 0x00	; 0
    15fe:	9c 01       	movw	r18, r24
    1600:	22 0f       	add	r18, r18
    1602:	33 1f       	adc	r19, r19
    1604:	22 0f       	add	r18, r18
    1606:	33 1f       	adc	r19, r19
    1608:	22 0f       	add	r18, r18
    160a:	33 1f       	adc	r19, r19
    160c:	82 0f       	add	r24, r18
    160e:	93 1f       	adc	r25, r19
    1610:	b6 01       	movw	r22, r12
    1612:	83 55       	subi	r24, 0x53	; 83
    1614:	98 4f       	sbci	r25, 0xF8	; 248
    1616:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsertEnd>
    161a:	0f 90       	pop	r0
    161c:	0f be       	out	0x3f, r0	; 63
    161e:	80 91 7f 07 	lds	r24, 0x077F	; 0x80077f <xSchedulerRunning>
    1622:	88 23       	and	r24, r24
    1624:	61 f0       	breq	.+24     	; 0x163e <xTaskCreate+0x1e6>
    1626:	e0 91 d1 07 	lds	r30, 0x07D1	; 0x8007d1 <pxCurrentTCB>
    162a:	f0 91 d2 07 	lds	r31, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
    162e:	96 89       	ldd	r25, Z+22	; 0x16
    1630:	8e 89       	ldd	r24, Y+22	; 0x16
    1632:	98 17       	cp	r25, r24
    1634:	30 f4       	brcc	.+12     	; 0x1642 <xTaskCreate+0x1ea>
    1636:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vPortYield>
    163a:	81 e0       	ldi	r24, 0x01	; 1
    163c:	05 c0       	rjmp	.+10     	; 0x1648 <xTaskCreate+0x1f0>
    163e:	81 e0       	ldi	r24, 0x01	; 1
    1640:	03 c0       	rjmp	.+6      	; 0x1648 <xTaskCreate+0x1f0>
    1642:	81 e0       	ldi	r24, 0x01	; 1
    1644:	01 c0       	rjmp	.+2      	; 0x1648 <xTaskCreate+0x1f0>
    1646:	8f ef       	ldi	r24, 0xFF	; 255
    1648:	df 91       	pop	r29
    164a:	cf 91       	pop	r28
    164c:	0f 91       	pop	r16
    164e:	ff 90       	pop	r15
    1650:	ef 90       	pop	r14
    1652:	df 90       	pop	r13
    1654:	cf 90       	pop	r12
    1656:	bf 90       	pop	r11
    1658:	af 90       	pop	r10
    165a:	9f 90       	pop	r9
    165c:	8f 90       	pop	r8
    165e:	7f 90       	pop	r7
    1660:	6f 90       	pop	r6
    1662:	5f 90       	pop	r5
    1664:	4f 90       	pop	r4
    1666:	08 95       	ret

00001668 <vTaskStartScheduler>:
    1668:	ef 92       	push	r14
    166a:	ff 92       	push	r15
    166c:	0f 93       	push	r16
    166e:	0f 2e       	mov	r0, r31
    1670:	f7 e7       	ldi	r31, 0x77	; 119
    1672:	ef 2e       	mov	r14, r31
    1674:	f7 e0       	ldi	r31, 0x07	; 7
    1676:	ff 2e       	mov	r15, r31
    1678:	f0 2d       	mov	r31, r0
    167a:	00 e0       	ldi	r16, 0x00	; 0
    167c:	20 e0       	ldi	r18, 0x00	; 0
    167e:	30 e0       	ldi	r19, 0x00	; 0
    1680:	45 e5       	ldi	r20, 0x55	; 85
    1682:	50 e0       	ldi	r21, 0x00	; 0
    1684:	60 e3       	ldi	r22, 0x30	; 48
    1686:	71 e0       	ldi	r23, 0x01	; 1
    1688:	8c eb       	ldi	r24, 0xBC	; 188
    168a:	9c e0       	ldi	r25, 0x0C	; 12
    168c:	0e 94 2c 0a 	call	0x1458	; 0x1458 <xTaskCreate>
    1690:	81 30       	cpi	r24, 0x01	; 1
    1692:	81 f4       	brne	.+32     	; 0x16b4 <vTaskStartScheduler+0x4c>
    1694:	f8 94       	cli
    1696:	8f ef       	ldi	r24, 0xFF	; 255
    1698:	9f ef       	ldi	r25, 0xFF	; 255
    169a:	90 93 7a 07 	sts	0x077A, r25	; 0x80077a <xNextTaskUnblockTime+0x1>
    169e:	80 93 79 07 	sts	0x0779, r24	; 0x800779 <xNextTaskUnblockTime>
    16a2:	81 e0       	ldi	r24, 0x01	; 1
    16a4:	80 93 7f 07 	sts	0x077F, r24	; 0x80077f <xSchedulerRunning>
    16a8:	10 92 82 07 	sts	0x0782, r1	; 0x800782 <xTickCount+0x1>
    16ac:	10 92 81 07 	sts	0x0781, r1	; 0x800781 <xTickCount>
    16b0:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <xPortStartScheduler>
    16b4:	0f 91       	pop	r16
    16b6:	ff 90       	pop	r15
    16b8:	ef 90       	pop	r14
    16ba:	08 95       	ret

000016bc <vTaskSuspendAll>:
    16bc:	80 91 76 07 	lds	r24, 0x0776	; 0x800776 <uxSchedulerSuspended>
    16c0:	8f 5f       	subi	r24, 0xFF	; 255
    16c2:	80 93 76 07 	sts	0x0776, r24	; 0x800776 <uxSchedulerSuspended>
    16c6:	08 95       	ret

000016c8 <xTaskGetTickCount>:
    16c8:	0f b6       	in	r0, 0x3f	; 63
    16ca:	f8 94       	cli
    16cc:	0f 92       	push	r0
    16ce:	80 91 81 07 	lds	r24, 0x0781	; 0x800781 <xTickCount>
    16d2:	90 91 82 07 	lds	r25, 0x0782	; 0x800782 <xTickCount+0x1>
    16d6:	0f 90       	pop	r0
    16d8:	0f be       	out	0x3f, r0	; 63
    16da:	08 95       	ret

000016dc <xTaskIncrementTick>:
    16dc:	cf 92       	push	r12
    16de:	df 92       	push	r13
    16e0:	ef 92       	push	r14
    16e2:	ff 92       	push	r15
    16e4:	0f 93       	push	r16
    16e6:	1f 93       	push	r17
    16e8:	cf 93       	push	r28
    16ea:	df 93       	push	r29
    16ec:	80 91 76 07 	lds	r24, 0x0776	; 0x800776 <uxSchedulerSuspended>
    16f0:	81 11       	cpse	r24, r1
    16f2:	99 c0       	rjmp	.+306    	; 0x1826 <xTaskIncrementTick+0x14a>
    16f4:	e0 90 81 07 	lds	r14, 0x0781	; 0x800781 <xTickCount>
    16f8:	f0 90 82 07 	lds	r15, 0x0782	; 0x800782 <xTickCount+0x1>
    16fc:	8f ef       	ldi	r24, 0xFF	; 255
    16fe:	e8 1a       	sub	r14, r24
    1700:	f8 0a       	sbc	r15, r24
    1702:	f0 92 82 07 	sts	0x0782, r15	; 0x800782 <xTickCount+0x1>
    1706:	e0 92 81 07 	sts	0x0781, r14	; 0x800781 <xTickCount>
    170a:	e1 14       	cp	r14, r1
    170c:	f1 04       	cpc	r15, r1
    170e:	b9 f4       	brne	.+46     	; 0x173e <xTaskIncrementTick+0x62>
    1710:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <pxDelayedTaskList>
    1714:	90 91 9a 07 	lds	r25, 0x079A	; 0x80079a <pxDelayedTaskList+0x1>
    1718:	20 91 97 07 	lds	r18, 0x0797	; 0x800797 <pxOverflowDelayedTaskList>
    171c:	30 91 98 07 	lds	r19, 0x0798	; 0x800798 <pxOverflowDelayedTaskList+0x1>
    1720:	30 93 9a 07 	sts	0x079A, r19	; 0x80079a <pxDelayedTaskList+0x1>
    1724:	20 93 99 07 	sts	0x0799, r18	; 0x800799 <pxDelayedTaskList>
    1728:	90 93 98 07 	sts	0x0798, r25	; 0x800798 <pxOverflowDelayedTaskList+0x1>
    172c:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <pxOverflowDelayedTaskList>
    1730:	80 91 7c 07 	lds	r24, 0x077C	; 0x80077c <xNumOfOverflows>
    1734:	8f 5f       	subi	r24, 0xFF	; 255
    1736:	80 93 7c 07 	sts	0x077C, r24	; 0x80077c <xNumOfOverflows>
    173a:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvResetNextTaskUnblockTime>
    173e:	80 91 79 07 	lds	r24, 0x0779	; 0x800779 <xNextTaskUnblockTime>
    1742:	90 91 7a 07 	lds	r25, 0x077A	; 0x80077a <xNextTaskUnblockTime+0x1>
    1746:	e8 16       	cp	r14, r24
    1748:	f9 06       	cpc	r15, r25
    174a:	10 f4       	brcc	.+4      	; 0x1750 <xTaskIncrementTick+0x74>
    174c:	d1 2c       	mov	r13, r1
    174e:	53 c0       	rjmp	.+166    	; 0x17f6 <xTaskIncrementTick+0x11a>
    1750:	d1 2c       	mov	r13, r1
    1752:	cc 24       	eor	r12, r12
    1754:	c3 94       	inc	r12
    1756:	e0 91 99 07 	lds	r30, 0x0799	; 0x800799 <pxDelayedTaskList>
    175a:	f0 91 9a 07 	lds	r31, 0x079A	; 0x80079a <pxDelayedTaskList+0x1>
    175e:	80 81       	ld	r24, Z
    1760:	81 11       	cpse	r24, r1
    1762:	07 c0       	rjmp	.+14     	; 0x1772 <xTaskIncrementTick+0x96>
    1764:	8f ef       	ldi	r24, 0xFF	; 255
    1766:	9f ef       	ldi	r25, 0xFF	; 255
    1768:	90 93 7a 07 	sts	0x077A, r25	; 0x80077a <xNextTaskUnblockTime+0x1>
    176c:	80 93 79 07 	sts	0x0779, r24	; 0x800779 <xNextTaskUnblockTime>
    1770:	42 c0       	rjmp	.+132    	; 0x17f6 <xTaskIncrementTick+0x11a>
    1772:	e0 91 99 07 	lds	r30, 0x0799	; 0x800799 <pxDelayedTaskList>
    1776:	f0 91 9a 07 	lds	r31, 0x079A	; 0x80079a <pxDelayedTaskList+0x1>
    177a:	05 80       	ldd	r0, Z+5	; 0x05
    177c:	f6 81       	ldd	r31, Z+6	; 0x06
    177e:	e0 2d       	mov	r30, r0
    1780:	c6 81       	ldd	r28, Z+6	; 0x06
    1782:	d7 81       	ldd	r29, Z+7	; 0x07
    1784:	8a 81       	ldd	r24, Y+2	; 0x02
    1786:	9b 81       	ldd	r25, Y+3	; 0x03
    1788:	e8 16       	cp	r14, r24
    178a:	f9 06       	cpc	r15, r25
    178c:	28 f4       	brcc	.+10     	; 0x1798 <xTaskIncrementTick+0xbc>
    178e:	90 93 7a 07 	sts	0x077A, r25	; 0x80077a <xNextTaskUnblockTime+0x1>
    1792:	80 93 79 07 	sts	0x0779, r24	; 0x800779 <xNextTaskUnblockTime>
    1796:	2f c0       	rjmp	.+94     	; 0x17f6 <xTaskIncrementTick+0x11a>
    1798:	8e 01       	movw	r16, r28
    179a:	0e 5f       	subi	r16, 0xFE	; 254
    179c:	1f 4f       	sbci	r17, 0xFF	; 255
    179e:	c8 01       	movw	r24, r16
    17a0:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>
    17a4:	8c 89       	ldd	r24, Y+20	; 0x14
    17a6:	9d 89       	ldd	r25, Y+21	; 0x15
    17a8:	89 2b       	or	r24, r25
    17aa:	21 f0       	breq	.+8      	; 0x17b4 <xTaskIncrementTick+0xd8>
    17ac:	ce 01       	movw	r24, r28
    17ae:	0c 96       	adiw	r24, 0x0c	; 12
    17b0:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>
    17b4:	8e 89       	ldd	r24, Y+22	; 0x16
    17b6:	90 91 80 07 	lds	r25, 0x0780	; 0x800780 <uxTopReadyPriority>
    17ba:	98 17       	cp	r25, r24
    17bc:	10 f4       	brcc	.+4      	; 0x17c2 <xTaskIncrementTick+0xe6>
    17be:	80 93 80 07 	sts	0x0780, r24	; 0x800780 <uxTopReadyPriority>
    17c2:	90 e0       	ldi	r25, 0x00	; 0
    17c4:	9c 01       	movw	r18, r24
    17c6:	22 0f       	add	r18, r18
    17c8:	33 1f       	adc	r19, r19
    17ca:	22 0f       	add	r18, r18
    17cc:	33 1f       	adc	r19, r19
    17ce:	22 0f       	add	r18, r18
    17d0:	33 1f       	adc	r19, r19
    17d2:	82 0f       	add	r24, r18
    17d4:	93 1f       	adc	r25, r19
    17d6:	b8 01       	movw	r22, r16
    17d8:	83 55       	subi	r24, 0x53	; 83
    17da:	98 4f       	sbci	r25, 0xF8	; 248
    17dc:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsertEnd>
    17e0:	e0 91 d1 07 	lds	r30, 0x07D1	; 0x8007d1 <pxCurrentTCB>
    17e4:	f0 91 d2 07 	lds	r31, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
    17e8:	9e 89       	ldd	r25, Y+22	; 0x16
    17ea:	86 89       	ldd	r24, Z+22	; 0x16
    17ec:	98 17       	cp	r25, r24
    17ee:	08 f4       	brcc	.+2      	; 0x17f2 <xTaskIncrementTick+0x116>
    17f0:	b2 cf       	rjmp	.-156    	; 0x1756 <xTaskIncrementTick+0x7a>
    17f2:	dc 2c       	mov	r13, r12
    17f4:	b0 cf       	rjmp	.-160    	; 0x1756 <xTaskIncrementTick+0x7a>
    17f6:	e0 91 d1 07 	lds	r30, 0x07D1	; 0x8007d1 <pxCurrentTCB>
    17fa:	f0 91 d2 07 	lds	r31, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
    17fe:	86 89       	ldd	r24, Z+22	; 0x16
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	fc 01       	movw	r30, r24
    1804:	ee 0f       	add	r30, r30
    1806:	ff 1f       	adc	r31, r31
    1808:	ee 0f       	add	r30, r30
    180a:	ff 1f       	adc	r31, r31
    180c:	ee 0f       	add	r30, r30
    180e:	ff 1f       	adc	r31, r31
    1810:	8e 0f       	add	r24, r30
    1812:	9f 1f       	adc	r25, r31
    1814:	fc 01       	movw	r30, r24
    1816:	e3 55       	subi	r30, 0x53	; 83
    1818:	f8 4f       	sbci	r31, 0xF8	; 248
    181a:	80 81       	ld	r24, Z
    181c:	82 30       	cpi	r24, 0x02	; 2
    181e:	48 f0       	brcs	.+18     	; 0x1832 <xTaskIncrementTick+0x156>
    1820:	dd 24       	eor	r13, r13
    1822:	d3 94       	inc	r13
    1824:	06 c0       	rjmp	.+12     	; 0x1832 <xTaskIncrementTick+0x156>
    1826:	80 91 7e 07 	lds	r24, 0x077E	; 0x80077e <uxPendedTicks>
    182a:	8f 5f       	subi	r24, 0xFF	; 255
    182c:	80 93 7e 07 	sts	0x077E, r24	; 0x80077e <uxPendedTicks>
    1830:	d1 2c       	mov	r13, r1
    1832:	80 91 7d 07 	lds	r24, 0x077D	; 0x80077d <xYieldPending>
    1836:	88 23       	and	r24, r24
    1838:	11 f0       	breq	.+4      	; 0x183e <xTaskIncrementTick+0x162>
    183a:	dd 24       	eor	r13, r13
    183c:	d3 94       	inc	r13
    183e:	8d 2d       	mov	r24, r13
    1840:	df 91       	pop	r29
    1842:	cf 91       	pop	r28
    1844:	1f 91       	pop	r17
    1846:	0f 91       	pop	r16
    1848:	ff 90       	pop	r15
    184a:	ef 90       	pop	r14
    184c:	df 90       	pop	r13
    184e:	cf 90       	pop	r12
    1850:	08 95       	ret

00001852 <xTaskResumeAll>:
    1852:	df 92       	push	r13
    1854:	ef 92       	push	r14
    1856:	ff 92       	push	r15
    1858:	0f 93       	push	r16
    185a:	1f 93       	push	r17
    185c:	cf 93       	push	r28
    185e:	df 93       	push	r29
    1860:	0f b6       	in	r0, 0x3f	; 63
    1862:	f8 94       	cli
    1864:	0f 92       	push	r0
    1866:	80 91 76 07 	lds	r24, 0x0776	; 0x800776 <uxSchedulerSuspended>
    186a:	81 50       	subi	r24, 0x01	; 1
    186c:	80 93 76 07 	sts	0x0776, r24	; 0x800776 <uxSchedulerSuspended>
    1870:	80 91 76 07 	lds	r24, 0x0776	; 0x800776 <uxSchedulerSuspended>
    1874:	81 11       	cpse	r24, r1
    1876:	5f c0       	rjmp	.+190    	; 0x1936 <xTaskResumeAll+0xe4>
    1878:	80 91 83 07 	lds	r24, 0x0783	; 0x800783 <uxCurrentNumberOfTasks>
    187c:	81 11       	cpse	r24, r1
    187e:	33 c0       	rjmp	.+102    	; 0x18e6 <xTaskResumeAll+0x94>
    1880:	5d c0       	rjmp	.+186    	; 0x193c <xTaskResumeAll+0xea>
    1882:	d7 01       	movw	r26, r14
    1884:	15 96       	adiw	r26, 0x05	; 5
    1886:	ed 91       	ld	r30, X+
    1888:	fc 91       	ld	r31, X
    188a:	16 97       	sbiw	r26, 0x06	; 6
    188c:	c6 81       	ldd	r28, Z+6	; 0x06
    188e:	d7 81       	ldd	r29, Z+7	; 0x07
    1890:	ce 01       	movw	r24, r28
    1892:	0c 96       	adiw	r24, 0x0c	; 12
    1894:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>
    1898:	8e 01       	movw	r16, r28
    189a:	0e 5f       	subi	r16, 0xFE	; 254
    189c:	1f 4f       	sbci	r17, 0xFF	; 255
    189e:	c8 01       	movw	r24, r16
    18a0:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>
    18a4:	8e 89       	ldd	r24, Y+22	; 0x16
    18a6:	90 91 80 07 	lds	r25, 0x0780	; 0x800780 <uxTopReadyPriority>
    18aa:	98 17       	cp	r25, r24
    18ac:	10 f4       	brcc	.+4      	; 0x18b2 <xTaskResumeAll+0x60>
    18ae:	80 93 80 07 	sts	0x0780, r24	; 0x800780 <uxTopReadyPriority>
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	9c 01       	movw	r18, r24
    18b6:	22 0f       	add	r18, r18
    18b8:	33 1f       	adc	r19, r19
    18ba:	22 0f       	add	r18, r18
    18bc:	33 1f       	adc	r19, r19
    18be:	22 0f       	add	r18, r18
    18c0:	33 1f       	adc	r19, r19
    18c2:	82 0f       	add	r24, r18
    18c4:	93 1f       	adc	r25, r19
    18c6:	b8 01       	movw	r22, r16
    18c8:	83 55       	subi	r24, 0x53	; 83
    18ca:	98 4f       	sbci	r25, 0xF8	; 248
    18cc:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsertEnd>
    18d0:	e0 91 d1 07 	lds	r30, 0x07D1	; 0x8007d1 <pxCurrentTCB>
    18d4:	f0 91 d2 07 	lds	r31, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
    18d8:	9e 89       	ldd	r25, Y+22	; 0x16
    18da:	86 89       	ldd	r24, Z+22	; 0x16
    18dc:	98 17       	cp	r25, r24
    18de:	68 f0       	brcs	.+26     	; 0x18fa <xTaskResumeAll+0xa8>
    18e0:	d0 92 7d 07 	sts	0x077D, r13	; 0x80077d <xYieldPending>
    18e4:	0a c0       	rjmp	.+20     	; 0x18fa <xTaskResumeAll+0xa8>
    18e6:	c0 e0       	ldi	r28, 0x00	; 0
    18e8:	d0 e0       	ldi	r29, 0x00	; 0
    18ea:	0f 2e       	mov	r0, r31
    18ec:	fe e8       	ldi	r31, 0x8E	; 142
    18ee:	ef 2e       	mov	r14, r31
    18f0:	f7 e0       	ldi	r31, 0x07	; 7
    18f2:	ff 2e       	mov	r15, r31
    18f4:	f0 2d       	mov	r31, r0
    18f6:	dd 24       	eor	r13, r13
    18f8:	d3 94       	inc	r13
    18fa:	f7 01       	movw	r30, r14
    18fc:	80 81       	ld	r24, Z
    18fe:	81 11       	cpse	r24, r1
    1900:	c0 cf       	rjmp	.-128    	; 0x1882 <xTaskResumeAll+0x30>
    1902:	cd 2b       	or	r28, r29
    1904:	11 f0       	breq	.+4      	; 0x190a <xTaskResumeAll+0xb8>
    1906:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvResetNextTaskUnblockTime>
    190a:	c0 91 7e 07 	lds	r28, 0x077E	; 0x80077e <uxPendedTicks>
    190e:	cc 23       	and	r28, r28
    1910:	51 f0       	breq	.+20     	; 0x1926 <xTaskResumeAll+0xd4>
    1912:	d1 e0       	ldi	r29, 0x01	; 1
    1914:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <xTaskIncrementTick>
    1918:	81 11       	cpse	r24, r1
    191a:	d0 93 7d 07 	sts	0x077D, r29	; 0x80077d <xYieldPending>
    191e:	c1 50       	subi	r28, 0x01	; 1
    1920:	c9 f7       	brne	.-14     	; 0x1914 <xTaskResumeAll+0xc2>
    1922:	10 92 7e 07 	sts	0x077E, r1	; 0x80077e <uxPendedTicks>
    1926:	80 91 7d 07 	lds	r24, 0x077D	; 0x80077d <xYieldPending>
    192a:	88 23       	and	r24, r24
    192c:	31 f0       	breq	.+12     	; 0x193a <xTaskResumeAll+0xe8>
    192e:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vPortYield>
    1932:	81 e0       	ldi	r24, 0x01	; 1
    1934:	03 c0       	rjmp	.+6      	; 0x193c <xTaskResumeAll+0xea>
    1936:	80 e0       	ldi	r24, 0x00	; 0
    1938:	01 c0       	rjmp	.+2      	; 0x193c <xTaskResumeAll+0xea>
    193a:	80 e0       	ldi	r24, 0x00	; 0
    193c:	0f 90       	pop	r0
    193e:	0f be       	out	0x3f, r0	; 63
    1940:	df 91       	pop	r29
    1942:	cf 91       	pop	r28
    1944:	1f 91       	pop	r17
    1946:	0f 91       	pop	r16
    1948:	ff 90       	pop	r15
    194a:	ef 90       	pop	r14
    194c:	df 90       	pop	r13
    194e:	08 95       	ret

00001950 <vTaskDelay>:
    1950:	cf 93       	push	r28
    1952:	df 93       	push	r29
    1954:	ec 01       	movw	r28, r24
    1956:	89 2b       	or	r24, r25
    1958:	51 f0       	breq	.+20     	; 0x196e <vTaskDelay+0x1e>
    195a:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <vTaskSuspendAll>
    195e:	60 e0       	ldi	r22, 0x00	; 0
    1960:	ce 01       	movw	r24, r28
    1962:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1966:	0e 94 29 0c 	call	0x1852	; 0x1852 <xTaskResumeAll>
    196a:	81 11       	cpse	r24, r1
    196c:	02 c0       	rjmp	.+4      	; 0x1972 <vTaskDelay+0x22>
    196e:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vPortYield>
    1972:	df 91       	pop	r29
    1974:	cf 91       	pop	r28
    1976:	08 95       	ret

00001978 <prvIdleTask>:
    1978:	05 e8       	ldi	r16, 0x85	; 133
    197a:	17 e0       	ldi	r17, 0x07	; 7
    197c:	0f 2e       	mov	r0, r31
    197e:	fd ea       	ldi	r31, 0xAD	; 173
    1980:	ef 2e       	mov	r14, r31
    1982:	f7 e0       	ldi	r31, 0x07	; 7
    1984:	ff 2e       	mov	r15, r31
    1986:	f0 2d       	mov	r31, r0
    1988:	29 c0       	rjmp	.+82     	; 0x19dc <prvIdleTask+0x64>
    198a:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <vTaskSuspendAll>
    198e:	d8 01       	movw	r26, r16
    1990:	cc 91       	ld	r28, X
    1992:	0e 94 29 0c 	call	0x1852	; 0x1852 <xTaskResumeAll>
    1996:	cc 23       	and	r28, r28
    1998:	09 f1       	breq	.+66     	; 0x19dc <prvIdleTask+0x64>
    199a:	0f b6       	in	r0, 0x3f	; 63
    199c:	f8 94       	cli
    199e:	0f 92       	push	r0
    19a0:	d8 01       	movw	r26, r16
    19a2:	15 96       	adiw	r26, 0x05	; 5
    19a4:	ed 91       	ld	r30, X+
    19a6:	fc 91       	ld	r31, X
    19a8:	16 97       	sbiw	r26, 0x06	; 6
    19aa:	c6 81       	ldd	r28, Z+6	; 0x06
    19ac:	d7 81       	ldd	r29, Z+7	; 0x07
    19ae:	ce 01       	movw	r24, r28
    19b0:	02 96       	adiw	r24, 0x02	; 2
    19b2:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>
    19b6:	80 91 83 07 	lds	r24, 0x0783	; 0x800783 <uxCurrentNumberOfTasks>
    19ba:	81 50       	subi	r24, 0x01	; 1
    19bc:	80 93 83 07 	sts	0x0783, r24	; 0x800783 <uxCurrentNumberOfTasks>
    19c0:	80 91 84 07 	lds	r24, 0x0784	; 0x800784 <uxDeletedTasksWaitingCleanUp>
    19c4:	81 50       	subi	r24, 0x01	; 1
    19c6:	80 93 84 07 	sts	0x0784, r24	; 0x800784 <uxDeletedTasksWaitingCleanUp>
    19ca:	0f 90       	pop	r0
    19cc:	0f be       	out	0x3f, r0	; 63
    19ce:	8f 89       	ldd	r24, Y+23	; 0x17
    19d0:	98 8d       	ldd	r25, Y+24	; 0x18
    19d2:	0e 94 1a 07 	call	0xe34	; 0xe34 <vPortFree>
    19d6:	ce 01       	movw	r24, r28
    19d8:	0e 94 1a 07 	call	0xe34	; 0xe34 <vPortFree>
    19dc:	80 91 84 07 	lds	r24, 0x0784	; 0x800784 <uxDeletedTasksWaitingCleanUp>
    19e0:	81 11       	cpse	r24, r1
    19e2:	d3 cf       	rjmp	.-90     	; 0x198a <prvIdleTask+0x12>
    19e4:	f7 01       	movw	r30, r14
    19e6:	80 81       	ld	r24, Z
    19e8:	82 30       	cpi	r24, 0x02	; 2
    19ea:	10 f0       	brcs	.+4      	; 0x19f0 <prvIdleTask+0x78>
    19ec:	0e 94 2d 06 	call	0xc5a	; 0xc5a <vPortYield>
    19f0:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <vApplicationIdleHook>
    19f4:	f3 cf       	rjmp	.-26     	; 0x19dc <prvIdleTask+0x64>

000019f6 <vTaskSwitchContext>:
    19f6:	80 91 76 07 	lds	r24, 0x0776	; 0x800776 <uxSchedulerSuspended>
    19fa:	88 23       	and	r24, r24
    19fc:	21 f0       	breq	.+8      	; 0x1a06 <vTaskSwitchContext+0x10>
    19fe:	81 e0       	ldi	r24, 0x01	; 1
    1a00:	80 93 7d 07 	sts	0x077D, r24	; 0x80077d <xYieldPending>
    1a04:	08 95       	ret
    1a06:	10 92 7d 07 	sts	0x077D, r1	; 0x80077d <xYieldPending>
    1a0a:	20 91 80 07 	lds	r18, 0x0780	; 0x800780 <uxTopReadyPriority>
    1a0e:	82 2f       	mov	r24, r18
    1a10:	90 e0       	ldi	r25, 0x00	; 0
    1a12:	fc 01       	movw	r30, r24
    1a14:	ee 0f       	add	r30, r30
    1a16:	ff 1f       	adc	r31, r31
    1a18:	ee 0f       	add	r30, r30
    1a1a:	ff 1f       	adc	r31, r31
    1a1c:	ee 0f       	add	r30, r30
    1a1e:	ff 1f       	adc	r31, r31
    1a20:	e8 0f       	add	r30, r24
    1a22:	f9 1f       	adc	r31, r25
    1a24:	e3 55       	subi	r30, 0x53	; 83
    1a26:	f8 4f       	sbci	r31, 0xF8	; 248
    1a28:	30 81       	ld	r19, Z
    1a2a:	31 11       	cpse	r19, r1
    1a2c:	11 c0       	rjmp	.+34     	; 0x1a50 <vTaskSwitchContext+0x5a>
    1a2e:	21 50       	subi	r18, 0x01	; 1
    1a30:	82 2f       	mov	r24, r18
    1a32:	90 e0       	ldi	r25, 0x00	; 0
    1a34:	fc 01       	movw	r30, r24
    1a36:	ee 0f       	add	r30, r30
    1a38:	ff 1f       	adc	r31, r31
    1a3a:	ee 0f       	add	r30, r30
    1a3c:	ff 1f       	adc	r31, r31
    1a3e:	ee 0f       	add	r30, r30
    1a40:	ff 1f       	adc	r31, r31
    1a42:	e8 0f       	add	r30, r24
    1a44:	f9 1f       	adc	r31, r25
    1a46:	e3 55       	subi	r30, 0x53	; 83
    1a48:	f8 4f       	sbci	r31, 0xF8	; 248
    1a4a:	30 81       	ld	r19, Z
    1a4c:	33 23       	and	r19, r19
    1a4e:	79 f3       	breq	.-34     	; 0x1a2e <vTaskSwitchContext+0x38>
    1a50:	ac 01       	movw	r20, r24
    1a52:	44 0f       	add	r20, r20
    1a54:	55 1f       	adc	r21, r21
    1a56:	44 0f       	add	r20, r20
    1a58:	55 1f       	adc	r21, r21
    1a5a:	44 0f       	add	r20, r20
    1a5c:	55 1f       	adc	r21, r21
    1a5e:	48 0f       	add	r20, r24
    1a60:	59 1f       	adc	r21, r25
    1a62:	da 01       	movw	r26, r20
    1a64:	a3 55       	subi	r26, 0x53	; 83
    1a66:	b8 4f       	sbci	r27, 0xF8	; 248
    1a68:	11 96       	adiw	r26, 0x01	; 1
    1a6a:	ed 91       	ld	r30, X+
    1a6c:	fc 91       	ld	r31, X
    1a6e:	12 97       	sbiw	r26, 0x02	; 2
    1a70:	02 80       	ldd	r0, Z+2	; 0x02
    1a72:	f3 81       	ldd	r31, Z+3	; 0x03
    1a74:	e0 2d       	mov	r30, r0
    1a76:	12 96       	adiw	r26, 0x02	; 2
    1a78:	fc 93       	st	X, r31
    1a7a:	ee 93       	st	-X, r30
    1a7c:	11 97       	sbiw	r26, 0x01	; 1
    1a7e:	40 55       	subi	r20, 0x50	; 80
    1a80:	58 4f       	sbci	r21, 0xF8	; 248
    1a82:	e4 17       	cp	r30, r20
    1a84:	f5 07       	cpc	r31, r21
    1a86:	29 f4       	brne	.+10     	; 0x1a92 <vTaskSwitchContext+0x9c>
    1a88:	42 81       	ldd	r20, Z+2	; 0x02
    1a8a:	53 81       	ldd	r21, Z+3	; 0x03
    1a8c:	fd 01       	movw	r30, r26
    1a8e:	52 83       	std	Z+2, r21	; 0x02
    1a90:	41 83       	std	Z+1, r20	; 0x01
    1a92:	fc 01       	movw	r30, r24
    1a94:	ee 0f       	add	r30, r30
    1a96:	ff 1f       	adc	r31, r31
    1a98:	ee 0f       	add	r30, r30
    1a9a:	ff 1f       	adc	r31, r31
    1a9c:	ee 0f       	add	r30, r30
    1a9e:	ff 1f       	adc	r31, r31
    1aa0:	8e 0f       	add	r24, r30
    1aa2:	9f 1f       	adc	r25, r31
    1aa4:	fc 01       	movw	r30, r24
    1aa6:	e3 55       	subi	r30, 0x53	; 83
    1aa8:	f8 4f       	sbci	r31, 0xF8	; 248
    1aaa:	01 80       	ldd	r0, Z+1	; 0x01
    1aac:	f2 81       	ldd	r31, Z+2	; 0x02
    1aae:	e0 2d       	mov	r30, r0
    1ab0:	86 81       	ldd	r24, Z+6	; 0x06
    1ab2:	97 81       	ldd	r25, Z+7	; 0x07
    1ab4:	90 93 d2 07 	sts	0x07D2, r25	; 0x8007d2 <pxCurrentTCB+0x1>
    1ab8:	80 93 d1 07 	sts	0x07D1, r24	; 0x8007d1 <pxCurrentTCB>
    1abc:	20 93 80 07 	sts	0x0780, r18	; 0x800780 <uxTopReadyPriority>
    1ac0:	08 95       	ret

00001ac2 <vTaskPlaceOnEventList>:
    1ac2:	cf 93       	push	r28
    1ac4:	df 93       	push	r29
    1ac6:	eb 01       	movw	r28, r22
    1ac8:	60 91 d1 07 	lds	r22, 0x07D1	; 0x8007d1 <pxCurrentTCB>
    1acc:	70 91 d2 07 	lds	r23, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
    1ad0:	64 5f       	subi	r22, 0xF4	; 244
    1ad2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ad4:	0e 94 30 05 	call	0xa60	; 0xa60 <vListInsert>
    1ad8:	61 e0       	ldi	r22, 0x01	; 1
    1ada:	ce 01       	movw	r24, r28
    1adc:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1ae0:	df 91       	pop	r29
    1ae2:	cf 91       	pop	r28
    1ae4:	08 95       	ret

00001ae6 <xTaskRemoveFromEventList>:
    1ae6:	0f 93       	push	r16
    1ae8:	1f 93       	push	r17
    1aea:	cf 93       	push	r28
    1aec:	df 93       	push	r29
    1aee:	dc 01       	movw	r26, r24
    1af0:	15 96       	adiw	r26, 0x05	; 5
    1af2:	ed 91       	ld	r30, X+
    1af4:	fc 91       	ld	r31, X
    1af6:	16 97       	sbiw	r26, 0x06	; 6
    1af8:	c6 81       	ldd	r28, Z+6	; 0x06
    1afa:	d7 81       	ldd	r29, Z+7	; 0x07
    1afc:	8e 01       	movw	r16, r28
    1afe:	04 5f       	subi	r16, 0xF4	; 244
    1b00:	1f 4f       	sbci	r17, 0xFF	; 255
    1b02:	c8 01       	movw	r24, r16
    1b04:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>
    1b08:	80 91 76 07 	lds	r24, 0x0776	; 0x800776 <uxSchedulerSuspended>
    1b0c:	81 11       	cpse	r24, r1
    1b0e:	1c c0       	rjmp	.+56     	; 0x1b48 <xTaskRemoveFromEventList+0x62>
    1b10:	0a 50       	subi	r16, 0x0A	; 10
    1b12:	11 09       	sbc	r17, r1
    1b14:	c8 01       	movw	r24, r16
    1b16:	0e 94 61 05 	call	0xac2	; 0xac2 <uxListRemove>
    1b1a:	8e 89       	ldd	r24, Y+22	; 0x16
    1b1c:	90 91 80 07 	lds	r25, 0x0780	; 0x800780 <uxTopReadyPriority>
    1b20:	98 17       	cp	r25, r24
    1b22:	10 f4       	brcc	.+4      	; 0x1b28 <xTaskRemoveFromEventList+0x42>
    1b24:	80 93 80 07 	sts	0x0780, r24	; 0x800780 <uxTopReadyPriority>
    1b28:	90 e0       	ldi	r25, 0x00	; 0
    1b2a:	9c 01       	movw	r18, r24
    1b2c:	22 0f       	add	r18, r18
    1b2e:	33 1f       	adc	r19, r19
    1b30:	22 0f       	add	r18, r18
    1b32:	33 1f       	adc	r19, r19
    1b34:	22 0f       	add	r18, r18
    1b36:	33 1f       	adc	r19, r19
    1b38:	82 0f       	add	r24, r18
    1b3a:	93 1f       	adc	r25, r19
    1b3c:	b8 01       	movw	r22, r16
    1b3e:	83 55       	subi	r24, 0x53	; 83
    1b40:	98 4f       	sbci	r25, 0xF8	; 248
    1b42:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsertEnd>
    1b46:	05 c0       	rjmp	.+10     	; 0x1b52 <xTaskRemoveFromEventList+0x6c>
    1b48:	b8 01       	movw	r22, r16
    1b4a:	8e e8       	ldi	r24, 0x8E	; 142
    1b4c:	97 e0       	ldi	r25, 0x07	; 7
    1b4e:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsertEnd>
    1b52:	e0 91 d1 07 	lds	r30, 0x07D1	; 0x8007d1 <pxCurrentTCB>
    1b56:	f0 91 d2 07 	lds	r31, 0x07D2	; 0x8007d2 <pxCurrentTCB+0x1>
    1b5a:	9e 89       	ldd	r25, Y+22	; 0x16
    1b5c:	86 89       	ldd	r24, Z+22	; 0x16
    1b5e:	89 17       	cp	r24, r25
    1b60:	20 f4       	brcc	.+8      	; 0x1b6a <xTaskRemoveFromEventList+0x84>
    1b62:	81 e0       	ldi	r24, 0x01	; 1
    1b64:	80 93 7d 07 	sts	0x077D, r24	; 0x80077d <xYieldPending>
    1b68:	01 c0       	rjmp	.+2      	; 0x1b6c <xTaskRemoveFromEventList+0x86>
    1b6a:	80 e0       	ldi	r24, 0x00	; 0
    1b6c:	df 91       	pop	r29
    1b6e:	cf 91       	pop	r28
    1b70:	1f 91       	pop	r17
    1b72:	0f 91       	pop	r16
    1b74:	08 95       	ret

00001b76 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1b76:	20 91 7c 07 	lds	r18, 0x077C	; 0x80077c <xNumOfOverflows>
    1b7a:	fc 01       	movw	r30, r24
    1b7c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1b7e:	20 91 81 07 	lds	r18, 0x0781	; 0x800781 <xTickCount>
    1b82:	30 91 82 07 	lds	r19, 0x0782	; 0x800782 <xTickCount+0x1>
    1b86:	32 83       	std	Z+2, r19	; 0x02
    1b88:	21 83       	std	Z+1, r18	; 0x01
    1b8a:	08 95       	ret

00001b8c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1b8c:	cf 93       	push	r28
    1b8e:	df 93       	push	r29
    1b90:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1b92:	0f b6       	in	r0, 0x3f	; 63
    1b94:	f8 94       	cli
    1b96:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1b98:	20 91 81 07 	lds	r18, 0x0781	; 0x800781 <xTickCount>
    1b9c:	30 91 82 07 	lds	r19, 0x0782	; 0x800782 <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1ba0:	80 91 7c 07 	lds	r24, 0x077C	; 0x80077c <xNumOfOverflows>
    1ba4:	90 81       	ld	r25, Z
    1ba6:	98 17       	cp	r25, r24
    1ba8:	29 f0       	breq	.+10     	; 0x1bb4 <xTaskCheckForTimeOut+0x28>
    1baa:	81 81       	ldd	r24, Z+1	; 0x01
    1bac:	92 81       	ldd	r25, Z+2	; 0x02
    1bae:	28 17       	cp	r18, r24
    1bb0:	39 07       	cpc	r19, r25
    1bb2:	b0 f4       	brcc	.+44     	; 0x1be0 <xTaskCheckForTimeOut+0x54>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1bb4:	a1 81       	ldd	r26, Z+1	; 0x01
    1bb6:	b2 81       	ldd	r27, Z+2	; 0x02
    1bb8:	eb 01       	movw	r28, r22
    1bba:	48 81       	ld	r20, Y
    1bbc:	59 81       	ldd	r21, Y+1	; 0x01
    1bbe:	c9 01       	movw	r24, r18
    1bc0:	8a 1b       	sub	r24, r26
    1bc2:	9b 0b       	sbc	r25, r27
    1bc4:	84 17       	cp	r24, r20
    1bc6:	95 07       	cpc	r25, r21
    1bc8:	68 f4       	brcc	.+26     	; 0x1be4 <xTaskCheckForTimeOut+0x58>
    1bca:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1bcc:	a2 1b       	sub	r26, r18
    1bce:	b3 0b       	sbc	r27, r19
    1bd0:	4a 0f       	add	r20, r26
    1bd2:	5b 1f       	adc	r21, r27
    1bd4:	59 83       	std	Y+1, r21	; 0x01
    1bd6:	48 83       	st	Y, r20
			vTaskSetTimeOutState( pxTimeOut );
    1bd8:	0e 94 bb 0d 	call	0x1b76	; 0x1b76 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1bdc:	80 e0       	ldi	r24, 0x00	; 0
    1bde:	03 c0       	rjmp	.+6      	; 0x1be6 <xTaskCheckForTimeOut+0x5a>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1be0:	81 e0       	ldi	r24, 0x01	; 1
    1be2:	01 c0       	rjmp	.+2      	; 0x1be6 <xTaskCheckForTimeOut+0x5a>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1be4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1be6:	0f 90       	pop	r0
    1be8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1bea:	df 91       	pop	r29
    1bec:	cf 91       	pop	r28
    1bee:	08 95       	ret

00001bf0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1bf0:	81 e0       	ldi	r24, 0x01	; 1
    1bf2:	80 93 7d 07 	sts	0x077D, r24	; 0x80077d <xYieldPending>
    1bf6:	08 95       	ret

00001bf8 <__udivmodsi4>:
    1bf8:	a1 e2       	ldi	r26, 0x21	; 33
    1bfa:	1a 2e       	mov	r1, r26
    1bfc:	aa 1b       	sub	r26, r26
    1bfe:	bb 1b       	sub	r27, r27
    1c00:	fd 01       	movw	r30, r26
    1c02:	0d c0       	rjmp	.+26     	; 0x1c1e <__udivmodsi4_ep>

00001c04 <__udivmodsi4_loop>:
    1c04:	aa 1f       	adc	r26, r26
    1c06:	bb 1f       	adc	r27, r27
    1c08:	ee 1f       	adc	r30, r30
    1c0a:	ff 1f       	adc	r31, r31
    1c0c:	a2 17       	cp	r26, r18
    1c0e:	b3 07       	cpc	r27, r19
    1c10:	e4 07       	cpc	r30, r20
    1c12:	f5 07       	cpc	r31, r21
    1c14:	20 f0       	brcs	.+8      	; 0x1c1e <__udivmodsi4_ep>
    1c16:	a2 1b       	sub	r26, r18
    1c18:	b3 0b       	sbc	r27, r19
    1c1a:	e4 0b       	sbc	r30, r20
    1c1c:	f5 0b       	sbc	r31, r21

00001c1e <__udivmodsi4_ep>:
    1c1e:	66 1f       	adc	r22, r22
    1c20:	77 1f       	adc	r23, r23
    1c22:	88 1f       	adc	r24, r24
    1c24:	99 1f       	adc	r25, r25
    1c26:	1a 94       	dec	r1
    1c28:	69 f7       	brne	.-38     	; 0x1c04 <__udivmodsi4_loop>
    1c2a:	60 95       	com	r22
    1c2c:	70 95       	com	r23
    1c2e:	80 95       	com	r24
    1c30:	90 95       	com	r25
    1c32:	9b 01       	movw	r18, r22
    1c34:	ac 01       	movw	r20, r24
    1c36:	bd 01       	movw	r22, r26
    1c38:	cf 01       	movw	r24, r30
    1c3a:	08 95       	ret

00001c3c <memcpy>:
    1c3c:	fb 01       	movw	r30, r22
    1c3e:	dc 01       	movw	r26, r24
    1c40:	02 c0       	rjmp	.+4      	; 0x1c46 <memcpy+0xa>
    1c42:	01 90       	ld	r0, Z+
    1c44:	0d 92       	st	X+, r0
    1c46:	41 50       	subi	r20, 0x01	; 1
    1c48:	50 40       	sbci	r21, 0x00	; 0
    1c4a:	d8 f7       	brcc	.-10     	; 0x1c42 <memcpy+0x6>
    1c4c:	08 95       	ret

00001c4e <sprintf>:
    1c4e:	ae e0       	ldi	r26, 0x0E	; 14
    1c50:	b0 e0       	ldi	r27, 0x00	; 0
    1c52:	ed e2       	ldi	r30, 0x2D	; 45
    1c54:	fe e0       	ldi	r31, 0x0E	; 14
    1c56:	0c 94 e8 10 	jmp	0x21d0	; 0x21d0 <__prologue_saves__+0x1c>
    1c5a:	0d 89       	ldd	r16, Y+21	; 0x15
    1c5c:	1e 89       	ldd	r17, Y+22	; 0x16
    1c5e:	86 e0       	ldi	r24, 0x06	; 6
    1c60:	8c 83       	std	Y+4, r24	; 0x04
    1c62:	1a 83       	std	Y+2, r17	; 0x02
    1c64:	09 83       	std	Y+1, r16	; 0x01
    1c66:	8f ef       	ldi	r24, 0xFF	; 255
    1c68:	9f e7       	ldi	r25, 0x7F	; 127
    1c6a:	9e 83       	std	Y+6, r25	; 0x06
    1c6c:	8d 83       	std	Y+5, r24	; 0x05
    1c6e:	ae 01       	movw	r20, r28
    1c70:	47 5e       	subi	r20, 0xE7	; 231
    1c72:	5f 4f       	sbci	r21, 0xFF	; 255
    1c74:	6f 89       	ldd	r22, Y+23	; 0x17
    1c76:	78 8d       	ldd	r23, Y+24	; 0x18
    1c78:	ce 01       	movw	r24, r28
    1c7a:	01 96       	adiw	r24, 0x01	; 1
    1c7c:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <vfprintf>
    1c80:	ef 81       	ldd	r30, Y+7	; 0x07
    1c82:	f8 85       	ldd	r31, Y+8	; 0x08
    1c84:	e0 0f       	add	r30, r16
    1c86:	f1 1f       	adc	r31, r17
    1c88:	10 82       	st	Z, r1
    1c8a:	2e 96       	adiw	r28, 0x0e	; 14
    1c8c:	e4 e0       	ldi	r30, 0x04	; 4
    1c8e:	0c 94 04 11 	jmp	0x2208	; 0x2208 <__epilogue_restores__+0x1c>

00001c92 <vfprintf>:
    1c92:	ab e0       	ldi	r26, 0x0B	; 11
    1c94:	b0 e0       	ldi	r27, 0x00	; 0
    1c96:	ef e4       	ldi	r30, 0x4F	; 79
    1c98:	fe e0       	ldi	r31, 0x0E	; 14
    1c9a:	0c 94 da 10 	jmp	0x21b4	; 0x21b4 <__prologue_saves__>
    1c9e:	6c 01       	movw	r12, r24
    1ca0:	7b 01       	movw	r14, r22
    1ca2:	8a 01       	movw	r16, r20
    1ca4:	fc 01       	movw	r30, r24
    1ca6:	17 82       	std	Z+7, r1	; 0x07
    1ca8:	16 82       	std	Z+6, r1	; 0x06
    1caa:	83 81       	ldd	r24, Z+3	; 0x03
    1cac:	81 ff       	sbrs	r24, 1
    1cae:	cc c1       	rjmp	.+920    	; 0x2048 <vfprintf+0x3b6>
    1cb0:	ce 01       	movw	r24, r28
    1cb2:	01 96       	adiw	r24, 0x01	; 1
    1cb4:	3c 01       	movw	r6, r24
    1cb6:	f6 01       	movw	r30, r12
    1cb8:	93 81       	ldd	r25, Z+3	; 0x03
    1cba:	f7 01       	movw	r30, r14
    1cbc:	93 fd       	sbrc	r25, 3
    1cbe:	85 91       	lpm	r24, Z+
    1cc0:	93 ff       	sbrs	r25, 3
    1cc2:	81 91       	ld	r24, Z+
    1cc4:	7f 01       	movw	r14, r30
    1cc6:	88 23       	and	r24, r24
    1cc8:	09 f4       	brne	.+2      	; 0x1ccc <vfprintf+0x3a>
    1cca:	ba c1       	rjmp	.+884    	; 0x2040 <vfprintf+0x3ae>
    1ccc:	85 32       	cpi	r24, 0x25	; 37
    1cce:	39 f4       	brne	.+14     	; 0x1cde <vfprintf+0x4c>
    1cd0:	93 fd       	sbrc	r25, 3
    1cd2:	85 91       	lpm	r24, Z+
    1cd4:	93 ff       	sbrs	r25, 3
    1cd6:	81 91       	ld	r24, Z+
    1cd8:	7f 01       	movw	r14, r30
    1cda:	85 32       	cpi	r24, 0x25	; 37
    1cdc:	29 f4       	brne	.+10     	; 0x1ce8 <vfprintf+0x56>
    1cde:	b6 01       	movw	r22, r12
    1ce0:	90 e0       	ldi	r25, 0x00	; 0
    1ce2:	0e 94 40 10 	call	0x2080	; 0x2080 <fputc>
    1ce6:	e7 cf       	rjmp	.-50     	; 0x1cb6 <vfprintf+0x24>
    1ce8:	91 2c       	mov	r9, r1
    1cea:	21 2c       	mov	r2, r1
    1cec:	31 2c       	mov	r3, r1
    1cee:	ff e1       	ldi	r31, 0x1F	; 31
    1cf0:	f3 15       	cp	r31, r3
    1cf2:	d8 f0       	brcs	.+54     	; 0x1d2a <vfprintf+0x98>
    1cf4:	8b 32       	cpi	r24, 0x2B	; 43
    1cf6:	79 f0       	breq	.+30     	; 0x1d16 <vfprintf+0x84>
    1cf8:	38 f4       	brcc	.+14     	; 0x1d08 <vfprintf+0x76>
    1cfa:	80 32       	cpi	r24, 0x20	; 32
    1cfc:	79 f0       	breq	.+30     	; 0x1d1c <vfprintf+0x8a>
    1cfe:	83 32       	cpi	r24, 0x23	; 35
    1d00:	a1 f4       	brne	.+40     	; 0x1d2a <vfprintf+0x98>
    1d02:	23 2d       	mov	r18, r3
    1d04:	20 61       	ori	r18, 0x10	; 16
    1d06:	1d c0       	rjmp	.+58     	; 0x1d42 <vfprintf+0xb0>
    1d08:	8d 32       	cpi	r24, 0x2D	; 45
    1d0a:	61 f0       	breq	.+24     	; 0x1d24 <vfprintf+0x92>
    1d0c:	80 33       	cpi	r24, 0x30	; 48
    1d0e:	69 f4       	brne	.+26     	; 0x1d2a <vfprintf+0x98>
    1d10:	23 2d       	mov	r18, r3
    1d12:	21 60       	ori	r18, 0x01	; 1
    1d14:	16 c0       	rjmp	.+44     	; 0x1d42 <vfprintf+0xb0>
    1d16:	83 2d       	mov	r24, r3
    1d18:	82 60       	ori	r24, 0x02	; 2
    1d1a:	38 2e       	mov	r3, r24
    1d1c:	e3 2d       	mov	r30, r3
    1d1e:	e4 60       	ori	r30, 0x04	; 4
    1d20:	3e 2e       	mov	r3, r30
    1d22:	2a c0       	rjmp	.+84     	; 0x1d78 <vfprintf+0xe6>
    1d24:	f3 2d       	mov	r31, r3
    1d26:	f8 60       	ori	r31, 0x08	; 8
    1d28:	1d c0       	rjmp	.+58     	; 0x1d64 <vfprintf+0xd2>
    1d2a:	37 fc       	sbrc	r3, 7
    1d2c:	2d c0       	rjmp	.+90     	; 0x1d88 <vfprintf+0xf6>
    1d2e:	20 ed       	ldi	r18, 0xD0	; 208
    1d30:	28 0f       	add	r18, r24
    1d32:	2a 30       	cpi	r18, 0x0A	; 10
    1d34:	40 f0       	brcs	.+16     	; 0x1d46 <vfprintf+0xb4>
    1d36:	8e 32       	cpi	r24, 0x2E	; 46
    1d38:	b9 f4       	brne	.+46     	; 0x1d68 <vfprintf+0xd6>
    1d3a:	36 fc       	sbrc	r3, 6
    1d3c:	81 c1       	rjmp	.+770    	; 0x2040 <vfprintf+0x3ae>
    1d3e:	23 2d       	mov	r18, r3
    1d40:	20 64       	ori	r18, 0x40	; 64
    1d42:	32 2e       	mov	r3, r18
    1d44:	19 c0       	rjmp	.+50     	; 0x1d78 <vfprintf+0xe6>
    1d46:	36 fe       	sbrs	r3, 6
    1d48:	06 c0       	rjmp	.+12     	; 0x1d56 <vfprintf+0xc4>
    1d4a:	8a e0       	ldi	r24, 0x0A	; 10
    1d4c:	98 9e       	mul	r9, r24
    1d4e:	20 0d       	add	r18, r0
    1d50:	11 24       	eor	r1, r1
    1d52:	92 2e       	mov	r9, r18
    1d54:	11 c0       	rjmp	.+34     	; 0x1d78 <vfprintf+0xe6>
    1d56:	ea e0       	ldi	r30, 0x0A	; 10
    1d58:	2e 9e       	mul	r2, r30
    1d5a:	20 0d       	add	r18, r0
    1d5c:	11 24       	eor	r1, r1
    1d5e:	22 2e       	mov	r2, r18
    1d60:	f3 2d       	mov	r31, r3
    1d62:	f0 62       	ori	r31, 0x20	; 32
    1d64:	3f 2e       	mov	r3, r31
    1d66:	08 c0       	rjmp	.+16     	; 0x1d78 <vfprintf+0xe6>
    1d68:	8c 36       	cpi	r24, 0x6C	; 108
    1d6a:	21 f4       	brne	.+8      	; 0x1d74 <vfprintf+0xe2>
    1d6c:	83 2d       	mov	r24, r3
    1d6e:	80 68       	ori	r24, 0x80	; 128
    1d70:	38 2e       	mov	r3, r24
    1d72:	02 c0       	rjmp	.+4      	; 0x1d78 <vfprintf+0xe6>
    1d74:	88 36       	cpi	r24, 0x68	; 104
    1d76:	41 f4       	brne	.+16     	; 0x1d88 <vfprintf+0xf6>
    1d78:	f7 01       	movw	r30, r14
    1d7a:	93 fd       	sbrc	r25, 3
    1d7c:	85 91       	lpm	r24, Z+
    1d7e:	93 ff       	sbrs	r25, 3
    1d80:	81 91       	ld	r24, Z+
    1d82:	7f 01       	movw	r14, r30
    1d84:	81 11       	cpse	r24, r1
    1d86:	b3 cf       	rjmp	.-154    	; 0x1cee <vfprintf+0x5c>
    1d88:	98 2f       	mov	r25, r24
    1d8a:	9f 7d       	andi	r25, 0xDF	; 223
    1d8c:	95 54       	subi	r25, 0x45	; 69
    1d8e:	93 30       	cpi	r25, 0x03	; 3
    1d90:	28 f4       	brcc	.+10     	; 0x1d9c <vfprintf+0x10a>
    1d92:	0c 5f       	subi	r16, 0xFC	; 252
    1d94:	1f 4f       	sbci	r17, 0xFF	; 255
    1d96:	9f e3       	ldi	r25, 0x3F	; 63
    1d98:	99 83       	std	Y+1, r25	; 0x01
    1d9a:	0d c0       	rjmp	.+26     	; 0x1db6 <vfprintf+0x124>
    1d9c:	83 36       	cpi	r24, 0x63	; 99
    1d9e:	31 f0       	breq	.+12     	; 0x1dac <vfprintf+0x11a>
    1da0:	83 37       	cpi	r24, 0x73	; 115
    1da2:	71 f0       	breq	.+28     	; 0x1dc0 <vfprintf+0x12e>
    1da4:	83 35       	cpi	r24, 0x53	; 83
    1da6:	09 f0       	breq	.+2      	; 0x1daa <vfprintf+0x118>
    1da8:	59 c0       	rjmp	.+178    	; 0x1e5c <vfprintf+0x1ca>
    1daa:	21 c0       	rjmp	.+66     	; 0x1dee <vfprintf+0x15c>
    1dac:	f8 01       	movw	r30, r16
    1dae:	80 81       	ld	r24, Z
    1db0:	89 83       	std	Y+1, r24	; 0x01
    1db2:	0e 5f       	subi	r16, 0xFE	; 254
    1db4:	1f 4f       	sbci	r17, 0xFF	; 255
    1db6:	88 24       	eor	r8, r8
    1db8:	83 94       	inc	r8
    1dba:	91 2c       	mov	r9, r1
    1dbc:	53 01       	movw	r10, r6
    1dbe:	13 c0       	rjmp	.+38     	; 0x1de6 <vfprintf+0x154>
    1dc0:	28 01       	movw	r4, r16
    1dc2:	f2 e0       	ldi	r31, 0x02	; 2
    1dc4:	4f 0e       	add	r4, r31
    1dc6:	51 1c       	adc	r5, r1
    1dc8:	f8 01       	movw	r30, r16
    1dca:	a0 80       	ld	r10, Z
    1dcc:	b1 80       	ldd	r11, Z+1	; 0x01
    1dce:	36 fe       	sbrs	r3, 6
    1dd0:	03 c0       	rjmp	.+6      	; 0x1dd8 <vfprintf+0x146>
    1dd2:	69 2d       	mov	r22, r9
    1dd4:	70 e0       	ldi	r23, 0x00	; 0
    1dd6:	02 c0       	rjmp	.+4      	; 0x1ddc <vfprintf+0x14a>
    1dd8:	6f ef       	ldi	r22, 0xFF	; 255
    1dda:	7f ef       	ldi	r23, 0xFF	; 255
    1ddc:	c5 01       	movw	r24, r10
    1dde:	0e 94 35 10 	call	0x206a	; 0x206a <strnlen>
    1de2:	4c 01       	movw	r8, r24
    1de4:	82 01       	movw	r16, r4
    1de6:	f3 2d       	mov	r31, r3
    1de8:	ff 77       	andi	r31, 0x7F	; 127
    1dea:	3f 2e       	mov	r3, r31
    1dec:	16 c0       	rjmp	.+44     	; 0x1e1a <vfprintf+0x188>
    1dee:	28 01       	movw	r4, r16
    1df0:	22 e0       	ldi	r18, 0x02	; 2
    1df2:	42 0e       	add	r4, r18
    1df4:	51 1c       	adc	r5, r1
    1df6:	f8 01       	movw	r30, r16
    1df8:	a0 80       	ld	r10, Z
    1dfa:	b1 80       	ldd	r11, Z+1	; 0x01
    1dfc:	36 fe       	sbrs	r3, 6
    1dfe:	03 c0       	rjmp	.+6      	; 0x1e06 <vfprintf+0x174>
    1e00:	69 2d       	mov	r22, r9
    1e02:	70 e0       	ldi	r23, 0x00	; 0
    1e04:	02 c0       	rjmp	.+4      	; 0x1e0a <vfprintf+0x178>
    1e06:	6f ef       	ldi	r22, 0xFF	; 255
    1e08:	7f ef       	ldi	r23, 0xFF	; 255
    1e0a:	c5 01       	movw	r24, r10
    1e0c:	0e 94 2a 10 	call	0x2054	; 0x2054 <strnlen_P>
    1e10:	4c 01       	movw	r8, r24
    1e12:	f3 2d       	mov	r31, r3
    1e14:	f0 68       	ori	r31, 0x80	; 128
    1e16:	3f 2e       	mov	r3, r31
    1e18:	82 01       	movw	r16, r4
    1e1a:	33 fc       	sbrc	r3, 3
    1e1c:	1b c0       	rjmp	.+54     	; 0x1e54 <vfprintf+0x1c2>
    1e1e:	82 2d       	mov	r24, r2
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	88 16       	cp	r8, r24
    1e24:	99 06       	cpc	r9, r25
    1e26:	b0 f4       	brcc	.+44     	; 0x1e54 <vfprintf+0x1c2>
    1e28:	b6 01       	movw	r22, r12
    1e2a:	80 e2       	ldi	r24, 0x20	; 32
    1e2c:	90 e0       	ldi	r25, 0x00	; 0
    1e2e:	0e 94 40 10 	call	0x2080	; 0x2080 <fputc>
    1e32:	2a 94       	dec	r2
    1e34:	f4 cf       	rjmp	.-24     	; 0x1e1e <vfprintf+0x18c>
    1e36:	f5 01       	movw	r30, r10
    1e38:	37 fc       	sbrc	r3, 7
    1e3a:	85 91       	lpm	r24, Z+
    1e3c:	37 fe       	sbrs	r3, 7
    1e3e:	81 91       	ld	r24, Z+
    1e40:	5f 01       	movw	r10, r30
    1e42:	b6 01       	movw	r22, r12
    1e44:	90 e0       	ldi	r25, 0x00	; 0
    1e46:	0e 94 40 10 	call	0x2080	; 0x2080 <fputc>
    1e4a:	21 10       	cpse	r2, r1
    1e4c:	2a 94       	dec	r2
    1e4e:	21 e0       	ldi	r18, 0x01	; 1
    1e50:	82 1a       	sub	r8, r18
    1e52:	91 08       	sbc	r9, r1
    1e54:	81 14       	cp	r8, r1
    1e56:	91 04       	cpc	r9, r1
    1e58:	71 f7       	brne	.-36     	; 0x1e36 <vfprintf+0x1a4>
    1e5a:	e8 c0       	rjmp	.+464    	; 0x202c <vfprintf+0x39a>
    1e5c:	84 36       	cpi	r24, 0x64	; 100
    1e5e:	11 f0       	breq	.+4      	; 0x1e64 <vfprintf+0x1d2>
    1e60:	89 36       	cpi	r24, 0x69	; 105
    1e62:	41 f5       	brne	.+80     	; 0x1eb4 <vfprintf+0x222>
    1e64:	f8 01       	movw	r30, r16
    1e66:	37 fe       	sbrs	r3, 7
    1e68:	07 c0       	rjmp	.+14     	; 0x1e78 <vfprintf+0x1e6>
    1e6a:	60 81       	ld	r22, Z
    1e6c:	71 81       	ldd	r23, Z+1	; 0x01
    1e6e:	82 81       	ldd	r24, Z+2	; 0x02
    1e70:	93 81       	ldd	r25, Z+3	; 0x03
    1e72:	0c 5f       	subi	r16, 0xFC	; 252
    1e74:	1f 4f       	sbci	r17, 0xFF	; 255
    1e76:	08 c0       	rjmp	.+16     	; 0x1e88 <vfprintf+0x1f6>
    1e78:	60 81       	ld	r22, Z
    1e7a:	71 81       	ldd	r23, Z+1	; 0x01
    1e7c:	07 2e       	mov	r0, r23
    1e7e:	00 0c       	add	r0, r0
    1e80:	88 0b       	sbc	r24, r24
    1e82:	99 0b       	sbc	r25, r25
    1e84:	0e 5f       	subi	r16, 0xFE	; 254
    1e86:	1f 4f       	sbci	r17, 0xFF	; 255
    1e88:	f3 2d       	mov	r31, r3
    1e8a:	ff 76       	andi	r31, 0x6F	; 111
    1e8c:	3f 2e       	mov	r3, r31
    1e8e:	97 ff       	sbrs	r25, 7
    1e90:	09 c0       	rjmp	.+18     	; 0x1ea4 <vfprintf+0x212>
    1e92:	90 95       	com	r25
    1e94:	80 95       	com	r24
    1e96:	70 95       	com	r23
    1e98:	61 95       	neg	r22
    1e9a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e9c:	8f 4f       	sbci	r24, 0xFF	; 255
    1e9e:	9f 4f       	sbci	r25, 0xFF	; 255
    1ea0:	f0 68       	ori	r31, 0x80	; 128
    1ea2:	3f 2e       	mov	r3, r31
    1ea4:	2a e0       	ldi	r18, 0x0A	; 10
    1ea6:	30 e0       	ldi	r19, 0x00	; 0
    1ea8:	a3 01       	movw	r20, r6
    1eaa:	0e 94 7c 10 	call	0x20f8	; 0x20f8 <__ultoa_invert>
    1eae:	88 2e       	mov	r8, r24
    1eb0:	86 18       	sub	r8, r6
    1eb2:	45 c0       	rjmp	.+138    	; 0x1f3e <vfprintf+0x2ac>
    1eb4:	85 37       	cpi	r24, 0x75	; 117
    1eb6:	31 f4       	brne	.+12     	; 0x1ec4 <vfprintf+0x232>
    1eb8:	23 2d       	mov	r18, r3
    1eba:	2f 7e       	andi	r18, 0xEF	; 239
    1ebc:	b2 2e       	mov	r11, r18
    1ebe:	2a e0       	ldi	r18, 0x0A	; 10
    1ec0:	30 e0       	ldi	r19, 0x00	; 0
    1ec2:	25 c0       	rjmp	.+74     	; 0x1f0e <vfprintf+0x27c>
    1ec4:	93 2d       	mov	r25, r3
    1ec6:	99 7f       	andi	r25, 0xF9	; 249
    1ec8:	b9 2e       	mov	r11, r25
    1eca:	8f 36       	cpi	r24, 0x6F	; 111
    1ecc:	c1 f0       	breq	.+48     	; 0x1efe <vfprintf+0x26c>
    1ece:	18 f4       	brcc	.+6      	; 0x1ed6 <vfprintf+0x244>
    1ed0:	88 35       	cpi	r24, 0x58	; 88
    1ed2:	79 f0       	breq	.+30     	; 0x1ef2 <vfprintf+0x260>
    1ed4:	b5 c0       	rjmp	.+362    	; 0x2040 <vfprintf+0x3ae>
    1ed6:	80 37       	cpi	r24, 0x70	; 112
    1ed8:	19 f0       	breq	.+6      	; 0x1ee0 <vfprintf+0x24e>
    1eda:	88 37       	cpi	r24, 0x78	; 120
    1edc:	21 f0       	breq	.+8      	; 0x1ee6 <vfprintf+0x254>
    1ede:	b0 c0       	rjmp	.+352    	; 0x2040 <vfprintf+0x3ae>
    1ee0:	e9 2f       	mov	r30, r25
    1ee2:	e0 61       	ori	r30, 0x10	; 16
    1ee4:	be 2e       	mov	r11, r30
    1ee6:	b4 fe       	sbrs	r11, 4
    1ee8:	0d c0       	rjmp	.+26     	; 0x1f04 <vfprintf+0x272>
    1eea:	fb 2d       	mov	r31, r11
    1eec:	f4 60       	ori	r31, 0x04	; 4
    1eee:	bf 2e       	mov	r11, r31
    1ef0:	09 c0       	rjmp	.+18     	; 0x1f04 <vfprintf+0x272>
    1ef2:	34 fe       	sbrs	r3, 4
    1ef4:	0a c0       	rjmp	.+20     	; 0x1f0a <vfprintf+0x278>
    1ef6:	29 2f       	mov	r18, r25
    1ef8:	26 60       	ori	r18, 0x06	; 6
    1efa:	b2 2e       	mov	r11, r18
    1efc:	06 c0       	rjmp	.+12     	; 0x1f0a <vfprintf+0x278>
    1efe:	28 e0       	ldi	r18, 0x08	; 8
    1f00:	30 e0       	ldi	r19, 0x00	; 0
    1f02:	05 c0       	rjmp	.+10     	; 0x1f0e <vfprintf+0x27c>
    1f04:	20 e1       	ldi	r18, 0x10	; 16
    1f06:	30 e0       	ldi	r19, 0x00	; 0
    1f08:	02 c0       	rjmp	.+4      	; 0x1f0e <vfprintf+0x27c>
    1f0a:	20 e1       	ldi	r18, 0x10	; 16
    1f0c:	32 e0       	ldi	r19, 0x02	; 2
    1f0e:	f8 01       	movw	r30, r16
    1f10:	b7 fe       	sbrs	r11, 7
    1f12:	07 c0       	rjmp	.+14     	; 0x1f22 <vfprintf+0x290>
    1f14:	60 81       	ld	r22, Z
    1f16:	71 81       	ldd	r23, Z+1	; 0x01
    1f18:	82 81       	ldd	r24, Z+2	; 0x02
    1f1a:	93 81       	ldd	r25, Z+3	; 0x03
    1f1c:	0c 5f       	subi	r16, 0xFC	; 252
    1f1e:	1f 4f       	sbci	r17, 0xFF	; 255
    1f20:	06 c0       	rjmp	.+12     	; 0x1f2e <vfprintf+0x29c>
    1f22:	60 81       	ld	r22, Z
    1f24:	71 81       	ldd	r23, Z+1	; 0x01
    1f26:	80 e0       	ldi	r24, 0x00	; 0
    1f28:	90 e0       	ldi	r25, 0x00	; 0
    1f2a:	0e 5f       	subi	r16, 0xFE	; 254
    1f2c:	1f 4f       	sbci	r17, 0xFF	; 255
    1f2e:	a3 01       	movw	r20, r6
    1f30:	0e 94 7c 10 	call	0x20f8	; 0x20f8 <__ultoa_invert>
    1f34:	88 2e       	mov	r8, r24
    1f36:	86 18       	sub	r8, r6
    1f38:	fb 2d       	mov	r31, r11
    1f3a:	ff 77       	andi	r31, 0x7F	; 127
    1f3c:	3f 2e       	mov	r3, r31
    1f3e:	36 fe       	sbrs	r3, 6
    1f40:	0d c0       	rjmp	.+26     	; 0x1f5c <vfprintf+0x2ca>
    1f42:	23 2d       	mov	r18, r3
    1f44:	2e 7f       	andi	r18, 0xFE	; 254
    1f46:	a2 2e       	mov	r10, r18
    1f48:	89 14       	cp	r8, r9
    1f4a:	58 f4       	brcc	.+22     	; 0x1f62 <vfprintf+0x2d0>
    1f4c:	34 fe       	sbrs	r3, 4
    1f4e:	0b c0       	rjmp	.+22     	; 0x1f66 <vfprintf+0x2d4>
    1f50:	32 fc       	sbrc	r3, 2
    1f52:	09 c0       	rjmp	.+18     	; 0x1f66 <vfprintf+0x2d4>
    1f54:	83 2d       	mov	r24, r3
    1f56:	8e 7e       	andi	r24, 0xEE	; 238
    1f58:	a8 2e       	mov	r10, r24
    1f5a:	05 c0       	rjmp	.+10     	; 0x1f66 <vfprintf+0x2d4>
    1f5c:	b8 2c       	mov	r11, r8
    1f5e:	a3 2c       	mov	r10, r3
    1f60:	03 c0       	rjmp	.+6      	; 0x1f68 <vfprintf+0x2d6>
    1f62:	b8 2c       	mov	r11, r8
    1f64:	01 c0       	rjmp	.+2      	; 0x1f68 <vfprintf+0x2d6>
    1f66:	b9 2c       	mov	r11, r9
    1f68:	a4 fe       	sbrs	r10, 4
    1f6a:	0f c0       	rjmp	.+30     	; 0x1f8a <vfprintf+0x2f8>
    1f6c:	fe 01       	movw	r30, r28
    1f6e:	e8 0d       	add	r30, r8
    1f70:	f1 1d       	adc	r31, r1
    1f72:	80 81       	ld	r24, Z
    1f74:	80 33       	cpi	r24, 0x30	; 48
    1f76:	21 f4       	brne	.+8      	; 0x1f80 <vfprintf+0x2ee>
    1f78:	9a 2d       	mov	r25, r10
    1f7a:	99 7e       	andi	r25, 0xE9	; 233
    1f7c:	a9 2e       	mov	r10, r25
    1f7e:	09 c0       	rjmp	.+18     	; 0x1f92 <vfprintf+0x300>
    1f80:	a2 fe       	sbrs	r10, 2
    1f82:	06 c0       	rjmp	.+12     	; 0x1f90 <vfprintf+0x2fe>
    1f84:	b3 94       	inc	r11
    1f86:	b3 94       	inc	r11
    1f88:	04 c0       	rjmp	.+8      	; 0x1f92 <vfprintf+0x300>
    1f8a:	8a 2d       	mov	r24, r10
    1f8c:	86 78       	andi	r24, 0x86	; 134
    1f8e:	09 f0       	breq	.+2      	; 0x1f92 <vfprintf+0x300>
    1f90:	b3 94       	inc	r11
    1f92:	a3 fc       	sbrc	r10, 3
    1f94:	11 c0       	rjmp	.+34     	; 0x1fb8 <vfprintf+0x326>
    1f96:	a0 fe       	sbrs	r10, 0
    1f98:	06 c0       	rjmp	.+12     	; 0x1fa6 <vfprintf+0x314>
    1f9a:	b2 14       	cp	r11, r2
    1f9c:	88 f4       	brcc	.+34     	; 0x1fc0 <vfprintf+0x32e>
    1f9e:	28 0c       	add	r2, r8
    1fa0:	92 2c       	mov	r9, r2
    1fa2:	9b 18       	sub	r9, r11
    1fa4:	0e c0       	rjmp	.+28     	; 0x1fc2 <vfprintf+0x330>
    1fa6:	b2 14       	cp	r11, r2
    1fa8:	60 f4       	brcc	.+24     	; 0x1fc2 <vfprintf+0x330>
    1faa:	b6 01       	movw	r22, r12
    1fac:	80 e2       	ldi	r24, 0x20	; 32
    1fae:	90 e0       	ldi	r25, 0x00	; 0
    1fb0:	0e 94 40 10 	call	0x2080	; 0x2080 <fputc>
    1fb4:	b3 94       	inc	r11
    1fb6:	f7 cf       	rjmp	.-18     	; 0x1fa6 <vfprintf+0x314>
    1fb8:	b2 14       	cp	r11, r2
    1fba:	18 f4       	brcc	.+6      	; 0x1fc2 <vfprintf+0x330>
    1fbc:	2b 18       	sub	r2, r11
    1fbe:	02 c0       	rjmp	.+4      	; 0x1fc4 <vfprintf+0x332>
    1fc0:	98 2c       	mov	r9, r8
    1fc2:	21 2c       	mov	r2, r1
    1fc4:	a4 fe       	sbrs	r10, 4
    1fc6:	10 c0       	rjmp	.+32     	; 0x1fe8 <vfprintf+0x356>
    1fc8:	b6 01       	movw	r22, r12
    1fca:	80 e3       	ldi	r24, 0x30	; 48
    1fcc:	90 e0       	ldi	r25, 0x00	; 0
    1fce:	0e 94 40 10 	call	0x2080	; 0x2080 <fputc>
    1fd2:	a2 fe       	sbrs	r10, 2
    1fd4:	17 c0       	rjmp	.+46     	; 0x2004 <vfprintf+0x372>
    1fd6:	a1 fc       	sbrc	r10, 1
    1fd8:	03 c0       	rjmp	.+6      	; 0x1fe0 <vfprintf+0x34e>
    1fda:	88 e7       	ldi	r24, 0x78	; 120
    1fdc:	90 e0       	ldi	r25, 0x00	; 0
    1fde:	02 c0       	rjmp	.+4      	; 0x1fe4 <vfprintf+0x352>
    1fe0:	88 e5       	ldi	r24, 0x58	; 88
    1fe2:	90 e0       	ldi	r25, 0x00	; 0
    1fe4:	b6 01       	movw	r22, r12
    1fe6:	0c c0       	rjmp	.+24     	; 0x2000 <vfprintf+0x36e>
    1fe8:	8a 2d       	mov	r24, r10
    1fea:	86 78       	andi	r24, 0x86	; 134
    1fec:	59 f0       	breq	.+22     	; 0x2004 <vfprintf+0x372>
    1fee:	a1 fe       	sbrs	r10, 1
    1ff0:	02 c0       	rjmp	.+4      	; 0x1ff6 <vfprintf+0x364>
    1ff2:	8b e2       	ldi	r24, 0x2B	; 43
    1ff4:	01 c0       	rjmp	.+2      	; 0x1ff8 <vfprintf+0x366>
    1ff6:	80 e2       	ldi	r24, 0x20	; 32
    1ff8:	a7 fc       	sbrc	r10, 7
    1ffa:	8d e2       	ldi	r24, 0x2D	; 45
    1ffc:	b6 01       	movw	r22, r12
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	0e 94 40 10 	call	0x2080	; 0x2080 <fputc>
    2004:	89 14       	cp	r8, r9
    2006:	38 f4       	brcc	.+14     	; 0x2016 <vfprintf+0x384>
    2008:	b6 01       	movw	r22, r12
    200a:	80 e3       	ldi	r24, 0x30	; 48
    200c:	90 e0       	ldi	r25, 0x00	; 0
    200e:	0e 94 40 10 	call	0x2080	; 0x2080 <fputc>
    2012:	9a 94       	dec	r9
    2014:	f7 cf       	rjmp	.-18     	; 0x2004 <vfprintf+0x372>
    2016:	8a 94       	dec	r8
    2018:	f3 01       	movw	r30, r6
    201a:	e8 0d       	add	r30, r8
    201c:	f1 1d       	adc	r31, r1
    201e:	80 81       	ld	r24, Z
    2020:	b6 01       	movw	r22, r12
    2022:	90 e0       	ldi	r25, 0x00	; 0
    2024:	0e 94 40 10 	call	0x2080	; 0x2080 <fputc>
    2028:	81 10       	cpse	r8, r1
    202a:	f5 cf       	rjmp	.-22     	; 0x2016 <vfprintf+0x384>
    202c:	22 20       	and	r2, r2
    202e:	09 f4       	brne	.+2      	; 0x2032 <vfprintf+0x3a0>
    2030:	42 ce       	rjmp	.-892    	; 0x1cb6 <vfprintf+0x24>
    2032:	b6 01       	movw	r22, r12
    2034:	80 e2       	ldi	r24, 0x20	; 32
    2036:	90 e0       	ldi	r25, 0x00	; 0
    2038:	0e 94 40 10 	call	0x2080	; 0x2080 <fputc>
    203c:	2a 94       	dec	r2
    203e:	f6 cf       	rjmp	.-20     	; 0x202c <vfprintf+0x39a>
    2040:	f6 01       	movw	r30, r12
    2042:	86 81       	ldd	r24, Z+6	; 0x06
    2044:	97 81       	ldd	r25, Z+7	; 0x07
    2046:	02 c0       	rjmp	.+4      	; 0x204c <vfprintf+0x3ba>
    2048:	8f ef       	ldi	r24, 0xFF	; 255
    204a:	9f ef       	ldi	r25, 0xFF	; 255
    204c:	2b 96       	adiw	r28, 0x0b	; 11
    204e:	e2 e1       	ldi	r30, 0x12	; 18
    2050:	0c 94 f6 10 	jmp	0x21ec	; 0x21ec <__epilogue_restores__>

00002054 <strnlen_P>:
    2054:	fc 01       	movw	r30, r24
    2056:	05 90       	lpm	r0, Z+
    2058:	61 50       	subi	r22, 0x01	; 1
    205a:	70 40       	sbci	r23, 0x00	; 0
    205c:	01 10       	cpse	r0, r1
    205e:	d8 f7       	brcc	.-10     	; 0x2056 <strnlen_P+0x2>
    2060:	80 95       	com	r24
    2062:	90 95       	com	r25
    2064:	8e 0f       	add	r24, r30
    2066:	9f 1f       	adc	r25, r31
    2068:	08 95       	ret

0000206a <strnlen>:
    206a:	fc 01       	movw	r30, r24
    206c:	61 50       	subi	r22, 0x01	; 1
    206e:	70 40       	sbci	r23, 0x00	; 0
    2070:	01 90       	ld	r0, Z+
    2072:	01 10       	cpse	r0, r1
    2074:	d8 f7       	brcc	.-10     	; 0x206c <strnlen+0x2>
    2076:	80 95       	com	r24
    2078:	90 95       	com	r25
    207a:	8e 0f       	add	r24, r30
    207c:	9f 1f       	adc	r25, r31
    207e:	08 95       	ret

00002080 <fputc>:
    2080:	0f 93       	push	r16
    2082:	1f 93       	push	r17
    2084:	cf 93       	push	r28
    2086:	df 93       	push	r29
    2088:	fb 01       	movw	r30, r22
    208a:	23 81       	ldd	r18, Z+3	; 0x03
    208c:	21 fd       	sbrc	r18, 1
    208e:	03 c0       	rjmp	.+6      	; 0x2096 <fputc+0x16>
    2090:	8f ef       	ldi	r24, 0xFF	; 255
    2092:	9f ef       	ldi	r25, 0xFF	; 255
    2094:	2c c0       	rjmp	.+88     	; 0x20ee <fputc+0x6e>
    2096:	22 ff       	sbrs	r18, 2
    2098:	16 c0       	rjmp	.+44     	; 0x20c6 <fputc+0x46>
    209a:	46 81       	ldd	r20, Z+6	; 0x06
    209c:	57 81       	ldd	r21, Z+7	; 0x07
    209e:	24 81       	ldd	r18, Z+4	; 0x04
    20a0:	35 81       	ldd	r19, Z+5	; 0x05
    20a2:	42 17       	cp	r20, r18
    20a4:	53 07       	cpc	r21, r19
    20a6:	44 f4       	brge	.+16     	; 0x20b8 <fputc+0x38>
    20a8:	a0 81       	ld	r26, Z
    20aa:	b1 81       	ldd	r27, Z+1	; 0x01
    20ac:	9d 01       	movw	r18, r26
    20ae:	2f 5f       	subi	r18, 0xFF	; 255
    20b0:	3f 4f       	sbci	r19, 0xFF	; 255
    20b2:	31 83       	std	Z+1, r19	; 0x01
    20b4:	20 83       	st	Z, r18
    20b6:	8c 93       	st	X, r24
    20b8:	26 81       	ldd	r18, Z+6	; 0x06
    20ba:	37 81       	ldd	r19, Z+7	; 0x07
    20bc:	2f 5f       	subi	r18, 0xFF	; 255
    20be:	3f 4f       	sbci	r19, 0xFF	; 255
    20c0:	37 83       	std	Z+7, r19	; 0x07
    20c2:	26 83       	std	Z+6, r18	; 0x06
    20c4:	14 c0       	rjmp	.+40     	; 0x20ee <fputc+0x6e>
    20c6:	8b 01       	movw	r16, r22
    20c8:	ec 01       	movw	r28, r24
    20ca:	fb 01       	movw	r30, r22
    20cc:	00 84       	ldd	r0, Z+8	; 0x08
    20ce:	f1 85       	ldd	r31, Z+9	; 0x09
    20d0:	e0 2d       	mov	r30, r0
    20d2:	09 95       	icall
    20d4:	89 2b       	or	r24, r25
    20d6:	e1 f6       	brne	.-72     	; 0x2090 <fputc+0x10>
    20d8:	d8 01       	movw	r26, r16
    20da:	16 96       	adiw	r26, 0x06	; 6
    20dc:	8d 91       	ld	r24, X+
    20de:	9c 91       	ld	r25, X
    20e0:	17 97       	sbiw	r26, 0x07	; 7
    20e2:	01 96       	adiw	r24, 0x01	; 1
    20e4:	17 96       	adiw	r26, 0x07	; 7
    20e6:	9c 93       	st	X, r25
    20e8:	8e 93       	st	-X, r24
    20ea:	16 97       	sbiw	r26, 0x06	; 6
    20ec:	ce 01       	movw	r24, r28
    20ee:	df 91       	pop	r29
    20f0:	cf 91       	pop	r28
    20f2:	1f 91       	pop	r17
    20f4:	0f 91       	pop	r16
    20f6:	08 95       	ret

000020f8 <__ultoa_invert>:
    20f8:	fa 01       	movw	r30, r20
    20fa:	aa 27       	eor	r26, r26
    20fc:	28 30       	cpi	r18, 0x08	; 8
    20fe:	51 f1       	breq	.+84     	; 0x2154 <__ultoa_invert+0x5c>
    2100:	20 31       	cpi	r18, 0x10	; 16
    2102:	81 f1       	breq	.+96     	; 0x2164 <__ultoa_invert+0x6c>
    2104:	e8 94       	clt
    2106:	6f 93       	push	r22
    2108:	6e 7f       	andi	r22, 0xFE	; 254
    210a:	6e 5f       	subi	r22, 0xFE	; 254
    210c:	7f 4f       	sbci	r23, 0xFF	; 255
    210e:	8f 4f       	sbci	r24, 0xFF	; 255
    2110:	9f 4f       	sbci	r25, 0xFF	; 255
    2112:	af 4f       	sbci	r26, 0xFF	; 255
    2114:	b1 e0       	ldi	r27, 0x01	; 1
    2116:	3e d0       	rcall	.+124    	; 0x2194 <__ultoa_invert+0x9c>
    2118:	b4 e0       	ldi	r27, 0x04	; 4
    211a:	3c d0       	rcall	.+120    	; 0x2194 <__ultoa_invert+0x9c>
    211c:	67 0f       	add	r22, r23
    211e:	78 1f       	adc	r23, r24
    2120:	89 1f       	adc	r24, r25
    2122:	9a 1f       	adc	r25, r26
    2124:	a1 1d       	adc	r26, r1
    2126:	68 0f       	add	r22, r24
    2128:	79 1f       	adc	r23, r25
    212a:	8a 1f       	adc	r24, r26
    212c:	91 1d       	adc	r25, r1
    212e:	a1 1d       	adc	r26, r1
    2130:	6a 0f       	add	r22, r26
    2132:	71 1d       	adc	r23, r1
    2134:	81 1d       	adc	r24, r1
    2136:	91 1d       	adc	r25, r1
    2138:	a1 1d       	adc	r26, r1
    213a:	20 d0       	rcall	.+64     	; 0x217c <__ultoa_invert+0x84>
    213c:	09 f4       	brne	.+2      	; 0x2140 <__ultoa_invert+0x48>
    213e:	68 94       	set
    2140:	3f 91       	pop	r19
    2142:	2a e0       	ldi	r18, 0x0A	; 10
    2144:	26 9f       	mul	r18, r22
    2146:	11 24       	eor	r1, r1
    2148:	30 19       	sub	r19, r0
    214a:	30 5d       	subi	r19, 0xD0	; 208
    214c:	31 93       	st	Z+, r19
    214e:	de f6       	brtc	.-74     	; 0x2106 <__ultoa_invert+0xe>
    2150:	cf 01       	movw	r24, r30
    2152:	08 95       	ret
    2154:	46 2f       	mov	r20, r22
    2156:	47 70       	andi	r20, 0x07	; 7
    2158:	40 5d       	subi	r20, 0xD0	; 208
    215a:	41 93       	st	Z+, r20
    215c:	b3 e0       	ldi	r27, 0x03	; 3
    215e:	0f d0       	rcall	.+30     	; 0x217e <__ultoa_invert+0x86>
    2160:	c9 f7       	brne	.-14     	; 0x2154 <__ultoa_invert+0x5c>
    2162:	f6 cf       	rjmp	.-20     	; 0x2150 <__ultoa_invert+0x58>
    2164:	46 2f       	mov	r20, r22
    2166:	4f 70       	andi	r20, 0x0F	; 15
    2168:	40 5d       	subi	r20, 0xD0	; 208
    216a:	4a 33       	cpi	r20, 0x3A	; 58
    216c:	18 f0       	brcs	.+6      	; 0x2174 <__ultoa_invert+0x7c>
    216e:	49 5d       	subi	r20, 0xD9	; 217
    2170:	31 fd       	sbrc	r19, 1
    2172:	40 52       	subi	r20, 0x20	; 32
    2174:	41 93       	st	Z+, r20
    2176:	02 d0       	rcall	.+4      	; 0x217c <__ultoa_invert+0x84>
    2178:	a9 f7       	brne	.-22     	; 0x2164 <__ultoa_invert+0x6c>
    217a:	ea cf       	rjmp	.-44     	; 0x2150 <__ultoa_invert+0x58>
    217c:	b4 e0       	ldi	r27, 0x04	; 4
    217e:	a6 95       	lsr	r26
    2180:	97 95       	ror	r25
    2182:	87 95       	ror	r24
    2184:	77 95       	ror	r23
    2186:	67 95       	ror	r22
    2188:	ba 95       	dec	r27
    218a:	c9 f7       	brne	.-14     	; 0x217e <__ultoa_invert+0x86>
    218c:	00 97       	sbiw	r24, 0x00	; 0
    218e:	61 05       	cpc	r22, r1
    2190:	71 05       	cpc	r23, r1
    2192:	08 95       	ret
    2194:	9b 01       	movw	r18, r22
    2196:	ac 01       	movw	r20, r24
    2198:	0a 2e       	mov	r0, r26
    219a:	06 94       	lsr	r0
    219c:	57 95       	ror	r21
    219e:	47 95       	ror	r20
    21a0:	37 95       	ror	r19
    21a2:	27 95       	ror	r18
    21a4:	ba 95       	dec	r27
    21a6:	c9 f7       	brne	.-14     	; 0x219a <__ultoa_invert+0xa2>
    21a8:	62 0f       	add	r22, r18
    21aa:	73 1f       	adc	r23, r19
    21ac:	84 1f       	adc	r24, r20
    21ae:	95 1f       	adc	r25, r21
    21b0:	a0 1d       	adc	r26, r0
    21b2:	08 95       	ret

000021b4 <__prologue_saves__>:
    21b4:	2f 92       	push	r2
    21b6:	3f 92       	push	r3
    21b8:	4f 92       	push	r4
    21ba:	5f 92       	push	r5
    21bc:	6f 92       	push	r6
    21be:	7f 92       	push	r7
    21c0:	8f 92       	push	r8
    21c2:	9f 92       	push	r9
    21c4:	af 92       	push	r10
    21c6:	bf 92       	push	r11
    21c8:	cf 92       	push	r12
    21ca:	df 92       	push	r13
    21cc:	ef 92       	push	r14
    21ce:	ff 92       	push	r15
    21d0:	0f 93       	push	r16
    21d2:	1f 93       	push	r17
    21d4:	cf 93       	push	r28
    21d6:	df 93       	push	r29
    21d8:	cd b7       	in	r28, 0x3d	; 61
    21da:	de b7       	in	r29, 0x3e	; 62
    21dc:	ca 1b       	sub	r28, r26
    21de:	db 0b       	sbc	r29, r27
    21e0:	0f b6       	in	r0, 0x3f	; 63
    21e2:	f8 94       	cli
    21e4:	de bf       	out	0x3e, r29	; 62
    21e6:	0f be       	out	0x3f, r0	; 63
    21e8:	cd bf       	out	0x3d, r28	; 61
    21ea:	09 94       	ijmp

000021ec <__epilogue_restores__>:
    21ec:	2a 88       	ldd	r2, Y+18	; 0x12
    21ee:	39 88       	ldd	r3, Y+17	; 0x11
    21f0:	48 88       	ldd	r4, Y+16	; 0x10
    21f2:	5f 84       	ldd	r5, Y+15	; 0x0f
    21f4:	6e 84       	ldd	r6, Y+14	; 0x0e
    21f6:	7d 84       	ldd	r7, Y+13	; 0x0d
    21f8:	8c 84       	ldd	r8, Y+12	; 0x0c
    21fa:	9b 84       	ldd	r9, Y+11	; 0x0b
    21fc:	aa 84       	ldd	r10, Y+10	; 0x0a
    21fe:	b9 84       	ldd	r11, Y+9	; 0x09
    2200:	c8 84       	ldd	r12, Y+8	; 0x08
    2202:	df 80       	ldd	r13, Y+7	; 0x07
    2204:	ee 80       	ldd	r14, Y+6	; 0x06
    2206:	fd 80       	ldd	r15, Y+5	; 0x05
    2208:	0c 81       	ldd	r16, Y+4	; 0x04
    220a:	1b 81       	ldd	r17, Y+3	; 0x03
    220c:	aa 81       	ldd	r26, Y+2	; 0x02
    220e:	b9 81       	ldd	r27, Y+1	; 0x01
    2210:	ce 0f       	add	r28, r30
    2212:	d1 1d       	adc	r29, r1
    2214:	0f b6       	in	r0, 0x3f	; 63
    2216:	f8 94       	cli
    2218:	de bf       	out	0x3e, r29	; 62
    221a:	0f be       	out	0x3f, r0	; 63
    221c:	cd bf       	out	0x3d, r28	; 61
    221e:	ed 01       	movw	r28, r26
    2220:	08 95       	ret

00002222 <_exit>:
    2222:	f8 94       	cli

00002224 <__stop_program>:
    2224:	ff cf       	rjmp	.-2      	; 0x2224 <__stop_program>
