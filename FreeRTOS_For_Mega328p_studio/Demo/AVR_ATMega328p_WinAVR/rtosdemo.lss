
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000066  00800100  000032d2  00003366  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000032d2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006aa  00800166  00800166  000033cc  2**0
                  ALLOC
  3 .debug_aranges 000001e0  00000000  00000000  000033cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000a48  00000000  00000000  000035ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003a67  00000000  00000000  00003ff4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000011be  00000000  00000000  00007a5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003911  00000000  00000000  00008c19  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000800  00000000  00000000  0000c52c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000188f  00000000  00000000  0000cd2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002205  00000000  00000000  0000e5bb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  000107c0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 fd 12 	jmp	0x25fa	; 0x25fa <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 33 03 	jmp	0x666	; 0x666 <__vector_18>
      4c:	0c 94 f1 02 	jmp	0x5e2	; 0x5e2 <__vector_19>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e2 ed       	ldi	r30, 0xD2	; 210
      7c:	f2 e3       	ldi	r31, 0x32	; 50
      7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
      84:	a6 36       	cpi	r26, 0x66	; 102
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
      8a:	18 e0       	ldi	r17, 0x08	; 8
      8c:	a6 e6       	ldi	r26, 0x66	; 102
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a0 31       	cpi	r26, 0x10	; 16
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 56 00 	call	0xac	; 0xac <main>
      9e:	0c 94 67 19 	jmp	0x32ce	; 0x32ce <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vApplicationIdleHook>:
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	vCoRoutineSchedule();
      a6:	0e 94 44 10 	call	0x2088	; 0x2088 <vCoRoutineSchedule>
}
      aa:	08 95       	ret

000000ac <main>:
		print(MsgBuff,strlen(MsgBuff));
	}

}
short main( void )
{
      ac:	ef 92       	push	r14
      ae:	ff 92       	push	r15
      b0:	0f 93       	push	r16
      b2:	df 93       	push	r29
      b4:	cf 93       	push	r28
      b6:	0f 92       	push	r0
      b8:	cd b7       	in	r28, 0x3d	; 61
      ba:	de b7       	in	r29, 0x3e	; 62

static void prvIncrementResetCount( void )
{
unsigned char ucCount;

	eeprom_read_block( &ucCount, mainRESET_COUNT_ADDRESS, sizeof( ucCount ) );
      bc:	ce 01       	movw	r24, r28
      be:	01 96       	adiw	r24, 0x01	; 1
      c0:	60 e5       	ldi	r22, 0x50	; 80
      c2:	70 e0       	ldi	r23, 0x00	; 0
      c4:	41 e0       	ldi	r20, 0x01	; 1
      c6:	50 e0       	ldi	r21, 0x00	; 0
      c8:	0e 94 72 18 	call	0x30e4	; 0x30e4 <__eerd_block_m328p>
	ucCount++;
      cc:	69 81       	ldd	r22, Y+1	; 0x01
      ce:	6f 5f       	subi	r22, 0xFF	; 255
      d0:	69 83       	std	Y+1, r22	; 0x01
	eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
      d2:	80 e5       	ldi	r24, 0x50	; 80
      d4:	90 e0       	ldi	r25, 0x00	; 0
      d6:	0e 94 82 18 	call	0x3104	; 0x3104 <__eewr_byte_m328p>
short main( void )
{
	prvIncrementResetCount();

	/* Setup the LED's for output. */
	vParTestInitialise();
      da:	0e 94 94 02 	call	0x528	; 0x528 <vParTestInitialise>

	/* Create the standard demo tasks. */
	vStartIntegerMathTasks( tskIDLE_PRIORITY );
      de:	80 e0       	ldi	r24, 0x00	; 0
      e0:	0e 94 8a 14 	call	0x2914	; 0x2914 <vStartIntegerMathTasks>
	vAltStartComTestTasks( mainCOM_TEST_PRIORITY, mainCOM_TEST_BAUD_RATE, mainCOM_TEST_LED );
      e4:	82 e0       	ldi	r24, 0x02	; 2
      e6:	40 e0       	ldi	r20, 0x00	; 0
      e8:	56 e9       	ldi	r21, 0x96	; 150
      ea:	60 e0       	ldi	r22, 0x00	; 0
      ec:	70 e0       	ldi	r23, 0x00	; 0
      ee:	24 e0       	ldi	r18, 0x04	; 4
      f0:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <vAltStartComTestTasks>
	vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
      f4:	82 e0       	ldi	r24, 0x02	; 2
      f6:	0e 94 ab 14 	call	0x2956	; 0x2956 <vStartPolledQueueTasks>
	vStartRegTestTasks();
      fa:	0e 94 76 02 	call	0x4ec	; 0x4ec <vStartRegTestTasks>

	/* Create the tasks defined within this file. */
	xTaskCreate( vErrorChecks, "Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
      fe:	8a e9       	ldi	r24, 0x9A	; 154
     100:	90 e0       	ldi	r25, 0x00	; 0
     102:	60 e0       	ldi	r22, 0x00	; 0
     104:	71 e0       	ldi	r23, 0x01	; 1
     106:	45 e5       	ldi	r20, 0x55	; 85
     108:	50 e0       	ldi	r21, 0x00	; 0
     10a:	20 e0       	ldi	r18, 0x00	; 0
     10c:	30 e0       	ldi	r19, 0x00	; 0
     10e:	03 e0       	ldi	r16, 0x03	; 3
     110:	ee 24       	eor	r14, r14
     112:	ff 24       	eor	r15, r15
     114:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <xTaskCreate>

	/* Create the co-routines that flash the LED's. */
	vStartFlashCoRoutines( mainNUM_FLASH_COROUTINES );
     118:	83 e0       	ldi	r24, 0x03	; 3
     11a:	0e 94 5c 13 	call	0x26b8	; 0x26b8 <vStartFlashCoRoutines>

	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION
	as 1 in portmacro.h.  To use the cooperative scheduler define
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
     11e:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <vTaskStartScheduler>

	return 0;
}
     122:	80 e0       	ldi	r24, 0x00	; 0
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	0f 90       	pop	r0
     128:	cf 91       	pop	r28
     12a:	df 91       	pop	r29
     12c:	0f 91       	pop	r16
     12e:	ff 90       	pop	r15
     130:	ef 90       	pop	r14
     132:	08 95       	ret

00000134 <vErrorChecks>:
/*-----------------------------------------------------------*/

static void vErrorChecks( void *pvParameters )
{
     134:	1f 93       	push	r17
		// xErrorHasOccurred = pdTRUE;
	// }

	if( xAreComTestTasksStillRunning() != pdTRUE )
	{
		xErrorHasOccurred = pdTRUE;
     136:	11 e0       	ldi	r17, 0x01	; 1

	/* Cycle for ever, delaying then checking all the other tasks are still
	operating without error. */
	for( ;; )
	{
		vTaskDelay( mainCHECK_PERIOD );
     138:	84 ef       	ldi	r24, 0xF4	; 244
     13a:	91 e0       	ldi	r25, 0x01	; 1
     13c:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <vTaskDelay>

		/* Perform a bit of 32bit maths to ensure the registers used by the
		integer tasks get some exercise. The result here is not important -
		see the demo application documentation for more info. */
		ulDummyVariable *= 3;
     140:	20 91 1c 01 	lds	r18, 0x011C
     144:	30 91 1d 01 	lds	r19, 0x011D
     148:	40 91 1e 01 	lds	r20, 0x011E
     14c:	50 91 1f 01 	lds	r21, 0x011F
     150:	da 01       	movw	r26, r20
     152:	c9 01       	movw	r24, r18
     154:	88 0f       	add	r24, r24
     156:	99 1f       	adc	r25, r25
     158:	aa 1f       	adc	r26, r26
     15a:	bb 1f       	adc	r27, r27
     15c:	82 0f       	add	r24, r18
     15e:	93 1f       	adc	r25, r19
     160:	a4 1f       	adc	r26, r20
     162:	b5 1f       	adc	r27, r21
     164:	80 93 1c 01 	sts	0x011C, r24
     168:	90 93 1d 01 	sts	0x011D, r25
     16c:	a0 93 1e 01 	sts	0x011E, r26
     170:	b0 93 1f 01 	sts	0x011F, r27
	// if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
	// {
		// xErrorHasOccurred = pdTRUE;
	// }

	if( xAreComTestTasksStillRunning() != pdTRUE )
     174:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <xAreComTestTasksStillRunning>
     178:	81 30       	cpi	r24, 0x01	; 1
     17a:	11 f0       	breq	.+4      	; 0x180 <vErrorChecks+0x4c>
	{
		xErrorHasOccurred = pdTRUE;
     17c:	10 93 66 01 	sts	0x0166, r17
	// if( xAreRegTestTasksStillRunning() != pdTRUE )
	// {
		// xErrorHasOccurred = pdTRUE;
	// }

	if( xErrorHasOccurred == pdFALSE )
     180:	80 91 66 01 	lds	r24, 0x0166
     184:	88 23       	and	r24, r24
     186:	c1 f6       	brne	.-80     	; 0x138 <vErrorChecks+0x4>
	{
		/* Toggle the LED if everything is okay so we know if an error occurs even if not
		using console IO. */
		vParTestToggleLED( mainCHECK_TASK_LED );
     188:	85 e0       	ldi	r24, 0x05	; 5
     18a:	0e 94 9c 02 	call	0x538	; 0x538 <vParTestToggleLED>
     18e:	d4 cf       	rjmp	.-88     	; 0x138 <vErrorChecks+0x4>

00000190 <print>:

/*-----------------------------------------------------------*/

void print(char *str,uint16_t len);
void print(char *str,uint16_t len)
{
     190:	ef 92       	push	r14
     192:	ff 92       	push	r15
     194:	0f 93       	push	r16
     196:	1f 93       	push	r17
     198:	cf 93       	push	r28
     19a:	df 93       	push	r29
     19c:	7c 01       	movw	r14, r24
     19e:	8b 01       	movw	r16, r22
     1a0:	c0 e0       	ldi	r28, 0x00	; 0
     1a2:	d0 e0       	ldi	r29, 0x00	; 0
     1a4:	0b c0       	rjmp	.+22     	; 0x1bc <print+0x2c>
	uint16_t i;
	for(i=0;i<len;i++)
		xSerialPutChar( 0, str[i], 0 );
     1a6:	f7 01       	movw	r30, r14
     1a8:	ec 0f       	add	r30, r28
     1aa:	fd 1f       	adc	r31, r29
     1ac:	80 e0       	ldi	r24, 0x00	; 0
     1ae:	90 e0       	ldi	r25, 0x00	; 0
     1b0:	60 81       	ld	r22, Z
     1b2:	40 e0       	ldi	r20, 0x00	; 0
     1b4:	50 e0       	ldi	r21, 0x00	; 0
     1b6:	0e 94 74 03 	call	0x6e8	; 0x6e8 <xSerialPutChar>

void print(char *str,uint16_t len);
void print(char *str,uint16_t len)
{
	uint16_t i;
	for(i=0;i<len;i++)
     1ba:	21 96       	adiw	r28, 0x01	; 1
     1bc:	c0 17       	cp	r28, r16
     1be:	d1 07       	cpc	r29, r17
     1c0:	90 f3       	brcs	.-28     	; 0x1a6 <print+0x16>
		xSerialPutChar( 0, str[i], 0 );
}
     1c2:	df 91       	pop	r29
     1c4:	cf 91       	pop	r28
     1c6:	1f 91       	pop	r17
     1c8:	0f 91       	pop	r16
     1ca:	ff 90       	pop	r15
     1cc:	ef 90       	pop	r14
     1ce:	08 95       	ret

000001d0 <DisplayTemp>:

void DisplayTemp(void *pvParameters);
void DisplayTemp(void *pvParameters)  // This is a task.
{
     1d0:	0f 93       	push	r16
     1d2:	1f 93       	push	r17
     1d4:	cf 93       	push	r28
     1d6:	df 93       	push	r29
	static int res;
	static char MsgBuff[32];
	(void) pvParameters;

	ADC_0_init();
     1d8:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <ADC_0_init>
	xSerialPortInitMinimal( mainCOM_TEST_BAUD_RATE, 100 );
     1dc:	60 e0       	ldi	r22, 0x00	; 0
     1de:	76 e9       	ldi	r23, 0x96	; 150
     1e0:	80 e0       	ldi	r24, 0x00	; 0
     1e2:	90 e0       	ldi	r25, 0x00	; 0
     1e4:	44 e6       	ldi	r20, 0x64	; 100
     1e6:	0e 94 9c 03 	call	0x738	; 0x738 <xSerialPortInitMinimal>
	for(;;)
	{
		vTaskDelay(500);              // wait for a second
		res = ADC_0_get_conversion(0);
		sprintf(MsgBuff,"Temperature = %d *C\r\n",res);
     1ea:	c7 e6       	ldi	r28, 0x67	; 103
     1ec:	d1 e0       	ldi	r29, 0x01	; 1
     1ee:	06 e0       	ldi	r16, 0x06	; 6
     1f0:	11 e0       	ldi	r17, 0x01	; 1

	ADC_0_init();
	xSerialPortInitMinimal( mainCOM_TEST_BAUD_RATE, 100 );
	for(;;)
	{
		vTaskDelay(500);              // wait for a second
     1f2:	84 ef       	ldi	r24, 0xF4	; 244
     1f4:	91 e0       	ldi	r25, 0x01	; 1
     1f6:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <vTaskDelay>
		res = ADC_0_get_conversion(0);
     1fa:	80 e0       	ldi	r24, 0x00	; 0
     1fc:	0e 94 23 04 	call	0x846	; 0x846 <ADC_0_get_conversion>
     200:	80 93 87 01 	sts	0x0187, r24
     204:	90 93 88 01 	sts	0x0188, r25
		sprintf(MsgBuff,"Temperature = %d *C\r\n",res);
     208:	00 d0       	rcall	.+0      	; 0x20a <DisplayTemp+0x3a>
     20a:	00 d0       	rcall	.+0      	; 0x20c <DisplayTemp+0x3c>
     20c:	00 d0       	rcall	.+0      	; 0x20e <DisplayTemp+0x3e>
     20e:	ed b7       	in	r30, 0x3d	; 61
     210:	fe b7       	in	r31, 0x3e	; 62
     212:	31 96       	adiw	r30, 0x01	; 1
     214:	ad b7       	in	r26, 0x3d	; 61
     216:	be b7       	in	r27, 0x3e	; 62
     218:	12 96       	adiw	r26, 0x02	; 2
     21a:	dc 93       	st	X, r29
     21c:	ce 93       	st	-X, r28
     21e:	11 97       	sbiw	r26, 0x01	; 1
     220:	13 83       	std	Z+3, r17	; 0x03
     222:	02 83       	std	Z+2, r16	; 0x02
     224:	84 83       	std	Z+4, r24	; 0x04
     226:	95 83       	std	Z+5, r25	; 0x05
     228:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <sprintf>
		print(MsgBuff,strlen(MsgBuff));
     22c:	fe 01       	movw	r30, r28
     22e:	01 90       	ld	r0, Z+
     230:	00 20       	and	r0, r0
     232:	e9 f7       	brne	.-6      	; 0x22e <DisplayTemp+0x5e>
     234:	31 97       	sbiw	r30, 0x01	; 1
     236:	e7 56       	subi	r30, 0x67	; 103
     238:	f1 40       	sbci	r31, 0x01	; 1
     23a:	8d b7       	in	r24, 0x3d	; 61
     23c:	9e b7       	in	r25, 0x3e	; 62
     23e:	06 96       	adiw	r24, 0x06	; 6
     240:	0f b6       	in	r0, 0x3f	; 63
     242:	f8 94       	cli
     244:	9e bf       	out	0x3e, r25	; 62
     246:	0f be       	out	0x3f, r0	; 63
     248:	8d bf       	out	0x3d, r24	; 61
     24a:	ce 01       	movw	r24, r28
     24c:	bf 01       	movw	r22, r30
     24e:	0e 94 c8 00 	call	0x190	; 0x190 <print>
     252:	cf cf       	rjmp	.-98     	; 0x1f2 <DisplayTemp+0x22>

00000254 <xAreRegTestTasksStillRunning>:
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
}
/*-----------------------------------------------------------*/

portBASE_TYPE xAreRegTestTasksStillRunning( void )
{
     254:	90 e0       	ldi	r25, 0x00	; 0
     256:	80 91 89 01 	lds	r24, 0x0189
     25a:	88 23       	and	r24, r24
     25c:	09 f4       	brne	.+2      	; 0x260 <xAreRegTestTasksStillRunning+0xc>
     25e:	91 e0       	ldi	r25, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     260:	89 2f       	mov	r24, r25
     262:	08 95       	ret

00000264 <prvRegisterCheck1>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);
     264:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
     266:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
     268:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
     26a:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
     26c:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
     26e:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
     270:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
     272:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
     274:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
     276:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
     278:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
     27a:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
     27c:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
     27e:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
     280:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
     282:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
     284:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
     286:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
     288:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
     28a:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
     28c:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
     28e:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
     290:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
     292:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
     294:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
     296:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
     298:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
     29a:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
     29c:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
     29e:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
     2a0:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
     2a2:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
     2a4:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
     2a6:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
     2a8:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
     2aa:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
     2ac:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
     2ae:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
     2b0:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
     2b2:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
     2b4:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
     2b6:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
     2b8:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
     2ba:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
     2bc:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
     2be:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
     2c0:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     2c2:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	6"			);
     2c6:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
     2c8:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     2ca:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	7"			);
     2ce:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
     2d0:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     2d2:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	8"			);
     2d6:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
     2d8:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     2da:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	9"			);
     2de:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
     2e0:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     2e2:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	10"			);
     2e6:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
     2e8:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     2ea:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	11"			);
     2ee:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
     2f0:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     2f2:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	12"			);
     2f6:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
     2f8:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     2fa:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	13"			);
     2fe:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
     300:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     302:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	14"			);
     306:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
     308:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     30a:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	15"			);
     30e:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
     310:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     312:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	16"			);
     316:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
     318:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     31a:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	17"			);
     31e:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
     320:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     322:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	18"			);
     326:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
     328:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     32a:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	19"			);
     32e:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
     330:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     332:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	20"			);
     336:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
     338:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     33a:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	21"			);
     33e:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
     340:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     342:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	22"			);
     346:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
     348:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     34a:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	23"			);
     34e:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
     350:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     352:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	24"			);
     356:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
     358:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     35a:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	25"			);
     35e:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
     360:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     362:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	26"			);
     366:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
     368:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     36a:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	27"			);
     36e:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
     370:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     372:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	28"			);
     376:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
     378:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     37a:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	29"			);
     37e:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
     380:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     382:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	30"			);
     386:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
     388:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     38a:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	31"			);
     38e:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
     390:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     392:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	32"			);
     396:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
     398:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     39a:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	33"			);
     39e:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
     3a0:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     3a2:	00 92 89 01 	sts	0x0189, r0
     3a6:	5e cf       	rjmp	.-324    	; 0x264 <prvRegisterCheck1>

000003a8 <prvRegisterCheck2>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);
     3a8:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
     3aa:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
     3ac:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
     3ae:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
     3b0:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
     3b2:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
     3b4:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
     3b6:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
     3b8:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
     3ba:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
     3bc:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
     3be:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
     3c0:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
     3c2:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
     3c4:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
     3c6:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
     3c8:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
     3ca:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
     3cc:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
     3ce:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
     3d0:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
     3d2:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
     3d4:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
     3d6:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
     3d8:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
     3da:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
     3dc:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
     3de:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
     3e0:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
     3e2:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
     3e4:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
     3e6:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
     3e8:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
     3ea:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
     3ec:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
     3ee:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
     3f0:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
     3f2:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
     3f4:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
     3f6:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
     3f8:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
     3fa:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
     3fc:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
     3fe:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
     400:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
     402:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
     404:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     406:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	2"			);
     40a:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
     40c:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     40e:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	3"			);
     412:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
     414:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     416:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	4"			);
     41a:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
     41c:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     41e:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	5"			);
     422:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
     424:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     426:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	6"			);
     42a:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
     42c:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     42e:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	7"			);
     432:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
     434:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     436:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	8"			);
     43a:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
     43c:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     43e:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	9"			);
     442:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
     444:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     446:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	10"			);
     44a:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
     44c:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     44e:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	11"			);
     452:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
     454:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     456:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	12"			);
     45a:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
     45c:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     45e:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	13"			);
     462:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
     464:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     466:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	14"			);
     46a:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
     46c:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     46e:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	15"			);
     472:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
     474:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     476:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	16"			);
     47a:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
     47c:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     47e:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	17"			);
     482:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
     484:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     486:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	18"			);
     48a:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
     48c:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     48e:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	19"			);
     492:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
     494:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     496:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	20"			);
     49a:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
     49c:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     49e:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	21"			);
     4a2:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
     4a4:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     4a6:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	22"			);
     4aa:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
     4ac:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     4ae:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	23"			);
     4b2:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
     4b4:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     4b6:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	24"			);
     4ba:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
     4bc:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     4be:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	25"			);
     4c2:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
     4c4:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     4c6:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	26"			);
     4ca:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
     4cc:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     4ce:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	27"			);
     4d2:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
     4d4:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     4d6:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	28"			);
     4da:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
     4dc:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     4de:	00 92 89 01 	sts	0x0189, r0
		asm(	"LDI	r31,	29"			);
     4e2:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
     4e4:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     4e6:	00 92 89 01 	sts	0x0189, r0
     4ea:	5e cf       	rjmp	.-324    	; 0x3a8 <prvRegisterCheck2>

000004ec <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
     4ec:	ef 92       	push	r14
     4ee:	ff 92       	push	r15
     4f0:	0f 93       	push	r16
	xTaskCreate( prvRegisterCheck1, "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     4f2:	82 e3       	ldi	r24, 0x32	; 50
     4f4:	91 e0       	ldi	r25, 0x01	; 1
     4f6:	60 e2       	ldi	r22, 0x20	; 32
     4f8:	71 e0       	ldi	r23, 0x01	; 1
     4fa:	45 e5       	ldi	r20, 0x55	; 85
     4fc:	50 e0       	ldi	r21, 0x00	; 0
     4fe:	20 e0       	ldi	r18, 0x00	; 0
     500:	30 e0       	ldi	r19, 0x00	; 0
     502:	00 e0       	ldi	r16, 0x00	; 0
     504:	ee 24       	eor	r14, r14
     506:	ff 24       	eor	r15, r15
     508:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <xTaskCreate>
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     50c:	84 ed       	ldi	r24, 0xD4	; 212
     50e:	91 e0       	ldi	r25, 0x01	; 1
     510:	65 e2       	ldi	r22, 0x25	; 37
     512:	71 e0       	ldi	r23, 0x01	; 1
     514:	45 e5       	ldi	r20, 0x55	; 85
     516:	50 e0       	ldi	r21, 0x00	; 0
     518:	20 e0       	ldi	r18, 0x00	; 0
     51a:	30 e0       	ldi	r19, 0x00	; 0
     51c:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <xTaskCreate>
}
     520:	0f 91       	pop	r16
     522:	ff 90       	pop	r15
     524:	ef 90       	pop	r14
     526:	08 95       	ret

00000528 <vParTestInitialise>:

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
     528:	8f ef       	ldi	r24, 0xFF	; 255
     52a:	80 93 2a 01 	sts	0x012A, r24

	/* Set port B direction to outputs.  Start with all output off. */
	DDRB = partstALL_BITS_OUTPUT;
     52e:	84 b9       	out	0x04, r24	; 4
	PORTB = ucCurrentOutputValue;
     530:	80 91 2a 01 	lds	r24, 0x012A
     534:	85 b9       	out	0x05, r24	; 5
}
     536:	08 95       	ret

00000538 <vParTestToggleLED>:
	}
}
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     538:	1f 93       	push	r17
     53a:	28 2f       	mov	r18, r24
unsigned char ucBit;

	if( uxLED <= partstMAX_OUTPUT_LED )
     53c:	88 30       	cpi	r24, 0x08	; 8
     53e:	e8 f4       	brcc	.+58     	; 0x57a <vParTestToggleLED+0x42>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
     540:	81 e0       	ldi	r24, 0x01	; 1
     542:	90 e0       	ldi	r25, 0x00	; 0
     544:	02 c0       	rjmp	.+4      	; 0x54a <vParTestToggleLED+0x12>
     546:	88 0f       	add	r24, r24
     548:	99 1f       	adc	r25, r25
     54a:	2a 95       	dec	r18
     54c:	e2 f7       	brpl	.-8      	; 0x546 <vParTestToggleLED+0xe>
     54e:	18 2f       	mov	r17, r24

		vTaskSuspendAll();
     550:	0e 94 55 04 	call	0x8aa	; 0x8aa <vTaskSuspendAll>
		{
			if( ucCurrentOutputValue & ucBit )
     554:	80 91 2a 01 	lds	r24, 0x012A
     558:	81 23       	and	r24, r17
     55a:	29 f0       	breq	.+10     	; 0x566 <vParTestToggleLED+0x2e>
			{
				ucCurrentOutputValue &= ~ucBit;
     55c:	80 91 2a 01 	lds	r24, 0x012A
     560:	10 95       	com	r17
     562:	18 23       	and	r17, r24
     564:	03 c0       	rjmp	.+6      	; 0x56c <vParTestToggleLED+0x34>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     566:	80 91 2a 01 	lds	r24, 0x012A
     56a:	18 2b       	or	r17, r24
     56c:	10 93 2a 01 	sts	0x012A, r17
			}

			PORTB = ucCurrentOutputValue;
     570:	80 91 2a 01 	lds	r24, 0x012A
     574:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();			
     576:	0e 94 97 07 	call	0xf2e	; 0xf2e <xTaskResumeAll>
	}
}
     57a:	1f 91       	pop	r17
     57c:	08 95       	ret

0000057e <vParTestSetLED>:
	PORTB = ucCurrentOutputValue;
}
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     57e:	0f 93       	push	r16
     580:	1f 93       	push	r17
     582:	28 2f       	mov	r18, r24
     584:	06 2f       	mov	r16, r22
unsigned char ucBit = ( unsigned char ) 1;

	if( uxLED <= partstMAX_OUTPUT_LED )
     586:	88 30       	cpi	r24, 0x08	; 8
     588:	d8 f4       	brcc	.+54     	; 0x5c0 <vParTestSetLED+0x42>
	{
		ucBit <<= uxLED;	
     58a:	81 e0       	ldi	r24, 0x01	; 1
     58c:	90 e0       	ldi	r25, 0x00	; 0
     58e:	02 c0       	rjmp	.+4      	; 0x594 <vParTestSetLED+0x16>
     590:	88 0f       	add	r24, r24
     592:	99 1f       	adc	r25, r25
     594:	2a 95       	dec	r18
     596:	e2 f7       	brpl	.-8      	; 0x590 <vParTestSetLED+0x12>
     598:	18 2f       	mov	r17, r24

		vTaskSuspendAll();
     59a:	0e 94 55 04 	call	0x8aa	; 0x8aa <vTaskSuspendAll>
		{
			if( xValue == pdTRUE )
     59e:	01 30       	cpi	r16, 0x01	; 1
     5a0:	29 f4       	brne	.+10     	; 0x5ac <vParTestSetLED+0x2e>
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     5a2:	80 91 2a 01 	lds	r24, 0x012A
     5a6:	10 95       	com	r17
     5a8:	18 23       	and	r17, r24
     5aa:	03 c0       	rjmp	.+6      	; 0x5b2 <vParTestSetLED+0x34>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     5ac:	80 91 2a 01 	lds	r24, 0x012A
     5b0:	18 2b       	or	r17, r24
     5b2:	10 93 2a 01 	sts	0x012A, r17
			}

			PORTB = ucCurrentOutputValue;
     5b6:	80 91 2a 01 	lds	r24, 0x012A
     5ba:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();
     5bc:	0e 94 97 07 	call	0xf2e	; 0xf2e <xTaskResumeAll>
	}
}
     5c0:	1f 91       	pop	r17
     5c2:	0f 91       	pop	r16
     5c4:	08 95       	ret

000005c6 <vSerialClose>:
	( void ) xPort;

	/* Turn off the interrupts.  We may also want to delete the queues and/or
	re-install the original ISR. */

	portENTER_CRITICAL();
     5c6:	0f b6       	in	r0, 0x3f	; 63
     5c8:	f8 94       	cli
     5ca:	0f 92       	push	r0
	{
		vInterruptOff();
     5cc:	e1 ec       	ldi	r30, 0xC1	; 193
     5ce:	f0 e0       	ldi	r31, 0x00	; 0
     5d0:	80 81       	ld	r24, Z
     5d2:	8f 7d       	andi	r24, 0xDF	; 223
     5d4:	80 83       	st	Z, r24
		ucByte = UCSR0B;
     5d6:	80 81       	ld	r24, Z
		ucByte &= ~serRX_INT_ENABLE;
     5d8:	8f 77       	andi	r24, 0x7F	; 127
		UCSR0B = ucByte;
     5da:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     5dc:	0f 90       	pop	r0
     5de:	0f be       	out	0x3f, r0	; 63
}
     5e0:	08 95       	ret

000005e2 <__vector_19>:
	}
}
/*-----------------------------------------------------------*/

SIGNAL( USART_UDRE_vect )
{
     5e2:	1f 92       	push	r1
     5e4:	0f 92       	push	r0
     5e6:	0f b6       	in	r0, 0x3f	; 63
     5e8:	0f 92       	push	r0
     5ea:	11 24       	eor	r1, r1
     5ec:	2f 93       	push	r18
     5ee:	3f 93       	push	r19
     5f0:	4f 93       	push	r20
     5f2:	5f 93       	push	r21
     5f4:	6f 93       	push	r22
     5f6:	7f 93       	push	r23
     5f8:	8f 93       	push	r24
     5fa:	9f 93       	push	r25
     5fc:	af 93       	push	r26
     5fe:	bf 93       	push	r27
     600:	ef 93       	push	r30
     602:	ff 93       	push	r31
     604:	df 93       	push	r29
     606:	cf 93       	push	r28
     608:	00 d0       	rcall	.+0      	; 0x60a <__vector_19+0x28>
     60a:	cd b7       	in	r28, 0x3d	; 61
     60c:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     60e:	80 91 8c 01 	lds	r24, 0x018C
     612:	90 91 8d 01 	lds	r25, 0x018D
     616:	be 01       	movw	r22, r28
     618:	6f 5f       	subi	r22, 0xFF	; 255
     61a:	7f 4f       	sbci	r23, 0xFF	; 255
     61c:	ae 01       	movw	r20, r28
     61e:	4e 5f       	subi	r20, 0xFE	; 254
     620:	5f 4f       	sbci	r21, 0xFF	; 255
     622:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <xQueueReceiveFromISR>
     626:	81 30       	cpi	r24, 0x01	; 1
     628:	21 f4       	brne	.+8      	; 0x632 <__vector_19+0x50>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
     62a:	89 81       	ldd	r24, Y+1	; 0x01
     62c:	80 93 c6 00 	sts	0x00C6, r24
     630:	05 c0       	rjmp	.+10     	; 0x63c <__vector_19+0x5a>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
     632:	80 91 c1 00 	lds	r24, 0x00C1
     636:	8f 7d       	andi	r24, 0xDF	; 223
     638:	80 93 c1 00 	sts	0x00C1, r24
	}
}
     63c:	0f 90       	pop	r0
     63e:	0f 90       	pop	r0
     640:	cf 91       	pop	r28
     642:	df 91       	pop	r29
     644:	ff 91       	pop	r31
     646:	ef 91       	pop	r30
     648:	bf 91       	pop	r27
     64a:	af 91       	pop	r26
     64c:	9f 91       	pop	r25
     64e:	8f 91       	pop	r24
     650:	7f 91       	pop	r23
     652:	6f 91       	pop	r22
     654:	5f 91       	pop	r21
     656:	4f 91       	pop	r20
     658:	3f 91       	pop	r19
     65a:	2f 91       	pop	r18
     65c:	0f 90       	pop	r0
     65e:	0f be       	out	0x3f, r0	; 63
     660:	0f 90       	pop	r0
     662:	1f 90       	pop	r1
     664:	18 95       	reti

00000666 <__vector_18>:
	portEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

SIGNAL( USART_RX_vect )
{
     666:	1f 92       	push	r1
     668:	0f 92       	push	r0
     66a:	0f b6       	in	r0, 0x3f	; 63
     66c:	0f 92       	push	r0
     66e:	11 24       	eor	r1, r1
     670:	2f 93       	push	r18
     672:	3f 93       	push	r19
     674:	4f 93       	push	r20
     676:	5f 93       	push	r21
     678:	6f 93       	push	r22
     67a:	7f 93       	push	r23
     67c:	8f 93       	push	r24
     67e:	9f 93       	push	r25
     680:	af 93       	push	r26
     682:	bf 93       	push	r27
     684:	ef 93       	push	r30
     686:	ff 93       	push	r31
     688:	df 93       	push	r29
     68a:	cf 93       	push	r28
     68c:	00 d0       	rcall	.+0      	; 0x68e <__vector_18+0x28>
     68e:	cd b7       	in	r28, 0x3d	; 61
     690:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     692:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
     694:	80 91 c6 00 	lds	r24, 0x00C6
     698:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     69a:	80 91 8a 01 	lds	r24, 0x018A
     69e:	90 91 8b 01 	lds	r25, 0x018B
     6a2:	be 01       	movw	r22, r28
     6a4:	6f 5f       	subi	r22, 0xFF	; 255
     6a6:	7f 4f       	sbci	r23, 0xFF	; 255
     6a8:	ae 01       	movw	r20, r28
     6aa:	4e 5f       	subi	r20, 0xFE	; 254
     6ac:	5f 4f       	sbci	r21, 0xFF	; 255
     6ae:	20 e0       	ldi	r18, 0x00	; 0
     6b0:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
     6b4:	8a 81       	ldd	r24, Y+2	; 0x02
     6b6:	88 23       	and	r24, r24
     6b8:	11 f0       	breq	.+4      	; 0x6be <__vector_18+0x58>
	{
		taskYIELD();
     6ba:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
	}
}
     6be:	0f 90       	pop	r0
     6c0:	0f 90       	pop	r0
     6c2:	cf 91       	pop	r28
     6c4:	df 91       	pop	r29
     6c6:	ff 91       	pop	r31
     6c8:	ef 91       	pop	r30
     6ca:	bf 91       	pop	r27
     6cc:	af 91       	pop	r26
     6ce:	9f 91       	pop	r25
     6d0:	8f 91       	pop	r24
     6d2:	7f 91       	pop	r23
     6d4:	6f 91       	pop	r22
     6d6:	5f 91       	pop	r21
     6d8:	4f 91       	pop	r20
     6da:	3f 91       	pop	r19
     6dc:	2f 91       	pop	r18
     6de:	0f 90       	pop	r0
     6e0:	0f be       	out	0x3f, r0	; 63
     6e2:	0f 90       	pop	r0
     6e4:	1f 90       	pop	r1
     6e6:	18 95       	reti

000006e8 <xSerialPutChar>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
{
     6e8:	df 93       	push	r29
     6ea:	cf 93       	push	r28
     6ec:	0f 92       	push	r0
     6ee:	cd b7       	in	r28, 0x3d	; 61
     6f0:	de b7       	in	r29, 0x3e	; 62
     6f2:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     6f4:	80 91 8c 01 	lds	r24, 0x018C
     6f8:	90 91 8d 01 	lds	r25, 0x018D
     6fc:	be 01       	movw	r22, r28
     6fe:	6f 5f       	subi	r22, 0xFF	; 255
     700:	7f 4f       	sbci	r23, 0xFF	; 255
     702:	20 e0       	ldi	r18, 0x00	; 0
     704:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <xQueueGenericSend>
     708:	81 30       	cpi	r24, 0x01	; 1
     70a:	11 f0       	breq	.+4      	; 0x710 <xSerialPutChar+0x28>
     70c:	80 e0       	ldi	r24, 0x00	; 0
     70e:	06 c0       	rjmp	.+12     	; 0x71c <xSerialPutChar+0x34>
	{
		return pdFAIL;
	}

	vInterruptOn();
     710:	80 91 c1 00 	lds	r24, 0x00C1
     714:	80 62       	ori	r24, 0x20	; 32
     716:	80 93 c1 00 	sts	0x00C1, r24
     71a:	81 e0       	ldi	r24, 0x01	; 1

	return pdPASS;
}
     71c:	0f 90       	pop	r0
     71e:	cf 91       	pop	r28
     720:	df 91       	pop	r29
     722:	08 95       	ret

00000724 <xSerialGetChar>:
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
     724:	80 91 8a 01 	lds	r24, 0x018A
     728:	90 91 8b 01 	lds	r25, 0x018B
     72c:	20 e0       	ldi	r18, 0x00	; 0
     72e:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <xQueueGenericReceive>
     732:	81 11       	cpse	r24, r1
     734:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return pdFALSE;
	}
}
     736:	08 95       	ret

00000738 <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
     738:	df 92       	push	r13
     73a:	ef 92       	push	r14
     73c:	ff 92       	push	r15
     73e:	0f 93       	push	r16
     740:	1f 93       	push	r17
     742:	7b 01       	movw	r14, r22
     744:	8c 01       	movw	r16, r24
     746:	d4 2e       	mov	r13, r20
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
     748:	0f b6       	in	r0, 0x3f	; 63
     74a:	f8 94       	cli
     74c:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     74e:	84 2f       	mov	r24, r20
     750:	61 e0       	ldi	r22, 0x01	; 1
     752:	40 e0       	ldi	r20, 0x00	; 0
     754:	0e 94 65 0f 	call	0x1eca	; 0x1eca <xQueueGenericCreate>
     758:	90 93 8b 01 	sts	0x018B, r25
     75c:	80 93 8a 01 	sts	0x018A, r24
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     760:	8d 2d       	mov	r24, r13
     762:	61 e0       	ldi	r22, 0x01	; 1
     764:	40 e0       	ldi	r20, 0x00	; 0
     766:	0e 94 65 0f 	call	0x1eca	; 0x1eca <xQueueGenericCreate>
     76a:	90 93 8d 01 	sts	0x018D, r25
     76e:	80 93 8c 01 	sts	0x018C, r24

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
     772:	94 e0       	ldi	r25, 0x04	; 4
     774:	ee 0c       	add	r14, r14
     776:	ff 1c       	adc	r15, r15
     778:	00 1f       	adc	r16, r16
     77a:	11 1f       	adc	r17, r17
     77c:	9a 95       	dec	r25
     77e:	d1 f7       	brne	.-12     	; 0x774 <xSerialPortInitMinimal+0x3c>
     780:	60 e0       	ldi	r22, 0x00	; 0
     782:	74 e2       	ldi	r23, 0x24	; 36
     784:	84 ef       	ldi	r24, 0xF4	; 244
     786:	90 e0       	ldi	r25, 0x00	; 0
     788:	a8 01       	movw	r20, r16
     78a:	97 01       	movw	r18, r14
     78c:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <__udivmodsi4>
     790:	21 50       	subi	r18, 0x01	; 1
     792:	30 40       	sbci	r19, 0x00	; 0
     794:	40 40       	sbci	r20, 0x00	; 0
     796:	50 40       	sbci	r21, 0x00	; 0

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR0L = ucByte;
     798:	20 93 c4 00 	sts	0x00C4, r18

		ulBaudRateCounter >>= ( unsigned long ) 8;
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
     79c:	23 2f       	mov	r18, r19
     79e:	34 2f       	mov	r19, r20
     7a0:	45 2f       	mov	r20, r21
     7a2:	55 27       	eor	r21, r21
		UBRR0H = ucByte;
     7a4:	20 93 c5 00 	sts	0x00C5, r18

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
     7a8:	88 e9       	ldi	r24, 0x98	; 152
     7aa:	80 93 c1 00 	sts	0x00C1, r24

		/* Set the data bits to 8. */
		UCSR0C = serEIGHT_DATA_BITS ;
     7ae:	86 e0       	ldi	r24, 0x06	; 6
     7b0:	80 93 c2 00 	sts	0x00C2, r24
	}
	portEXIT_CRITICAL();
     7b4:	0f 90       	pop	r0
     7b6:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
     7b8:	80 e0       	ldi	r24, 0x00	; 0
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	1f 91       	pop	r17
     7be:	0f 91       	pop	r16
     7c0:	ff 90       	pop	r15
     7c2:	ef 90       	pop	r14
     7c4:	df 90       	pop	r13
     7c6:	08 95       	ret

000007c8 <ADC_0_init>:
 */
int8_t ADC_0_init()
{

	/* Enable clock to write ADC registers */
	PRR &= ~(1 << PRADC);
     7c8:	e4 e6       	ldi	r30, 0x64	; 100
     7ca:	f0 e0       	ldi	r31, 0x00	; 0
     7cc:	80 81       	ld	r24, Z
     7ce:	8e 7f       	andi	r24, 0xFE	; 254
     7d0:	80 83       	st	Z, r24

	ADMUX = (0x00 << REFS0) /* AREF, Internal Vref turned off */
     7d2:	10 92 7c 00 	sts	0x007C, r1
	        | (0 << ADLAR)  /* Left Adjust Result: disabled */
	        | (0x00 << MUX0) /* ADC Single Ended Input pin 0 */;

	ADCSRA = (1 << ADEN)    /* ADC: enabled */
     7d6:	81 e8       	ldi	r24, 0x81	; 129
     7d8:	80 93 7a 00 	sts	0x007A, r24
	         | (0 << ADATE) /* Auto Trigger: disabled */
	         | (0 << ADIE)  /* ADC Interrupt: disabled */
	         | (0x01 << ADPS0) /* 2 */;

	ADCSRB = (0x00 << ADTS0) /* Free Running mode */
     7dc:	10 92 7b 00 	sts	0x007B, r1
	         | (0 << ACME) /* Analog Comparator Multiplexer: disabled */;

	DIDR0 = (0 << ADC0D)   /* Digital Input: enabled */
     7e0:	10 92 7e 00 	sts	0x007E, r1
	        | (0 << ADC3D) /* Digital Input: enabled */
	        | (0 << ADC4D) /* Digital Input: enabled */
	        | (0 << ADC5D) /* Digital Input: enabled */;

	return 0;
}
     7e4:	80 e0       	ldi	r24, 0x00	; 0
     7e6:	08 95       	ret

000007e8 <ADC_0_enable>:

void ADC_0_enable()
{
	ADCSRA |= (1 << ADEN);
     7e8:	ea e7       	ldi	r30, 0x7A	; 122
     7ea:	f0 e0       	ldi	r31, 0x00	; 0
     7ec:	80 81       	ld	r24, Z
     7ee:	80 68       	ori	r24, 0x80	; 128
     7f0:	80 83       	st	Z, r24
}
     7f2:	08 95       	ret

000007f4 <ADC_0_disable>:

void ADC_0_disable()
{
	ADCSRA &= ~(1 << ADEN);
     7f4:	ea e7       	ldi	r30, 0x7A	; 122
     7f6:	f0 e0       	ldi	r31, 0x00	; 0
     7f8:	80 81       	ld	r24, Z
     7fa:	8f 77       	andi	r24, 0x7F	; 127
     7fc:	80 83       	st	Z, r24
}
     7fe:	08 95       	ret

00000800 <ADC_0_start_conversion>:

void ADC_0_start_conversion(adc_0_channel_t channel)
{
	ADMUX &= ~0x0f;
     800:	ec e7       	ldi	r30, 0x7C	; 124
     802:	f0 e0       	ldi	r31, 0x00	; 0
     804:	90 81       	ld	r25, Z
     806:	90 7f       	andi	r25, 0xF0	; 240
     808:	90 83       	st	Z, r25
	ADMUX |= channel;
     80a:	90 81       	ld	r25, Z
     80c:	98 2b       	or	r25, r24
     80e:	90 83       	st	Z, r25
	ADCSRA |= (1 << ADSC);
     810:	ea e7       	ldi	r30, 0x7A	; 122
     812:	f0 e0       	ldi	r31, 0x00	; 0
     814:	80 81       	ld	r24, Z
     816:	80 64       	ori	r24, 0x40	; 64
     818:	80 83       	st	Z, r24
}
     81a:	08 95       	ret

0000081c <ADC_0_is_conversion_done>:

bool ADC_0_is_conversion_done()
{
	return ((ADCSRA & (1 << ADIF)));
     81c:	80 91 7a 00 	lds	r24, 0x007A
     820:	90 e0       	ldi	r25, 0x00	; 0
     822:	24 e0       	ldi	r18, 0x04	; 4
     824:	96 95       	lsr	r25
     826:	87 95       	ror	r24
     828:	2a 95       	dec	r18
     82a:	e1 f7       	brne	.-8      	; 0x824 <ADC_0_is_conversion_done+0x8>
}
     82c:	81 70       	andi	r24, 0x01	; 1
     82e:	08 95       	ret

00000830 <ADC_0_get_conversion_result>:

adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADCL | ADCH << 8);
     830:	20 91 78 00 	lds	r18, 0x0078
     834:	40 91 79 00 	lds	r20, 0x0079
     838:	94 2f       	mov	r25, r20
     83a:	80 e0       	ldi	r24, 0x00	; 0
     83c:	30 e0       	ldi	r19, 0x00	; 0
     83e:	28 2b       	or	r18, r24
     840:	39 2b       	or	r19, r25
}
     842:	c9 01       	movw	r24, r18
     844:	08 95       	ret

00000846 <ADC_0_get_conversion>:
	ADCSRA &= ~(1 << ADEN);
}

void ADC_0_start_conversion(adc_0_channel_t channel)
{
	ADMUX &= ~0x0f;
     846:	90 91 7c 00 	lds	r25, 0x007C
     84a:	90 7f       	andi	r25, 0xF0	; 240
     84c:	90 93 7c 00 	sts	0x007C, r25
	ADMUX |= channel;
     850:	90 91 7c 00 	lds	r25, 0x007C
     854:	98 2b       	or	r25, r24
     856:	90 93 7c 00 	sts	0x007C, r25
	ADCSRA |= (1 << ADSC);
     85a:	80 91 7a 00 	lds	r24, 0x007A
     85e:	80 64       	ori	r24, 0x40	; 64
     860:	80 93 7a 00 	sts	0x007A, r24
}

bool ADC_0_is_conversion_done()
{
	return ((ADCSRA & (1 << ADIF)));
     864:	80 91 7a 00 	lds	r24, 0x007A
adc_result_t ADC_0_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     868:	84 ff       	sbrs	r24, 4
     86a:	fc cf       	rjmp	.-8      	; 0x864 <ADC_0_get_conversion+0x1e>
	return ((ADCSRA & (1 << ADIF)));
}

adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADCL | ADCH << 8);
     86c:	20 91 78 00 	lds	r18, 0x0078
     870:	40 91 79 00 	lds	r20, 0x0079

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADCSRA |= (1 << ADIF);
     874:	80 91 7a 00 	lds	r24, 0x007A
     878:	80 61       	ori	r24, 0x10	; 16
     87a:	80 93 7a 00 	sts	0x007A, r24
     87e:	94 2f       	mov	r25, r20
     880:	80 e0       	ldi	r24, 0x00	; 0
     882:	30 e0       	ldi	r19, 0x00	; 0
     884:	28 2b       	or	r18, r24
     886:	39 2b       	or	r19, r25
	return res;
}
     888:	c9 01       	movw	r24, r18
     88a:	08 95       	ret

0000088c <ADC_0_get_resolution>:

uint8_t ADC_0_get_resolution()
{
	return 10;
}
     88c:	8a e0       	ldi	r24, 0x0A	; 10
     88e:	08 95       	ret

00000890 <ADC_0_register_callback>:

void ADC_0_register_callback(adc_irq_cb_t f)
{
	ADC_0_cb = f;
     890:	90 93 8f 01 	sts	0x018F, r25
     894:	80 93 8e 01 	sts	0x018E, r24
}
     898:	08 95       	ret

0000089a <ISR>:

ISR(ADC_vect)
{

	if (ADC_0_cb != NULL) {
     89a:	e0 91 8e 01 	lds	r30, 0x018E
     89e:	f0 91 8f 01 	lds	r31, 0x018F
     8a2:	30 97       	sbiw	r30, 0x00	; 0
     8a4:	09 f0       	breq	.+2      	; 0x8a8 <ISR+0xe>
		ADC_0_cb();
     8a6:	09 95       	icall
	}
     8a8:	08 95       	ret

000008aa <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     8aa:	80 91 92 01 	lds	r24, 0x0192
     8ae:	8f 5f       	subi	r24, 0xFF	; 255
     8b0:	80 93 92 01 	sts	0x0192, r24
}
     8b4:	08 95       	ret

000008b6 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     8b6:	0f b6       	in	r0, 0x3f	; 63
     8b8:	f8 94       	cli
     8ba:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     8bc:	20 91 95 01 	lds	r18, 0x0195
     8c0:	30 91 96 01 	lds	r19, 0x0196
	}
	portTICK_TYPE_EXIT_CRITICAL();
     8c4:	0f 90       	pop	r0
     8c6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     8c8:	c9 01       	movw	r24, r18
     8ca:	08 95       	ret

000008cc <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     8cc:	20 91 95 01 	lds	r18, 0x0195
     8d0:	30 91 96 01 	lds	r19, 0x0196
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     8d4:	c9 01       	movw	r24, r18
     8d6:	08 95       	ret

000008d8 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     8d8:	80 91 9b 01 	lds	r24, 0x019B
}
     8dc:	08 95       	ret

000008de <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     8de:	00 97       	sbiw	r24, 0x00	; 0
     8e0:	21 f4       	brne	.+8      	; 0x8ea <pcTaskGetName+0xc>
     8e2:	80 91 90 01 	lds	r24, 0x0190
     8e6:	90 91 91 01 	lds	r25, 0x0191
     8ea:	9c 01       	movw	r18, r24
     8ec:	27 5e       	subi	r18, 0xE7	; 231
     8ee:	3f 4f       	sbci	r19, 0xFF	; 255
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     8f0:	c9 01       	movw	r24, r18
     8f2:	08 95       	ret

000008f4 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     8f4:	80 91 92 01 	lds	r24, 0x0192
     8f8:	88 23       	and	r24, r24
     8fa:	21 f0       	breq	.+8      	; 0x904 <__stack+0x5>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     8fc:	81 e0       	ldi	r24, 0x01	; 1
     8fe:	80 93 94 01 	sts	0x0194, r24
     902:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     904:	10 92 94 01 	sts	0x0194, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     908:	20 91 93 01 	lds	r18, 0x0193
     90c:	99 e0       	ldi	r25, 0x09	; 9
     90e:	01 c0       	rjmp	.+2      	; 0x912 <__stack+0x13>
     910:	21 50       	subi	r18, 0x01	; 1
     912:	29 9f       	mul	r18, r25
     914:	d0 01       	movw	r26, r0
     916:	11 24       	eor	r1, r1
     918:	af 55       	subi	r26, 0x5F	; 95
     91a:	be 4f       	sbci	r27, 0xFE	; 254
     91c:	8c 91       	ld	r24, X
     91e:	88 23       	and	r24, r24
     920:	b9 f3       	breq	.-18     	; 0x910 <__stack+0x11>
     922:	11 96       	adiw	r26, 0x01	; 1
     924:	ed 91       	ld	r30, X+
     926:	fc 91       	ld	r31, X
     928:	12 97       	sbiw	r26, 0x02	; 2
     92a:	02 80       	ldd	r0, Z+2	; 0x02
     92c:	f3 81       	ldd	r31, Z+3	; 0x03
     92e:	e0 2d       	mov	r30, r0
     930:	12 96       	adiw	r26, 0x02	; 2
     932:	fc 93       	st	X, r31
     934:	ee 93       	st	-X, r30
     936:	11 97       	sbiw	r26, 0x01	; 1
     938:	cd 01       	movw	r24, r26
     93a:	03 96       	adiw	r24, 0x03	; 3
     93c:	e8 17       	cp	r30, r24
     93e:	f9 07       	cpc	r31, r25
     940:	31 f4       	brne	.+12     	; 0x94e <__stack+0x4f>
     942:	82 81       	ldd	r24, Z+2	; 0x02
     944:	93 81       	ldd	r25, Z+3	; 0x03
     946:	12 96       	adiw	r26, 0x02	; 2
     948:	9c 93       	st	X, r25
     94a:	8e 93       	st	-X, r24
     94c:	11 97       	sbiw	r26, 0x01	; 1
     94e:	11 96       	adiw	r26, 0x01	; 1
     950:	ed 91       	ld	r30, X+
     952:	fc 91       	ld	r31, X
     954:	12 97       	sbiw	r26, 0x02	; 2
     956:	86 81       	ldd	r24, Z+6	; 0x06
     958:	97 81       	ldd	r25, Z+7	; 0x07
     95a:	90 93 91 01 	sts	0x0191, r25
     95e:	80 93 90 01 	sts	0x0190, r24
     962:	20 93 93 01 	sts	0x0193, r18
     966:	08 95       	ret

00000968 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
     968:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     96a:	80 91 99 01 	lds	r24, 0x0199
     96e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     970:	80 91 95 01 	lds	r24, 0x0195
     974:	90 91 96 01 	lds	r25, 0x0196
     978:	92 83       	std	Z+2, r25	; 0x02
     97a:	81 83       	std	Z+1, r24	; 0x01
}
     97c:	08 95       	ret

0000097e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     97e:	fc 01       	movw	r30, r24
     980:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     982:	0f b6       	in	r0, 0x3f	; 63
     984:	f8 94       	cli
     986:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     988:	40 91 95 01 	lds	r20, 0x0195
     98c:	50 91 96 01 	lds	r21, 0x0196
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     990:	90 91 99 01 	lds	r25, 0x0199
     994:	80 81       	ld	r24, Z
     996:	98 17       	cp	r25, r24
     998:	29 f0       	breq	.+10     	; 0x9a4 <xTaskCheckForTimeOut+0x26>
     99a:	81 81       	ldd	r24, Z+1	; 0x01
     99c:	92 81       	ldd	r25, Z+2	; 0x02
     99e:	48 17       	cp	r20, r24
     9a0:	59 07       	cpc	r21, r25
     9a2:	e0 f4       	brcc	.+56     	; 0x9dc <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     9a4:	21 81       	ldd	r18, Z+1	; 0x01
     9a6:	32 81       	ldd	r19, Z+2	; 0x02
     9a8:	6d 91       	ld	r22, X+
     9aa:	7c 91       	ld	r23, X
     9ac:	11 97       	sbiw	r26, 0x01	; 1
     9ae:	ca 01       	movw	r24, r20
     9b0:	82 1b       	sub	r24, r18
     9b2:	93 0b       	sbc	r25, r19
     9b4:	86 17       	cp	r24, r22
     9b6:	97 07       	cpc	r25, r23
     9b8:	88 f4       	brcc	.+34     	; 0x9dc <xTaskCheckForTimeOut+0x5e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
     9ba:	24 1b       	sub	r18, r20
     9bc:	35 0b       	sbc	r19, r21
     9be:	26 0f       	add	r18, r22
     9c0:	37 1f       	adc	r19, r23
     9c2:	2d 93       	st	X+, r18
     9c4:	3c 93       	st	X, r19
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     9c6:	80 91 99 01 	lds	r24, 0x0199
     9ca:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     9cc:	80 91 95 01 	lds	r24, 0x0195
     9d0:	90 91 96 01 	lds	r25, 0x0196
     9d4:	92 83       	std	Z+2, r25	; 0x02
     9d6:	81 83       	std	Z+1, r24	; 0x01
     9d8:	80 e0       	ldi	r24, 0x00	; 0
     9da:	01 c0       	rjmp	.+2      	; 0x9de <xTaskCheckForTimeOut+0x60>
     9dc:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     9de:	0f 90       	pop	r0
     9e0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     9e2:	08 95       	ret

000009e4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	80 93 94 01 	sts	0x0194, r24
}
     9ea:	08 95       	ret

000009ec <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     9ec:	e0 91 90 01 	lds	r30, 0x0190
     9f0:	f0 91 91 01 	lds	r31, 0x0191
     9f4:	84 85       	ldd	r24, Z+12	; 0x0c
     9f6:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     9f8:	a0 91 90 01 	lds	r26, 0x0190
     9fc:	b0 91 91 01 	lds	r27, 0x0191
     a00:	e0 91 90 01 	lds	r30, 0x0190
     a04:	f0 91 91 01 	lds	r31, 0x0191
     a08:	46 89       	ldd	r20, Z+22	; 0x16
     a0a:	24 e0       	ldi	r18, 0x04	; 4
     a0c:	30 e0       	ldi	r19, 0x00	; 0
     a0e:	24 1b       	sub	r18, r20
     a10:	31 09       	sbc	r19, r1
     a12:	1d 96       	adiw	r26, 0x0d	; 13
     a14:	3c 93       	st	X, r19
     a16:	2e 93       	st	-X, r18
     a18:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
}
     a1a:	08 95       	ret

00000a1c <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
     a1c:	00 97       	sbiw	r24, 0x00	; 0
     a1e:	29 f4       	brne	.+10     	; 0xa2a <xTaskNotifyStateClear+0xe>
     a20:	e0 91 90 01 	lds	r30, 0x0190
     a24:	f0 91 91 01 	lds	r31, 0x0191
     a28:	01 c0       	rjmp	.+2      	; 0xa2c <xTaskNotifyStateClear+0x10>
     a2a:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
     a2c:	0f b6       	in	r0, 0x3f	; 63
     a2e:	f8 94       	cli
     a30:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
     a32:	85 a1       	ldd	r24, Z+37	; 0x25
     a34:	82 30       	cpi	r24, 0x02	; 2
     a36:	11 f0       	breq	.+4      	; 0xa3c <xTaskNotifyStateClear+0x20>
     a38:	80 e0       	ldi	r24, 0x00	; 0
     a3a:	02 c0       	rjmp	.+4      	; 0xa40 <xTaskNotifyStateClear+0x24>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     a3c:	15 a2       	std	Z+37, r1	; 0x25
     a3e:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		taskEXIT_CRITICAL();
     a40:	0f 90       	pop	r0
     a42:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     a44:	08 95       	ret

00000a46 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
     a46:	ef 92       	push	r14
     a48:	ff 92       	push	r15
     a4a:	0f 93       	push	r16
     a4c:	1f 93       	push	r17
     a4e:	cf 93       	push	r28
     a50:	df 93       	push	r29
     a52:	7b 01       	movw	r14, r22
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
     a54:	ec 01       	movw	r28, r24

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
     a56:	2d a1       	ldd	r18, Y+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     a58:	82 e0       	ldi	r24, 0x02	; 2
     a5a:	8d a3       	std	Y+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
     a5c:	89 a1       	ldd	r24, Y+33	; 0x21
     a5e:	9a a1       	ldd	r25, Y+34	; 0x22
     a60:	ab a1       	ldd	r26, Y+35	; 0x23
     a62:	bc a1       	ldd	r27, Y+36	; 0x24
     a64:	01 96       	adiw	r24, 0x01	; 1
     a66:	a1 1d       	adc	r26, r1
     a68:	b1 1d       	adc	r27, r1
     a6a:	89 a3       	std	Y+33, r24	; 0x21
     a6c:	9a a3       	std	Y+34, r25	; 0x22
     a6e:	ab a3       	std	Y+35, r26	; 0x23
     a70:	bc a3       	std	Y+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     a72:	21 30       	cpi	r18, 0x01	; 1
     a74:	91 f5       	brne	.+100    	; 0xada <vTaskNotifyGiveFromISR+0x94>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     a76:	80 91 92 01 	lds	r24, 0x0192
     a7a:	88 23       	and	r24, r24
     a7c:	a9 f4       	brne	.+42     	; 0xaa8 <vTaskNotifyGiveFromISR+0x62>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     a7e:	8e 01       	movw	r16, r28
     a80:	0e 5f       	subi	r16, 0xFE	; 254
     a82:	1f 4f       	sbci	r17, 0xFF	; 255
     a84:	c8 01       	movw	r24, r16
     a86:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     a8a:	9e 89       	ldd	r25, Y+22	; 0x16
     a8c:	80 91 93 01 	lds	r24, 0x0193
     a90:	89 17       	cp	r24, r25
     a92:	10 f4       	brcc	.+4      	; 0xa98 <vTaskNotifyGiveFromISR+0x52>
     a94:	90 93 93 01 	sts	0x0193, r25
     a98:	89 e0       	ldi	r24, 0x09	; 9
     a9a:	98 9f       	mul	r25, r24
     a9c:	c0 01       	movw	r24, r0
     a9e:	11 24       	eor	r1, r1
     aa0:	8f 55       	subi	r24, 0x5F	; 95
     aa2:	9e 4f       	sbci	r25, 0xFE	; 254
     aa4:	b8 01       	movw	r22, r16
     aa6:	05 c0       	rjmp	.+10     	; 0xab2 <vTaskNotifyGiveFromISR+0x6c>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     aa8:	be 01       	movw	r22, r28
     aaa:	64 5f       	subi	r22, 0xF4	; 244
     aac:	7f 4f       	sbci	r23, 0xFF	; 255
     aae:	8b ed       	ldi	r24, 0xDB	; 219
     ab0:	91 e0       	ldi	r25, 0x01	; 1
     ab2:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     ab6:	e0 91 90 01 	lds	r30, 0x0190
     aba:	f0 91 91 01 	lds	r31, 0x0191
     abe:	9e 89       	ldd	r25, Y+22	; 0x16
     ac0:	86 89       	ldd	r24, Z+22	; 0x16
     ac2:	89 17       	cp	r24, r25
     ac4:	50 f4       	brcc	.+20     	; 0xada <vTaskNotifyGiveFromISR+0x94>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
     ac6:	e1 14       	cp	r14, r1
     ac8:	f1 04       	cpc	r15, r1
     aca:	21 f0       	breq	.+8      	; 0xad4 <vTaskNotifyGiveFromISR+0x8e>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
     acc:	81 e0       	ldi	r24, 0x01	; 1
     ace:	f7 01       	movw	r30, r14
     ad0:	80 83       	st	Z, r24
     ad2:	03 c0       	rjmp	.+6      	; 0xada <vTaskNotifyGiveFromISR+0x94>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
     ad4:	81 e0       	ldi	r24, 0x01	; 1
     ad6:	80 93 94 01 	sts	0x0194, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
     ada:	df 91       	pop	r29
     adc:	cf 91       	pop	r28
     ade:	1f 91       	pop	r17
     ae0:	0f 91       	pop	r16
     ae2:	ff 90       	pop	r15
     ae4:	ef 90       	pop	r14
     ae6:	08 95       	ret

00000ae8 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
     ae8:	ef 92       	push	r14
     aea:	ff 92       	push	r15
     aec:	0f 93       	push	r16
     aee:	1f 93       	push	r17
     af0:	cf 93       	push	r28
     af2:	df 93       	push	r29
     af4:	f8 01       	movw	r30, r16
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
     af6:	ec 01       	movw	r28, r24

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
     af8:	01 15       	cp	r16, r1
     afa:	11 05       	cpc	r17, r1
     afc:	41 f0       	breq	.+16     	; 0xb0e <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     afe:	89 a1       	ldd	r24, Y+33	; 0x21
     b00:	9a a1       	ldd	r25, Y+34	; 0x22
     b02:	ab a1       	ldd	r26, Y+35	; 0x23
     b04:	bc a1       	ldd	r27, Y+36	; 0x24
     b06:	80 83       	st	Z, r24
     b08:	91 83       	std	Z+1, r25	; 0x01
     b0a:	a2 83       	std	Z+2, r26	; 0x02
     b0c:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     b0e:	3d a1       	ldd	r19, Y+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     b10:	82 e0       	ldi	r24, 0x02	; 2
     b12:	8d a3       	std	Y+37, r24	; 0x25

			switch( eAction )
     b14:	22 30       	cpi	r18, 0x02	; 2
     b16:	99 f0       	breq	.+38     	; 0xb3e <xTaskGenericNotifyFromISR+0x56>
     b18:	23 30       	cpi	r18, 0x03	; 3
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <xTaskGenericNotifyFromISR+0x3a>
     b1c:	21 30       	cpi	r18, 0x01	; 1
     b1e:	19 f5       	brne	.+70     	; 0xb66 <xTaskGenericNotifyFromISR+0x7e>
     b20:	05 c0       	rjmp	.+10     	; 0xb2c <xTaskGenericNotifyFromISR+0x44>
     b22:	23 30       	cpi	r18, 0x03	; 3
     b24:	e1 f0       	breq	.+56     	; 0xb5e <xTaskGenericNotifyFromISR+0x76>
     b26:	24 30       	cpi	r18, 0x04	; 4
     b28:	f1 f4       	brne	.+60     	; 0xb66 <xTaskGenericNotifyFromISR+0x7e>
     b2a:	15 c0       	rjmp	.+42     	; 0xb56 <xTaskGenericNotifyFromISR+0x6e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     b2c:	89 a1       	ldd	r24, Y+33	; 0x21
     b2e:	9a a1       	ldd	r25, Y+34	; 0x22
     b30:	ab a1       	ldd	r26, Y+35	; 0x23
     b32:	bc a1       	ldd	r27, Y+36	; 0x24
     b34:	84 2b       	or	r24, r20
     b36:	95 2b       	or	r25, r21
     b38:	a6 2b       	or	r26, r22
     b3a:	b7 2b       	or	r27, r23
     b3c:	07 c0       	rjmp	.+14     	; 0xb4c <xTaskGenericNotifyFromISR+0x64>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     b3e:	89 a1       	ldd	r24, Y+33	; 0x21
     b40:	9a a1       	ldd	r25, Y+34	; 0x22
     b42:	ab a1       	ldd	r26, Y+35	; 0x23
     b44:	bc a1       	ldd	r27, Y+36	; 0x24
     b46:	01 96       	adiw	r24, 0x01	; 1
     b48:	a1 1d       	adc	r26, r1
     b4a:	b1 1d       	adc	r27, r1
     b4c:	89 a3       	std	Y+33, r24	; 0x21
     b4e:	9a a3       	std	Y+34, r25	; 0x22
     b50:	ab a3       	std	Y+35, r26	; 0x23
     b52:	bc a3       	std	Y+36, r27	; 0x24
     b54:	08 c0       	rjmp	.+16     	; 0xb66 <xTaskGenericNotifyFromISR+0x7e>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     b56:	32 30       	cpi	r19, 0x02	; 2
     b58:	11 f4       	brne	.+4      	; 0xb5e <xTaskGenericNotifyFromISR+0x76>
     b5a:	80 e0       	ldi	r24, 0x00	; 0
     b5c:	3a c0       	rjmp	.+116    	; 0xbd2 <xTaskGenericNotifyFromISR+0xea>
					{
						pxTCB->ulNotifiedValue = ulValue;
     b5e:	49 a3       	std	Y+33, r20	; 0x21
     b60:	5a a3       	std	Y+34, r21	; 0x22
     b62:	6b a3       	std	Y+35, r22	; 0x23
     b64:	7c a3       	std	Y+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     b66:	31 30       	cpi	r19, 0x01	; 1
     b68:	99 f5       	brne	.+102    	; 0xbd0 <xTaskGenericNotifyFromISR+0xe8>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     b6a:	80 91 92 01 	lds	r24, 0x0192
     b6e:	88 23       	and	r24, r24
     b70:	a9 f4       	brne	.+42     	; 0xb9c <xTaskGenericNotifyFromISR+0xb4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     b72:	8e 01       	movw	r16, r28
     b74:	0e 5f       	subi	r16, 0xFE	; 254
     b76:	1f 4f       	sbci	r17, 0xFF	; 255
     b78:	c8 01       	movw	r24, r16
     b7a:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     b7e:	9e 89       	ldd	r25, Y+22	; 0x16
     b80:	80 91 93 01 	lds	r24, 0x0193
     b84:	89 17       	cp	r24, r25
     b86:	10 f4       	brcc	.+4      	; 0xb8c <xTaskGenericNotifyFromISR+0xa4>
     b88:	90 93 93 01 	sts	0x0193, r25
     b8c:	89 e0       	ldi	r24, 0x09	; 9
     b8e:	98 9f       	mul	r25, r24
     b90:	c0 01       	movw	r24, r0
     b92:	11 24       	eor	r1, r1
     b94:	8f 55       	subi	r24, 0x5F	; 95
     b96:	9e 4f       	sbci	r25, 0xFE	; 254
     b98:	b8 01       	movw	r22, r16
     b9a:	05 c0       	rjmp	.+10     	; 0xba6 <xTaskGenericNotifyFromISR+0xbe>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     b9c:	be 01       	movw	r22, r28
     b9e:	64 5f       	subi	r22, 0xF4	; 244
     ba0:	7f 4f       	sbci	r23, 0xFF	; 255
     ba2:	8b ed       	ldi	r24, 0xDB	; 219
     ba4:	91 e0       	ldi	r25, 0x01	; 1
     ba6:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     baa:	e0 91 90 01 	lds	r30, 0x0190
     bae:	f0 91 91 01 	lds	r31, 0x0191
     bb2:	9e 89       	ldd	r25, Y+22	; 0x16
     bb4:	86 89       	ldd	r24, Z+22	; 0x16
     bb6:	89 17       	cp	r24, r25
     bb8:	58 f4       	brcc	.+22     	; 0xbd0 <xTaskGenericNotifyFromISR+0xe8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
     bba:	e1 14       	cp	r14, r1
     bbc:	f1 04       	cpc	r15, r1
     bbe:	21 f0       	breq	.+8      	; 0xbc8 <xTaskGenericNotifyFromISR+0xe0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
     bc0:	81 e0       	ldi	r24, 0x01	; 1
     bc2:	f7 01       	movw	r30, r14
     bc4:	80 83       	st	Z, r24
     bc6:	05 c0       	rjmp	.+10     	; 0xbd2 <xTaskGenericNotifyFromISR+0xea>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
     bc8:	81 e0       	ldi	r24, 0x01	; 1
     bca:	80 93 94 01 	sts	0x0194, r24
     bce:	01 c0       	rjmp	.+2      	; 0xbd2 <xTaskGenericNotifyFromISR+0xea>
     bd0:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
     bd2:	df 91       	pop	r29
     bd4:	cf 91       	pop	r28
     bd6:	1f 91       	pop	r17
     bd8:	0f 91       	pop	r16
     bda:	ff 90       	pop	r15
     bdc:	ef 90       	pop	r14
     bde:	08 95       	ret

00000be0 <xTaskRemoveFromUnorderedEventList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     be0:	0f 93       	push	r16
     be2:	1f 93       	push	r17
     be4:	cf 93       	push	r28
     be6:	df 93       	push	r29
     be8:	fc 01       	movw	r30, r24
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     bea:	70 68       	ori	r23, 0x80	; 128
     bec:	71 83       	std	Z+1, r23	; 0x01
     bee:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
     bf0:	c6 81       	ldd	r28, Z+6	; 0x06
     bf2:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     bf4:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     bf8:	8e 01       	movw	r16, r28
     bfa:	0e 5f       	subi	r16, 0xFE	; 254
     bfc:	1f 4f       	sbci	r17, 0xFF	; 255
     bfe:	c8 01       	movw	r24, r16
     c00:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     c04:	9e 89       	ldd	r25, Y+22	; 0x16
     c06:	80 91 93 01 	lds	r24, 0x0193
     c0a:	89 17       	cp	r24, r25
     c0c:	10 f4       	brcc	.+4      	; 0xc12 <xTaskRemoveFromUnorderedEventList+0x32>
     c0e:	90 93 93 01 	sts	0x0193, r25
     c12:	89 e0       	ldi	r24, 0x09	; 9
     c14:	98 9f       	mul	r25, r24
     c16:	c0 01       	movw	r24, r0
     c18:	11 24       	eor	r1, r1
     c1a:	8f 55       	subi	r24, 0x5F	; 95
     c1c:	9e 4f       	sbci	r25, 0xFE	; 254
     c1e:	b8 01       	movw	r22, r16
     c20:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c24:	e0 91 90 01 	lds	r30, 0x0190
     c28:	f0 91 91 01 	lds	r31, 0x0191
     c2c:	9e 89       	ldd	r25, Y+22	; 0x16
     c2e:	86 89       	ldd	r24, Z+22	; 0x16
     c30:	89 17       	cp	r24, r25
     c32:	10 f0       	brcs	.+4      	; 0xc38 <xTaskRemoveFromUnorderedEventList+0x58>
     c34:	80 e0       	ldi	r24, 0x00	; 0
     c36:	03 c0       	rjmp	.+6      	; 0xc3e <xTaskRemoveFromUnorderedEventList+0x5e>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     c38:	81 e0       	ldi	r24, 0x01	; 1
     c3a:	80 93 94 01 	sts	0x0194, r24
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     c3e:	df 91       	pop	r29
     c40:	cf 91       	pop	r28
     c42:	1f 91       	pop	r17
     c44:	0f 91       	pop	r16
     c46:	08 95       	ret

00000c48 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     c48:	0f 93       	push	r16
     c4a:	1f 93       	push	r17
     c4c:	cf 93       	push	r28
     c4e:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     c50:	dc 01       	movw	r26, r24
     c52:	15 96       	adiw	r26, 0x05	; 5
     c54:	ed 91       	ld	r30, X+
     c56:	fc 91       	ld	r31, X
     c58:	16 97       	sbiw	r26, 0x06	; 6
     c5a:	c6 81       	ldd	r28, Z+6	; 0x06
     c5c:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     c5e:	8e 01       	movw	r16, r28
     c60:	04 5f       	subi	r16, 0xF4	; 244
     c62:	1f 4f       	sbci	r17, 0xFF	; 255
     c64:	c8 01       	movw	r24, r16
     c66:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c6a:	80 91 92 01 	lds	r24, 0x0192
     c6e:	88 23       	and	r24, r24
     c70:	a1 f4       	brne	.+40     	; 0xc9a <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c72:	8e 01       	movw	r16, r28
     c74:	0e 5f       	subi	r16, 0xFE	; 254
     c76:	1f 4f       	sbci	r17, 0xFF	; 255
     c78:	c8 01       	movw	r24, r16
     c7a:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     c7e:	9e 89       	ldd	r25, Y+22	; 0x16
     c80:	80 91 93 01 	lds	r24, 0x0193
     c84:	89 17       	cp	r24, r25
     c86:	10 f4       	brcc	.+4      	; 0xc8c <xTaskRemoveFromEventList+0x44>
     c88:	90 93 93 01 	sts	0x0193, r25
     c8c:	89 e0       	ldi	r24, 0x09	; 9
     c8e:	98 9f       	mul	r25, r24
     c90:	c0 01       	movw	r24, r0
     c92:	11 24       	eor	r1, r1
     c94:	8f 55       	subi	r24, 0x5F	; 95
     c96:	9e 4f       	sbci	r25, 0xFE	; 254
     c98:	02 c0       	rjmp	.+4      	; 0xc9e <xTaskRemoveFromEventList+0x56>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     c9a:	8b ed       	ldi	r24, 0xDB	; 219
     c9c:	91 e0       	ldi	r25, 0x01	; 1
     c9e:	b8 01       	movw	r22, r16
     ca0:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     ca4:	e0 91 90 01 	lds	r30, 0x0190
     ca8:	f0 91 91 01 	lds	r31, 0x0191
     cac:	9e 89       	ldd	r25, Y+22	; 0x16
     cae:	86 89       	ldd	r24, Z+22	; 0x16
     cb0:	89 17       	cp	r24, r25
     cb2:	10 f0       	brcs	.+4      	; 0xcb8 <xTaskRemoveFromEventList+0x70>
     cb4:	80 e0       	ldi	r24, 0x00	; 0
     cb6:	03 c0       	rjmp	.+6      	; 0xcbe <xTaskRemoveFromEventList+0x76>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     cb8:	81 e0       	ldi	r24, 0x01	; 1
     cba:	80 93 94 01 	sts	0x0194, r24
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     cbe:	df 91       	pop	r29
     cc0:	cf 91       	pop	r28
     cc2:	1f 91       	pop	r17
     cc4:	0f 91       	pop	r16
     cc6:	08 95       	ret

00000cc8 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     cc8:	cf 92       	push	r12
     cca:	df 92       	push	r13
     ccc:	ef 92       	push	r14
     cce:	ff 92       	push	r15
     cd0:	0f 93       	push	r16
     cd2:	1f 93       	push	r17
     cd4:	cf 93       	push	r28
     cd6:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     cd8:	80 91 92 01 	lds	r24, 0x0192
     cdc:	88 23       	and	r24, r24
     cde:	09 f0       	breq	.+2      	; 0xce2 <xTaskIncrementTick+0x1a>
     ce0:	a6 c0       	rjmp	.+332    	; 0xe2e <xTaskIncrementTick+0x166>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     ce2:	00 91 95 01 	lds	r16, 0x0195
     ce6:	10 91 96 01 	lds	r17, 0x0196
     cea:	0f 5f       	subi	r16, 0xFF	; 255
     cec:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     cee:	10 93 96 01 	sts	0x0196, r17
     cf2:	00 93 95 01 	sts	0x0195, r16

		if( xConstTickCount == ( TickType_t ) 0U )
     cf6:	01 15       	cp	r16, r1
     cf8:	11 05       	cpc	r17, r1
     cfa:	79 f5       	brne	.+94     	; 0xd5a <xTaskIncrementTick+0x92>
		{
			taskSWITCH_DELAYED_LISTS();
     cfc:	20 91 d7 01 	lds	r18, 0x01D7
     d00:	30 91 d8 01 	lds	r19, 0x01D8
     d04:	80 91 d9 01 	lds	r24, 0x01D9
     d08:	90 91 da 01 	lds	r25, 0x01DA
     d0c:	90 93 d8 01 	sts	0x01D8, r25
     d10:	80 93 d7 01 	sts	0x01D7, r24
     d14:	30 93 da 01 	sts	0x01DA, r19
     d18:	20 93 d9 01 	sts	0x01D9, r18
     d1c:	80 91 99 01 	lds	r24, 0x0199
     d20:	8f 5f       	subi	r24, 0xFF	; 255
     d22:	80 93 99 01 	sts	0x0199, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     d26:	e0 91 d7 01 	lds	r30, 0x01D7
     d2a:	f0 91 d8 01 	lds	r31, 0x01D8
     d2e:	80 81       	ld	r24, Z
     d30:	88 23       	and	r24, r24
     d32:	19 f4       	brne	.+6      	; 0xd3a <xTaskIncrementTick+0x72>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     d34:	8f ef       	ldi	r24, 0xFF	; 255
     d36:	9f ef       	ldi	r25, 0xFF	; 255
     d38:	0c c0       	rjmp	.+24     	; 0xd52 <xTaskIncrementTick+0x8a>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     d3a:	e0 91 d7 01 	lds	r30, 0x01D7
     d3e:	f0 91 d8 01 	lds	r31, 0x01D8
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     d42:	05 80       	ldd	r0, Z+5	; 0x05
     d44:	f6 81       	ldd	r31, Z+6	; 0x06
     d46:	e0 2d       	mov	r30, r0
     d48:	06 80       	ldd	r0, Z+6	; 0x06
     d4a:	f7 81       	ldd	r31, Z+7	; 0x07
     d4c:	e0 2d       	mov	r30, r0
     d4e:	82 81       	ldd	r24, Z+2	; 0x02
     d50:	93 81       	ldd	r25, Z+3	; 0x03
     d52:	90 93 98 01 	sts	0x0198, r25
     d56:	80 93 97 01 	sts	0x0197, r24

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     d5a:	80 91 97 01 	lds	r24, 0x0197
     d5e:	90 91 98 01 	lds	r25, 0x0198
     d62:	08 17       	cp	r16, r24
     d64:	19 07       	cpc	r17, r25
     d66:	08 f4       	brcc	.+2      	; 0xd6a <xTaskIncrementTick+0xa2>
     d68:	4b c0       	rjmp	.+150    	; 0xe00 <xTaskIncrementTick+0x138>
     d6a:	dd 24       	eor	r13, r13
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     d6c:	49 e0       	ldi	r20, 0x09	; 9
     d6e:	c4 2e       	mov	r12, r20
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     d70:	e0 91 d7 01 	lds	r30, 0x01D7
     d74:	f0 91 d8 01 	lds	r31, 0x01D8
     d78:	80 81       	ld	r24, Z
     d7a:	88 23       	and	r24, r24
     d7c:	19 f4       	brne	.+6      	; 0xd84 <xTaskIncrementTick+0xbc>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d7e:	8f ef       	ldi	r24, 0xFF	; 255
     d80:	9f ef       	ldi	r25, 0xFF	; 255
     d82:	0e c0       	rjmp	.+28     	; 0xda0 <xTaskIncrementTick+0xd8>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     d84:	e0 91 d7 01 	lds	r30, 0x01D7
     d88:	f0 91 d8 01 	lds	r31, 0x01D8
     d8c:	05 80       	ldd	r0, Z+5	; 0x05
     d8e:	f6 81       	ldd	r31, Z+6	; 0x06
     d90:	e0 2d       	mov	r30, r0
     d92:	c6 81       	ldd	r28, Z+6	; 0x06
     d94:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     d96:	8a 81       	ldd	r24, Y+2	; 0x02
     d98:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
     d9a:	08 17       	cp	r16, r24
     d9c:	19 07       	cpc	r17, r25
     d9e:	28 f4       	brcc	.+10     	; 0xdaa <xTaskIncrementTick+0xe2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     da0:	90 93 98 01 	sts	0x0198, r25
     da4:	80 93 97 01 	sts	0x0197, r24
     da8:	2c c0       	rjmp	.+88     	; 0xe02 <xTaskIncrementTick+0x13a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     daa:	32 e0       	ldi	r19, 0x02	; 2
     dac:	e3 2e       	mov	r14, r19
     dae:	f1 2c       	mov	r15, r1
     db0:	ec 0e       	add	r14, r28
     db2:	fd 1e       	adc	r15, r29
     db4:	c7 01       	movw	r24, r14
     db6:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     dba:	8c 89       	ldd	r24, Y+20	; 0x14
     dbc:	9d 89       	ldd	r25, Y+21	; 0x15
     dbe:	89 2b       	or	r24, r25
     dc0:	21 f0       	breq	.+8      	; 0xdca <xTaskIncrementTick+0x102>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     dc2:	ce 01       	movw	r24, r28
     dc4:	0c 96       	adiw	r24, 0x0c	; 12
     dc6:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     dca:	9e 89       	ldd	r25, Y+22	; 0x16
     dcc:	80 91 93 01 	lds	r24, 0x0193
     dd0:	89 17       	cp	r24, r25
     dd2:	10 f4       	brcc	.+4      	; 0xdd8 <xTaskIncrementTick+0x110>
     dd4:	90 93 93 01 	sts	0x0193, r25
     dd8:	9c 9d       	mul	r25, r12
     dda:	c0 01       	movw	r24, r0
     ddc:	11 24       	eor	r1, r1
     dde:	8f 55       	subi	r24, 0x5F	; 95
     de0:	9e 4f       	sbci	r25, 0xFE	; 254
     de2:	b7 01       	movw	r22, r14
     de4:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     de8:	e0 91 90 01 	lds	r30, 0x0190
     dec:	f0 91 91 01 	lds	r31, 0x0191
     df0:	9e 89       	ldd	r25, Y+22	; 0x16
     df2:	86 89       	ldd	r24, Z+22	; 0x16
     df4:	98 17       	cp	r25, r24
     df6:	08 f4       	brcc	.+2      	; 0xdfa <xTaskIncrementTick+0x132>
     df8:	bb cf       	rjmp	.-138    	; 0xd70 <xTaskIncrementTick+0xa8>
     dfa:	dd 24       	eor	r13, r13
     dfc:	d3 94       	inc	r13
     dfe:	b8 cf       	rjmp	.-144    	; 0xd70 <xTaskIncrementTick+0xa8>
     e00:	dd 24       	eor	r13, r13
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     e02:	e0 91 90 01 	lds	r30, 0x0190
     e06:	f0 91 91 01 	lds	r31, 0x0191
     e0a:	86 89       	ldd	r24, Z+22	; 0x16
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	fc 01       	movw	r30, r24
     e10:	23 e0       	ldi	r18, 0x03	; 3
     e12:	ee 0f       	add	r30, r30
     e14:	ff 1f       	adc	r31, r31
     e16:	2a 95       	dec	r18
     e18:	e1 f7       	brne	.-8      	; 0xe12 <xTaskIncrementTick+0x14a>
     e1a:	e8 0f       	add	r30, r24
     e1c:	f9 1f       	adc	r31, r25
     e1e:	ef 55       	subi	r30, 0x5F	; 95
     e20:	fe 4f       	sbci	r31, 0xFE	; 254
     e22:	80 81       	ld	r24, Z
     e24:	82 30       	cpi	r24, 0x02	; 2
     e26:	48 f0       	brcs	.+18     	; 0xe3a <xTaskIncrementTick+0x172>
     e28:	dd 24       	eor	r13, r13
     e2a:	d3 94       	inc	r13
     e2c:	06 c0       	rjmp	.+12     	; 0xe3a <xTaskIncrementTick+0x172>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     e2e:	80 91 9a 01 	lds	r24, 0x019A
     e32:	8f 5f       	subi	r24, 0xFF	; 255
     e34:	80 93 9a 01 	sts	0x019A, r24
     e38:	dd 24       	eor	r13, r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     e3a:	80 91 94 01 	lds	r24, 0x0194
     e3e:	88 23       	and	r24, r24
     e40:	11 f0       	breq	.+4      	; 0xe46 <xTaskIncrementTick+0x17e>
     e42:	dd 24       	eor	r13, r13
     e44:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     e46:	8d 2d       	mov	r24, r13
     e48:	df 91       	pop	r29
     e4a:	cf 91       	pop	r28
     e4c:	1f 91       	pop	r17
     e4e:	0f 91       	pop	r16
     e50:	ff 90       	pop	r15
     e52:	ef 90       	pop	r14
     e54:	df 90       	pop	r13
     e56:	cf 90       	pop	r12
     e58:	08 95       	ret

00000e5a <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     e5a:	0f 93       	push	r16
     e5c:	1f 93       	push	r17
     e5e:	cf 93       	push	r28
     e60:	df 93       	push	r29
     e62:	f8 01       	movw	r30, r16
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
     e64:	ec 01       	movw	r28, r24

		taskENTER_CRITICAL();
     e66:	0f b6       	in	r0, 0x3f	; 63
     e68:	f8 94       	cli
     e6a:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
     e6c:	01 15       	cp	r16, r1
     e6e:	11 05       	cpc	r17, r1
     e70:	41 f0       	breq	.+16     	; 0xe82 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     e72:	89 a1       	ldd	r24, Y+33	; 0x21
     e74:	9a a1       	ldd	r25, Y+34	; 0x22
     e76:	ab a1       	ldd	r26, Y+35	; 0x23
     e78:	bc a1       	ldd	r27, Y+36	; 0x24
     e7a:	80 83       	st	Z, r24
     e7c:	91 83       	std	Z+1, r25	; 0x01
     e7e:	a2 83       	std	Z+2, r26	; 0x02
     e80:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     e82:	3d a1       	ldd	r19, Y+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     e84:	82 e0       	ldi	r24, 0x02	; 2
     e86:	8d a3       	std	Y+37, r24	; 0x25

			switch( eAction )
     e88:	22 30       	cpi	r18, 0x02	; 2
     e8a:	99 f0       	breq	.+38     	; 0xeb2 <xTaskGenericNotify+0x58>
     e8c:	23 30       	cpi	r18, 0x03	; 3
     e8e:	18 f4       	brcc	.+6      	; 0xe96 <xTaskGenericNotify+0x3c>
     e90:	21 30       	cpi	r18, 0x01	; 1
     e92:	19 f5       	brne	.+70     	; 0xeda <xTaskGenericNotify+0x80>
     e94:	05 c0       	rjmp	.+10     	; 0xea0 <xTaskGenericNotify+0x46>
     e96:	23 30       	cpi	r18, 0x03	; 3
     e98:	e1 f0       	breq	.+56     	; 0xed2 <xTaskGenericNotify+0x78>
     e9a:	24 30       	cpi	r18, 0x04	; 4
     e9c:	f1 f4       	brne	.+60     	; 0xeda <xTaskGenericNotify+0x80>
     e9e:	15 c0       	rjmp	.+42     	; 0xeca <xTaskGenericNotify+0x70>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     ea0:	89 a1       	ldd	r24, Y+33	; 0x21
     ea2:	9a a1       	ldd	r25, Y+34	; 0x22
     ea4:	ab a1       	ldd	r26, Y+35	; 0x23
     ea6:	bc a1       	ldd	r27, Y+36	; 0x24
     ea8:	84 2b       	or	r24, r20
     eaa:	95 2b       	or	r25, r21
     eac:	a6 2b       	or	r26, r22
     eae:	b7 2b       	or	r27, r23
     eb0:	07 c0       	rjmp	.+14     	; 0xec0 <xTaskGenericNotify+0x66>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     eb2:	89 a1       	ldd	r24, Y+33	; 0x21
     eb4:	9a a1       	ldd	r25, Y+34	; 0x22
     eb6:	ab a1       	ldd	r26, Y+35	; 0x23
     eb8:	bc a1       	ldd	r27, Y+36	; 0x24
     eba:	01 96       	adiw	r24, 0x01	; 1
     ebc:	a1 1d       	adc	r26, r1
     ebe:	b1 1d       	adc	r27, r1
     ec0:	89 a3       	std	Y+33, r24	; 0x21
     ec2:	9a a3       	std	Y+34, r25	; 0x22
     ec4:	ab a3       	std	Y+35, r26	; 0x23
     ec6:	bc a3       	std	Y+36, r27	; 0x24
     ec8:	08 c0       	rjmp	.+16     	; 0xeda <xTaskGenericNotify+0x80>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     eca:	32 30       	cpi	r19, 0x02	; 2
     ecc:	11 f4       	brne	.+4      	; 0xed2 <xTaskGenericNotify+0x78>
     ece:	80 e0       	ldi	r24, 0x00	; 0
     ed0:	27 c0       	rjmp	.+78     	; 0xf20 <xTaskGenericNotify+0xc6>
					{
						pxTCB->ulNotifiedValue = ulValue;
     ed2:	49 a3       	std	Y+33, r20	; 0x21
     ed4:	5a a3       	std	Y+34, r21	; 0x22
     ed6:	6b a3       	std	Y+35, r22	; 0x23
     ed8:	7c a3       	std	Y+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     eda:	31 30       	cpi	r19, 0x01	; 1
     edc:	01 f5       	brne	.+64     	; 0xf1e <xTaskGenericNotify+0xc4>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     ede:	8e 01       	movw	r16, r28
     ee0:	0e 5f       	subi	r16, 0xFE	; 254
     ee2:	1f 4f       	sbci	r17, 0xFF	; 255
     ee4:	c8 01       	movw	r24, r16
     ee6:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
     eea:	9e 89       	ldd	r25, Y+22	; 0x16
     eec:	80 91 93 01 	lds	r24, 0x0193
     ef0:	89 17       	cp	r24, r25
     ef2:	10 f4       	brcc	.+4      	; 0xef8 <xTaskGenericNotify+0x9e>
     ef4:	90 93 93 01 	sts	0x0193, r25
     ef8:	89 e0       	ldi	r24, 0x09	; 9
     efa:	98 9f       	mul	r25, r24
     efc:	c0 01       	movw	r24, r0
     efe:	11 24       	eor	r1, r1
     f00:	8f 55       	subi	r24, 0x5F	; 95
     f02:	9e 4f       	sbci	r25, 0xFE	; 254
     f04:	b8 01       	movw	r22, r16
     f06:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     f0a:	e0 91 90 01 	lds	r30, 0x0190
     f0e:	f0 91 91 01 	lds	r31, 0x0191
     f12:	9e 89       	ldd	r25, Y+22	; 0x16
     f14:	86 89       	ldd	r24, Z+22	; 0x16
     f16:	89 17       	cp	r24, r25
     f18:	10 f4       	brcc	.+4      	; 0xf1e <xTaskGenericNotify+0xc4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
     f1a:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
     f1e:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     f20:	0f 90       	pop	r0
     f22:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     f24:	df 91       	pop	r29
     f26:	cf 91       	pop	r28
     f28:	1f 91       	pop	r17
     f2a:	0f 91       	pop	r16
     f2c:	08 95       	ret

00000f2e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     f2e:	ef 92       	push	r14
     f30:	ff 92       	push	r15
     f32:	0f 93       	push	r16
     f34:	1f 93       	push	r17
     f36:	cf 93       	push	r28
     f38:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     f3a:	0f b6       	in	r0, 0x3f	; 63
     f3c:	f8 94       	cli
     f3e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     f40:	80 91 92 01 	lds	r24, 0x0192
     f44:	81 50       	subi	r24, 0x01	; 1
     f46:	80 93 92 01 	sts	0x0192, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     f4a:	80 91 92 01 	lds	r24, 0x0192
     f4e:	88 23       	and	r24, r24
     f50:	09 f0       	breq	.+2      	; 0xf54 <xTaskResumeAll+0x26>
     f52:	6c c0       	rjmp	.+216    	; 0x102c <xTaskResumeAll+0xfe>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     f54:	80 91 9b 01 	lds	r24, 0x019B
     f58:	88 23       	and	r24, r24
     f5a:	09 f4       	brne	.+2      	; 0xf5e <xTaskResumeAll+0x30>
     f5c:	67 c0       	rjmp	.+206    	; 0x102c <xTaskResumeAll+0xfe>
     f5e:	c0 e0       	ldi	r28, 0x00	; 0
     f60:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     f62:	59 e0       	ldi	r21, 0x09	; 9
     f64:	e5 2e       	mov	r14, r21

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     f66:	ff 24       	eor	r15, r15
     f68:	f3 94       	inc	r15
     f6a:	29 c0       	rjmp	.+82     	; 0xfbe <xTaskResumeAll+0x90>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     f6c:	e0 91 e0 01 	lds	r30, 0x01E0
     f70:	f0 91 e1 01 	lds	r31, 0x01E1
     f74:	c6 81       	ldd	r28, Z+6	; 0x06
     f76:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     f78:	ce 01       	movw	r24, r28
     f7a:	0c 96       	adiw	r24, 0x0c	; 12
     f7c:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     f80:	8e 01       	movw	r16, r28
     f82:	0e 5f       	subi	r16, 0xFE	; 254
     f84:	1f 4f       	sbci	r17, 0xFF	; 255
     f86:	c8 01       	movw	r24, r16
     f88:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     f8c:	9e 89       	ldd	r25, Y+22	; 0x16
     f8e:	80 91 93 01 	lds	r24, 0x0193
     f92:	89 17       	cp	r24, r25
     f94:	10 f4       	brcc	.+4      	; 0xf9a <xTaskResumeAll+0x6c>
     f96:	90 93 93 01 	sts	0x0193, r25
     f9a:	9e 9d       	mul	r25, r14
     f9c:	c0 01       	movw	r24, r0
     f9e:	11 24       	eor	r1, r1
     fa0:	8f 55       	subi	r24, 0x5F	; 95
     fa2:	9e 4f       	sbci	r25, 0xFE	; 254
     fa4:	b8 01       	movw	r22, r16
     fa6:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     faa:	e0 91 90 01 	lds	r30, 0x0190
     fae:	f0 91 91 01 	lds	r31, 0x0191
     fb2:	9e 89       	ldd	r25, Y+22	; 0x16
     fb4:	86 89       	ldd	r24, Z+22	; 0x16
     fb6:	98 17       	cp	r25, r24
     fb8:	10 f0       	brcs	.+4      	; 0xfbe <xTaskResumeAll+0x90>
					{
						xYieldPending = pdTRUE;
     fba:	f0 92 94 01 	sts	0x0194, r15
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     fbe:	80 91 db 01 	lds	r24, 0x01DB
     fc2:	88 23       	and	r24, r24
     fc4:	99 f6       	brne	.-90     	; 0xf6c <xTaskResumeAll+0x3e>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     fc6:	cd 2b       	or	r28, r29
     fc8:	d1 f0       	breq	.+52     	; 0xffe <xTaskResumeAll+0xd0>

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     fca:	e0 91 d7 01 	lds	r30, 0x01D7
     fce:	f0 91 d8 01 	lds	r31, 0x01D8
     fd2:	80 81       	ld	r24, Z
     fd4:	88 23       	and	r24, r24
     fd6:	19 f4       	brne	.+6      	; 0xfde <xTaskResumeAll+0xb0>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     fd8:	8f ef       	ldi	r24, 0xFF	; 255
     fda:	9f ef       	ldi	r25, 0xFF	; 255
     fdc:	0c c0       	rjmp	.+24     	; 0xff6 <xTaskResumeAll+0xc8>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     fde:	e0 91 d7 01 	lds	r30, 0x01D7
     fe2:	f0 91 d8 01 	lds	r31, 0x01D8
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     fe6:	05 80       	ldd	r0, Z+5	; 0x05
     fe8:	f6 81       	ldd	r31, Z+6	; 0x06
     fea:	e0 2d       	mov	r30, r0
     fec:	06 80       	ldd	r0, Z+6	; 0x06
     fee:	f7 81       	ldd	r31, Z+7	; 0x07
     ff0:	e0 2d       	mov	r30, r0
     ff2:	82 81       	ldd	r24, Z+2	; 0x02
     ff4:	93 81       	ldd	r25, Z+3	; 0x03
     ff6:	90 93 98 01 	sts	0x0198, r25
     ffa:	80 93 97 01 	sts	0x0197, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     ffe:	10 91 9a 01 	lds	r17, 0x019A

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    1002:	11 23       	and	r17, r17
    1004:	59 f0       	breq	.+22     	; 0x101c <xTaskResumeAll+0xee>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    1006:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    1008:	0e 94 64 06 	call	0xcc8	; 0xcc8 <xTaskIncrementTick>
    100c:	88 23       	and	r24, r24
    100e:	11 f0       	breq	.+4      	; 0x1014 <xTaskResumeAll+0xe6>
							{
								xYieldPending = pdTRUE;
    1010:	00 93 94 01 	sts	0x0194, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    1014:	11 50       	subi	r17, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1016:	c1 f7       	brne	.-16     	; 0x1008 <xTaskResumeAll+0xda>

						uxPendedTicks = 0;
    1018:	10 92 9a 01 	sts	0x019A, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    101c:	80 91 94 01 	lds	r24, 0x0194
    1020:	88 23       	and	r24, r24
    1022:	21 f0       	breq	.+8      	; 0x102c <xTaskResumeAll+0xfe>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    1024:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
    1028:	81 e0       	ldi	r24, 0x01	; 1
    102a:	01 c0       	rjmp	.+2      	; 0x102e <xTaskResumeAll+0x100>
    102c:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    102e:	0f 90       	pop	r0
    1030:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1032:	df 91       	pop	r29
    1034:	cf 91       	pop	r28
    1036:	1f 91       	pop	r17
    1038:	0f 91       	pop	r16
    103a:	ff 90       	pop	r15
    103c:	ef 90       	pop	r14
    103e:	08 95       	ret

00001040 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    1040:	0f 93       	push	r16
    1042:	1f 93       	push	r17
    1044:	cf 93       	push	r28
    1046:	df 93       	push	r29
    1048:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    104a:	00 91 95 01 	lds	r16, 0x0195
    104e:	10 91 96 01 	lds	r17, 0x0196
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1052:	80 91 90 01 	lds	r24, 0x0190
    1056:	90 91 91 01 	lds	r25, 0x0191
    105a:	02 96       	adiw	r24, 0x02	; 2
    105c:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    1060:	c0 0f       	add	r28, r16
    1062:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    1064:	e0 91 90 01 	lds	r30, 0x0190
    1068:	f0 91 91 01 	lds	r31, 0x0191
    106c:	d3 83       	std	Z+3, r29	; 0x03
    106e:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
    1070:	c0 17       	cp	r28, r16
    1072:	d1 07       	cpc	r29, r17
    1074:	68 f4       	brcc	.+26     	; 0x1090 <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1076:	80 91 d9 01 	lds	r24, 0x01D9
    107a:	90 91 da 01 	lds	r25, 0x01DA
    107e:	60 91 90 01 	lds	r22, 0x0190
    1082:	70 91 91 01 	lds	r23, 0x0191
    1086:	6e 5f       	subi	r22, 0xFE	; 254
    1088:	7f 4f       	sbci	r23, 0xFF	; 255
    108a:	0e 94 c0 0f 	call	0x1f80	; 0x1f80 <vListInsert>
    108e:	17 c0       	rjmp	.+46     	; 0x10be <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1090:	80 91 d7 01 	lds	r24, 0x01D7
    1094:	90 91 d8 01 	lds	r25, 0x01D8
    1098:	60 91 90 01 	lds	r22, 0x0190
    109c:	70 91 91 01 	lds	r23, 0x0191
    10a0:	6e 5f       	subi	r22, 0xFE	; 254
    10a2:	7f 4f       	sbci	r23, 0xFF	; 255
    10a4:	0e 94 c0 0f 	call	0x1f80	; 0x1f80 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    10a8:	80 91 97 01 	lds	r24, 0x0197
    10ac:	90 91 98 01 	lds	r25, 0x0198
    10b0:	c8 17       	cp	r28, r24
    10b2:	d9 07       	cpc	r29, r25
    10b4:	20 f4       	brcc	.+8      	; 0x10be <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
    10b6:	d0 93 98 01 	sts	0x0198, r29
    10ba:	c0 93 97 01 	sts	0x0197, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    10be:	df 91       	pop	r29
    10c0:	cf 91       	pop	r28
    10c2:	1f 91       	pop	r17
    10c4:	0f 91       	pop	r16
    10c6:	08 95       	ret

000010c8 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    10c8:	6f 92       	push	r6
    10ca:	7f 92       	push	r7
    10cc:	8f 92       	push	r8
    10ce:	9f 92       	push	r9
    10d0:	af 92       	push	r10
    10d2:	bf 92       	push	r11
    10d4:	cf 92       	push	r12
    10d6:	df 92       	push	r13
    10d8:	ef 92       	push	r14
    10da:	ff 92       	push	r15
    10dc:	0f 93       	push	r16
    10de:	1f 93       	push	r17
    10e0:	cf 93       	push	r28
    10e2:	df 93       	push	r29
    10e4:	5b 01       	movw	r10, r22
    10e6:	6c 01       	movw	r12, r24
    10e8:	39 01       	movw	r6, r18
    10ea:	4a 01       	movw	r8, r20
    10ec:	e8 01       	movw	r28, r16
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    10ee:	0f b6       	in	r0, 0x3f	; 63
    10f0:	f8 94       	cli
    10f2:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    10f4:	e0 91 90 01 	lds	r30, 0x0190
    10f8:	f0 91 91 01 	lds	r31, 0x0191
    10fc:	85 a1       	ldd	r24, Z+37	; 0x25
    10fe:	82 30       	cpi	r24, 0x02	; 2
    1100:	19 f1       	breq	.+70     	; 0x1148 <xTaskNotifyWait+0x80>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    1102:	e0 91 90 01 	lds	r30, 0x0190
    1106:	f0 91 91 01 	lds	r31, 0x0191
    110a:	81 a1       	ldd	r24, Z+33	; 0x21
    110c:	92 a1       	ldd	r25, Z+34	; 0x22
    110e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1110:	b4 a1       	ldd	r27, Z+36	; 0x24
    1112:	a0 94       	com	r10
    1114:	b0 94       	com	r11
    1116:	c0 94       	com	r12
    1118:	d0 94       	com	r13
    111a:	8a 21       	and	r24, r10
    111c:	9b 21       	and	r25, r11
    111e:	ac 21       	and	r26, r12
    1120:	bd 21       	and	r27, r13
    1122:	81 a3       	std	Z+33, r24	; 0x21
    1124:	92 a3       	std	Z+34, r25	; 0x22
    1126:	a3 a3       	std	Z+35, r26	; 0x23
    1128:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    112a:	e0 91 90 01 	lds	r30, 0x0190
    112e:	f0 91 91 01 	lds	r31, 0x0191
    1132:	81 e0       	ldi	r24, 0x01	; 1
    1134:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1136:	e1 14       	cp	r14, r1
    1138:	f1 04       	cpc	r15, r1
    113a:	31 f0       	breq	.+12     	; 0x1148 <xTaskNotifyWait+0x80>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    113c:	c7 01       	movw	r24, r14
    113e:	61 e0       	ldi	r22, 0x01	; 1
    1140:	0e 94 20 08 	call	0x1040	; 0x1040 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1144:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1148:	0f 90       	pop	r0
    114a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    114c:	0f b6       	in	r0, 0x3f	; 63
    114e:	f8 94       	cli
    1150:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1152:	20 97       	sbiw	r28, 0x00	; 0
    1154:	61 f0       	breq	.+24     	; 0x116e <xTaskNotifyWait+0xa6>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    1156:	e0 91 90 01 	lds	r30, 0x0190
    115a:	f0 91 91 01 	lds	r31, 0x0191
    115e:	81 a1       	ldd	r24, Z+33	; 0x21
    1160:	92 a1       	ldd	r25, Z+34	; 0x22
    1162:	a3 a1       	ldd	r26, Z+35	; 0x23
    1164:	b4 a1       	ldd	r27, Z+36	; 0x24
    1166:	88 83       	st	Y, r24
    1168:	99 83       	std	Y+1, r25	; 0x01
    116a:	aa 83       	std	Y+2, r26	; 0x02
    116c:	bb 83       	std	Y+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    116e:	e0 91 90 01 	lds	r30, 0x0190
    1172:	f0 91 91 01 	lds	r31, 0x0191
    1176:	85 a1       	ldd	r24, Z+37	; 0x25
    1178:	81 30       	cpi	r24, 0x01	; 1
    117a:	11 f4       	brne	.+4      	; 0x1180 <xTaskNotifyWait+0xb8>
    117c:	80 e0       	ldi	r24, 0x00	; 0
    117e:	15 c0       	rjmp	.+42     	; 0x11aa <xTaskNotifyWait+0xe2>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    1180:	e0 91 90 01 	lds	r30, 0x0190
    1184:	f0 91 91 01 	lds	r31, 0x0191
    1188:	81 a1       	ldd	r24, Z+33	; 0x21
    118a:	92 a1       	ldd	r25, Z+34	; 0x22
    118c:	a3 a1       	ldd	r26, Z+35	; 0x23
    118e:	b4 a1       	ldd	r27, Z+36	; 0x24
    1190:	60 94       	com	r6
    1192:	70 94       	com	r7
    1194:	80 94       	com	r8
    1196:	90 94       	com	r9
    1198:	86 21       	and	r24, r6
    119a:	97 21       	and	r25, r7
    119c:	a8 21       	and	r26, r8
    119e:	b9 21       	and	r27, r9
    11a0:	81 a3       	std	Z+33, r24	; 0x21
    11a2:	92 a3       	std	Z+34, r25	; 0x22
    11a4:	a3 a3       	std	Z+35, r26	; 0x23
    11a6:	b4 a3       	std	Z+36, r27	; 0x24
    11a8:	81 e0       	ldi	r24, 0x01	; 1
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    11aa:	e0 91 90 01 	lds	r30, 0x0190
    11ae:	f0 91 91 01 	lds	r31, 0x0191
    11b2:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    11b4:	0f 90       	pop	r0
    11b6:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    11b8:	df 91       	pop	r29
    11ba:	cf 91       	pop	r28
    11bc:	1f 91       	pop	r17
    11be:	0f 91       	pop	r16
    11c0:	ff 90       	pop	r15
    11c2:	ef 90       	pop	r14
    11c4:	df 90       	pop	r13
    11c6:	cf 90       	pop	r12
    11c8:	bf 90       	pop	r11
    11ca:	af 90       	pop	r10
    11cc:	9f 90       	pop	r9
    11ce:	8f 90       	pop	r8
    11d0:	7f 90       	pop	r7
    11d2:	6f 90       	pop	r6
    11d4:	08 95       	ret

000011d6 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    11d6:	1f 93       	push	r17
    11d8:	18 2f       	mov	r17, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    11da:	0f b6       	in	r0, 0x3f	; 63
    11dc:	f8 94       	cli
    11de:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    11e0:	e0 91 90 01 	lds	r30, 0x0190
    11e4:	f0 91 91 01 	lds	r31, 0x0191
    11e8:	81 a1       	ldd	r24, Z+33	; 0x21
    11ea:	92 a1       	ldd	r25, Z+34	; 0x22
    11ec:	a3 a1       	ldd	r26, Z+35	; 0x23
    11ee:	b4 a1       	ldd	r27, Z+36	; 0x24
    11f0:	00 97       	sbiw	r24, 0x00	; 0
    11f2:	a1 05       	cpc	r26, r1
    11f4:	b1 05       	cpc	r27, r1
    11f6:	79 f4       	brne	.+30     	; 0x1216 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    11f8:	e0 91 90 01 	lds	r30, 0x0190
    11fc:	f0 91 91 01 	lds	r31, 0x0191
    1200:	81 e0       	ldi	r24, 0x01	; 1
    1202:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1204:	61 15       	cp	r22, r1
    1206:	71 05       	cpc	r23, r1
    1208:	31 f0       	breq	.+12     	; 0x1216 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    120a:	cb 01       	movw	r24, r22
    120c:	61 e0       	ldi	r22, 0x01	; 1
    120e:	0e 94 20 08 	call	0x1040	; 0x1040 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1212:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1216:	0f 90       	pop	r0
    1218:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    121a:	0f b6       	in	r0, 0x3f	; 63
    121c:	f8 94       	cli
    121e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    1220:	e0 91 90 01 	lds	r30, 0x0190
    1224:	f0 91 91 01 	lds	r31, 0x0191
    1228:	21 a1       	ldd	r18, Z+33	; 0x21
    122a:	32 a1       	ldd	r19, Z+34	; 0x22
    122c:	43 a1       	ldd	r20, Z+35	; 0x23
    122e:	54 a1       	ldd	r21, Z+36	; 0x24

			if( ulReturn != 0UL )
    1230:	21 15       	cp	r18, r1
    1232:	31 05       	cpc	r19, r1
    1234:	41 05       	cpc	r20, r1
    1236:	51 05       	cpc	r21, r1
    1238:	d9 f0       	breq	.+54     	; 0x1270 <ulTaskNotifyTake+0x9a>
			{
				if( xClearCountOnExit != pdFALSE )
    123a:	11 23       	and	r17, r17
    123c:	49 f0       	breq	.+18     	; 0x1250 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    123e:	e0 91 90 01 	lds	r30, 0x0190
    1242:	f0 91 91 01 	lds	r31, 0x0191
    1246:	11 a2       	std	Z+33, r1	; 0x21
    1248:	12 a2       	std	Z+34, r1	; 0x22
    124a:	13 a2       	std	Z+35, r1	; 0x23
    124c:	14 a2       	std	Z+36, r1	; 0x24
    124e:	10 c0       	rjmp	.+32     	; 0x1270 <ulTaskNotifyTake+0x9a>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    1250:	e0 91 90 01 	lds	r30, 0x0190
    1254:	f0 91 91 01 	lds	r31, 0x0191
    1258:	21 50       	subi	r18, 0x01	; 1
    125a:	30 40       	sbci	r19, 0x00	; 0
    125c:	40 40       	sbci	r20, 0x00	; 0
    125e:	50 40       	sbci	r21, 0x00	; 0
    1260:	21 a3       	std	Z+33, r18	; 0x21
    1262:	32 a3       	std	Z+34, r19	; 0x22
    1264:	43 a3       	std	Z+35, r20	; 0x23
    1266:	54 a3       	std	Z+36, r21	; 0x24
    1268:	2f 5f       	subi	r18, 0xFF	; 255
    126a:	3f 4f       	sbci	r19, 0xFF	; 255
    126c:	4f 4f       	sbci	r20, 0xFF	; 255
    126e:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1270:	e0 91 90 01 	lds	r30, 0x0190
    1274:	f0 91 91 01 	lds	r31, 0x0191
    1278:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    127a:	0f 90       	pop	r0
    127c:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    127e:	b9 01       	movw	r22, r18
    1280:	ca 01       	movw	r24, r20
    1282:	1f 91       	pop	r17
    1284:	08 95       	ret

00001286 <vTaskPlaceOnUnorderedEventList>:
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    1286:	0f 93       	push	r16
    1288:	1f 93       	push	r17
    128a:	8a 01       	movw	r16, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    128c:	e0 91 90 01 	lds	r30, 0x0190
    1290:	f0 91 91 01 	lds	r31, 0x0191
    1294:	70 68       	ori	r23, 0x80	; 128
    1296:	75 87       	std	Z+13, r23	; 0x0d
    1298:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    129a:	60 91 90 01 	lds	r22, 0x0190
    129e:	70 91 91 01 	lds	r23, 0x0191
    12a2:	64 5f       	subi	r22, 0xF4	; 244
    12a4:	7f 4f       	sbci	r23, 0xFF	; 255
    12a6:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    12aa:	c8 01       	movw	r24, r16
    12ac:	61 e0       	ldi	r22, 0x01	; 1
    12ae:	0e 94 20 08 	call	0x1040	; 0x1040 <prvAddCurrentTaskToDelayedList>
}
    12b2:	1f 91       	pop	r17
    12b4:	0f 91       	pop	r16
    12b6:	08 95       	ret

000012b8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    12b8:	9c 01       	movw	r18, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    12ba:	00 97       	sbiw	r24, 0x00	; 0
    12bc:	69 f0       	breq	.+26     	; 0x12d8 <vTaskDelay+0x20>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    12be:	80 91 92 01 	lds	r24, 0x0192
    12c2:	8f 5f       	subi	r24, 0xFF	; 255
    12c4:	80 93 92 01 	sts	0x0192, r24
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    12c8:	c9 01       	movw	r24, r18
    12ca:	60 e0       	ldi	r22, 0x00	; 0
    12cc:	0e 94 20 08 	call	0x1040	; 0x1040 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    12d0:	0e 94 97 07 	call	0xf2e	; 0xf2e <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    12d4:	88 23       	and	r24, r24
    12d6:	11 f4       	brne	.+4      	; 0x12dc <vTaskDelay+0x24>
		{
			portYIELD_WITHIN_API();
    12d8:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
    12dc:	08 95       	ret

000012de <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    12de:	fc 01       	movw	r30, r24
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    12e0:	80 91 92 01 	lds	r24, 0x0192
    12e4:	8f 5f       	subi	r24, 0xFF	; 255
    12e6:	80 93 92 01 	sts	0x0192, r24

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    12ea:	40 91 95 01 	lds	r20, 0x0195
    12ee:	50 91 96 01 	lds	r21, 0x0196

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    12f2:	20 81       	ld	r18, Z
    12f4:	31 81       	ldd	r19, Z+1	; 0x01
    12f6:	62 0f       	add	r22, r18
    12f8:	73 1f       	adc	r23, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    12fa:	42 17       	cp	r20, r18
    12fc:	53 07       	cpc	r21, r19
    12fe:	28 f4       	brcc	.+10     	; 0x130a <vTaskDelayUntil+0x2c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1300:	62 17       	cp	r22, r18
    1302:	73 07       	cpc	r23, r19
    1304:	28 f0       	brcs	.+10     	; 0x1310 <vTaskDelayUntil+0x32>
    1306:	80 e0       	ldi	r24, 0x00	; 0
    1308:	08 c0       	rjmp	.+16     	; 0x131a <vTaskDelayUntil+0x3c>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    130a:	62 17       	cp	r22, r18
    130c:	73 07       	cpc	r23, r19
    130e:	20 f0       	brcs	.+8      	; 0x1318 <vTaskDelayUntil+0x3a>
    1310:	80 e0       	ldi	r24, 0x00	; 0
    1312:	46 17       	cp	r20, r22
    1314:	57 07       	cpc	r21, r23
    1316:	08 f4       	brcc	.+2      	; 0x131a <vTaskDelayUntil+0x3c>
    1318:	81 e0       	ldi	r24, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    131a:	71 83       	std	Z+1, r23	; 0x01
    131c:	60 83       	st	Z, r22

			if( xShouldDelay != pdFALSE )
    131e:	88 23       	and	r24, r24
    1320:	31 f0       	breq	.+12     	; 0x132e <vTaskDelayUntil+0x50>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1322:	cb 01       	movw	r24, r22
    1324:	84 1b       	sub	r24, r20
    1326:	95 0b       	sbc	r25, r21
    1328:	60 e0       	ldi	r22, 0x00	; 0
    132a:	0e 94 20 08 	call	0x1040	; 0x1040 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    132e:	0e 94 97 07 	call	0xf2e	; 0xf2e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1332:	88 23       	and	r24, r24
    1334:	11 f4       	brne	.+4      	; 0x133a <vTaskDelayUntil+0x5c>
		{
			portYIELD_WITHIN_API();
    1336:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
    133a:	08 95       	ret

0000133c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    133c:	0f 93       	push	r16
    133e:	1f 93       	push	r17
    1340:	8b 01       	movw	r16, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1342:	60 91 90 01 	lds	r22, 0x0190
    1346:	70 91 91 01 	lds	r23, 0x0191
    134a:	64 5f       	subi	r22, 0xF4	; 244
    134c:	7f 4f       	sbci	r23, 0xFF	; 255
    134e:	0e 94 c0 0f 	call	0x1f80	; 0x1f80 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1352:	c8 01       	movw	r24, r16
    1354:	61 e0       	ldi	r22, 0x01	; 1
    1356:	0e 94 20 08 	call	0x1040	; 0x1040 <prvAddCurrentTaskToDelayedList>
}
    135a:	1f 91       	pop	r17
    135c:	0f 91       	pop	r16
    135e:	08 95       	ret

00001360 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1360:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1362:	10 92 9c 01 	sts	0x019C, r1
	vPortEndScheduler();
    1366:	0e 94 9f 12 	call	0x253e	; 0x253e <vPortEndScheduler>
}
    136a:	08 95       	ret

0000136c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    136c:	0f 93       	push	r16
    136e:	1f 93       	push	r17
    1370:	2c c0       	rjmp	.+88     	; 0x13ca <prvIdleTask+0x5e>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1372:	80 91 92 01 	lds	r24, 0x0192
    1376:	8f 5f       	subi	r24, 0xFF	; 255
    1378:	80 93 92 01 	sts	0x0192, r24
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    137c:	10 91 e4 01 	lds	r17, 0x01E4
			}
			( void ) xTaskResumeAll();
    1380:	0e 94 97 07 	call	0xf2e	; 0xf2e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1384:	11 23       	and	r17, r17
    1386:	09 f1       	breq	.+66     	; 0x13ca <prvIdleTask+0x5e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1388:	0f b6       	in	r0, 0x3f	; 63
    138a:	f8 94       	cli
    138c:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    138e:	e0 91 e9 01 	lds	r30, 0x01E9
    1392:	f0 91 ea 01 	lds	r31, 0x01EA
    1396:	06 81       	ldd	r16, Z+6	; 0x06
    1398:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    139a:	c8 01       	movw	r24, r16
    139c:	02 96       	adiw	r24, 0x02	; 2
    139e:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
					--uxCurrentNumberOfTasks;
    13a2:	80 91 9b 01 	lds	r24, 0x019B
    13a6:	81 50       	subi	r24, 0x01	; 1
    13a8:	80 93 9b 01 	sts	0x019B, r24
					--uxDeletedTasksWaitingCleanUp;
    13ac:	80 91 9f 01 	lds	r24, 0x019F
    13b0:	81 50       	subi	r24, 0x01	; 1
    13b2:	80 93 9f 01 	sts	0x019F, r24
				}
				taskEXIT_CRITICAL();
    13b6:	0f 90       	pop	r0
    13b8:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    13ba:	f8 01       	movw	r30, r16
    13bc:	87 89       	ldd	r24, Z+23	; 0x17
    13be:	90 8d       	ldd	r25, Z+24	; 0x18
    13c0:	0e 94 db 11 	call	0x23b6	; 0x23b6 <vPortFree>
			vPortFree( pxTCB );
    13c4:	c8 01       	movw	r24, r16
    13c6:	0e 94 db 11 	call	0x23b6	; 0x23b6 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    13ca:	80 91 9f 01 	lds	r24, 0x019F
    13ce:	88 23       	and	r24, r24
    13d0:	81 f6       	brne	.-96     	; 0x1372 <prvIdleTask+0x6>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    13d2:	80 91 a1 01 	lds	r24, 0x01A1
    13d6:	82 30       	cpi	r24, 0x02	; 2
    13d8:	10 f0       	brcs	.+4      	; 0x13de <prvIdleTask+0x72>
			{
				taskYIELD();
    13da:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    13de:	0e 94 53 00 	call	0xa6	; 0xa6 <vApplicationIdleHook>
    13e2:	f3 cf       	rjmp	.-26     	; 0x13ca <prvIdleTask+0x5e>

000013e4 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    13e4:	0f 93       	push	r16
    13e6:	1f 93       	push	r17
    13e8:	cf 93       	push	r28
    13ea:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    13ec:	0f b6       	in	r0, 0x3f	; 63
    13ee:	f8 94       	cli
    13f0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    13f2:	00 97       	sbiw	r24, 0x00	; 0
    13f4:	29 f4       	brne	.+10     	; 0x1400 <vTaskDelete+0x1c>
    13f6:	c0 91 90 01 	lds	r28, 0x0190
    13fa:	d0 91 91 01 	lds	r29, 0x0191
    13fe:	01 c0       	rjmp	.+2      	; 0x1402 <vTaskDelete+0x1e>
    1400:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1402:	8e 01       	movw	r16, r28
    1404:	0e 5f       	subi	r16, 0xFE	; 254
    1406:	1f 4f       	sbci	r17, 0xFF	; 255
    1408:	c8 01       	movw	r24, r16
    140a:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    140e:	8c 89       	ldd	r24, Y+20	; 0x14
    1410:	9d 89       	ldd	r25, Y+21	; 0x15
    1412:	89 2b       	or	r24, r25
    1414:	21 f0       	breq	.+8      	; 0x141e <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1416:	ce 01       	movw	r24, r28
    1418:	0c 96       	adiw	r24, 0x0c	; 12
    141a:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    141e:	80 91 a0 01 	lds	r24, 0x01A0
    1422:	8f 5f       	subi	r24, 0xFF	; 255
    1424:	80 93 a0 01 	sts	0x01A0, r24

			if( pxTCB == pxCurrentTCB )
    1428:	80 91 90 01 	lds	r24, 0x0190
    142c:	90 91 91 01 	lds	r25, 0x0191
    1430:	c8 17       	cp	r28, r24
    1432:	d9 07       	cpc	r29, r25
    1434:	59 f4       	brne	.+22     	; 0x144c <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    1436:	84 ee       	ldi	r24, 0xE4	; 228
    1438:	91 e0       	ldi	r25, 0x01	; 1
    143a:	b8 01       	movw	r22, r16
    143c:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    1440:	80 91 9f 01 	lds	r24, 0x019F
    1444:	8f 5f       	subi	r24, 0xFF	; 255
    1446:	80 93 9f 01 	sts	0x019F, r24
    144a:	26 c0       	rjmp	.+76     	; 0x1498 <vTaskDelete+0xb4>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    144c:	80 91 9b 01 	lds	r24, 0x019B
    1450:	81 50       	subi	r24, 0x01	; 1
    1452:	80 93 9b 01 	sts	0x019B, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    1456:	8f 89       	ldd	r24, Y+23	; 0x17
    1458:	98 8d       	ldd	r25, Y+24	; 0x18
    145a:	0e 94 db 11 	call	0x23b6	; 0x23b6 <vPortFree>
			vPortFree( pxTCB );
    145e:	ce 01       	movw	r24, r28
    1460:	0e 94 db 11 	call	0x23b6	; 0x23b6 <vPortFree>

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1464:	e0 91 d7 01 	lds	r30, 0x01D7
    1468:	f0 91 d8 01 	lds	r31, 0x01D8
    146c:	80 81       	ld	r24, Z
    146e:	88 23       	and	r24, r24
    1470:	19 f4       	brne	.+6      	; 0x1478 <vTaskDelete+0x94>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1472:	8f ef       	ldi	r24, 0xFF	; 255
    1474:	9f ef       	ldi	r25, 0xFF	; 255
    1476:	0c c0       	rjmp	.+24     	; 0x1490 <vTaskDelete+0xac>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1478:	e0 91 d7 01 	lds	r30, 0x01D7
    147c:	f0 91 d8 01 	lds	r31, 0x01D8
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    1480:	05 80       	ldd	r0, Z+5	; 0x05
    1482:	f6 81       	ldd	r31, Z+6	; 0x06
    1484:	e0 2d       	mov	r30, r0
    1486:	06 80       	ldd	r0, Z+6	; 0x06
    1488:	f7 81       	ldd	r31, Z+7	; 0x07
    148a:	e0 2d       	mov	r30, r0
    148c:	82 81       	ldd	r24, Z+2	; 0x02
    148e:	93 81       	ldd	r25, Z+3	; 0x03
    1490:	90 93 98 01 	sts	0x0198, r25
    1494:	80 93 97 01 	sts	0x0197, r24
				prvResetNextTaskUnblockTime();
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1498:	0f 90       	pop	r0
    149a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    149c:	80 91 9c 01 	lds	r24, 0x019C
    14a0:	88 23       	and	r24, r24
    14a2:	49 f0       	breq	.+18     	; 0x14b6 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    14a4:	80 91 90 01 	lds	r24, 0x0190
    14a8:	90 91 91 01 	lds	r25, 0x0191
    14ac:	c8 17       	cp	r28, r24
    14ae:	d9 07       	cpc	r29, r25
    14b0:	11 f4       	brne	.+4      	; 0x14b6 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    14b2:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    14b6:	df 91       	pop	r29
    14b8:	cf 91       	pop	r28
    14ba:	1f 91       	pop	r17
    14bc:	0f 91       	pop	r16
    14be:	08 95       	ret

000014c0 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    14c0:	4f 92       	push	r4
    14c2:	5f 92       	push	r5
    14c4:	6f 92       	push	r6
    14c6:	7f 92       	push	r7
    14c8:	8f 92       	push	r8
    14ca:	9f 92       	push	r9
    14cc:	af 92       	push	r10
    14ce:	bf 92       	push	r11
    14d0:	cf 92       	push	r12
    14d2:	df 92       	push	r13
    14d4:	ef 92       	push	r14
    14d6:	ff 92       	push	r15
    14d8:	0f 93       	push	r16
    14da:	1f 93       	push	r17
    14dc:	cf 93       	push	r28
    14de:	df 93       	push	r29
    14e0:	2c 01       	movw	r4, r24
    14e2:	16 2f       	mov	r17, r22
    14e4:	97 2e       	mov	r9, r23
    14e6:	6a 01       	movw	r12, r20
    14e8:	39 01       	movw	r6, r18
    14ea:	57 01       	movw	r10, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    14ec:	ca 01       	movw	r24, r20
    14ee:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <pvPortMalloc>
    14f2:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    14f4:	00 97       	sbiw	r24, 0x00	; 0
    14f6:	99 f0       	breq	.+38     	; 0x151e <xTaskCreate+0x5e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    14f8:	86 e2       	ldi	r24, 0x26	; 38
    14fa:	90 e0       	ldi	r25, 0x00	; 0
    14fc:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <pvPortMalloc>
    1500:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
    1502:	00 97       	sbiw	r24, 0x00	; 0
    1504:	49 f0       	breq	.+18     	; 0x1518 <xTaskCreate+0x58>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    1506:	f8 8e       	std	Y+24, r15	; 0x18
    1508:	ef 8a       	std	Y+23, r14	; 0x17
    150a:	81 2f       	mov	r24, r17
    150c:	99 2d       	mov	r25, r9
    150e:	9c 01       	movw	r18, r24
    1510:	f9 01       	movw	r30, r18
    1512:	de 01       	movw	r26, r28
    1514:	90 e0       	ldi	r25, 0x00	; 0
    1516:	05 c0       	rjmp	.+10     	; 0x1522 <xTaskCreate+0x62>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    1518:	c7 01       	movw	r24, r14
    151a:	0e 94 db 11 	call	0x23b6	; 0x23b6 <vPortFree>
    151e:	8f ef       	ldi	r24, 0xFF	; 255
    1520:	b7 c0       	rjmp	.+366    	; 0x1690 <xTaskCreate+0x1d0>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1522:	80 81       	ld	r24, Z
    1524:	59 96       	adiw	r26, 0x19	; 25
    1526:	8c 93       	st	X, r24
    1528:	59 97       	sbiw	r26, 0x19	; 25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    152a:	80 81       	ld	r24, Z
    152c:	88 23       	and	r24, r24
    152e:	29 f0       	breq	.+10     	; 0x153a <xTaskCreate+0x7a>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1530:	9f 5f       	subi	r25, 0xFF	; 255
    1532:	31 96       	adiw	r30, 0x01	; 1
    1534:	11 96       	adiw	r26, 0x01	; 1
    1536:	98 30       	cpi	r25, 0x08	; 8
    1538:	a1 f7       	brne	.-24     	; 0x1522 <xTaskCreate+0x62>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    153a:	18 a2       	std	Y+32, r1	; 0x20
    153c:	04 30       	cpi	r16, 0x04	; 4
    153e:	08 f0       	brcs	.+2      	; 0x1542 <xTaskCreate+0x82>
    1540:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    1542:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1544:	72 e0       	ldi	r23, 0x02	; 2
    1546:	87 2e       	mov	r8, r23
    1548:	91 2c       	mov	r9, r1
    154a:	8c 0e       	add	r8, r28
    154c:	9d 1e       	adc	r9, r29
    154e:	c4 01       	movw	r24, r8
    1550:	0e 94 9d 0f 	call	0x1f3a	; 0x1f3a <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1554:	ce 01       	movw	r24, r28
    1556:	0c 96       	adiw	r24, 0x0c	; 12
    1558:	0e 94 9d 0f 	call	0x1f3a	; 0x1f3a <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    155c:	d9 87       	std	Y+9, r29	; 0x09
    155e:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1560:	84 e0       	ldi	r24, 0x04	; 4
    1562:	90 e0       	ldi	r25, 0x00	; 0
    1564:	80 1b       	sub	r24, r16
    1566:	91 09       	sbc	r25, r1
    1568:	9d 87       	std	Y+13, r25	; 0x0d
    156a:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    156c:	db 8b       	std	Y+19, r29	; 0x13
    156e:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    1570:	19 a2       	std	Y+33, r1	; 0x21
    1572:	1a a2       	std	Y+34, r1	; 0x22
    1574:	1b a2       	std	Y+35, r1	; 0x23
    1576:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1578:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    157a:	08 94       	sec
    157c:	c1 08       	sbc	r12, r1
    157e:	d1 08       	sbc	r13, r1
    1580:	c7 01       	movw	r24, r14
    1582:	8c 0d       	add	r24, r12
    1584:	9d 1d       	adc	r25, r13
    1586:	b2 01       	movw	r22, r4
    1588:	a3 01       	movw	r20, r6
    158a:	0e 94 1d 12 	call	0x243a	; 0x243a <pxPortInitialiseStack>
    158e:	99 83       	std	Y+1, r25	; 0x01
    1590:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    1592:	a1 14       	cp	r10, r1
    1594:	b1 04       	cpc	r11, r1
    1596:	19 f0       	breq	.+6      	; 0x159e <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1598:	f5 01       	movw	r30, r10
    159a:	d1 83       	std	Z+1, r29	; 0x01
    159c:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    159e:	0f b6       	in	r0, 0x3f	; 63
    15a0:	f8 94       	cli
    15a2:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    15a4:	80 91 9b 01 	lds	r24, 0x019B
    15a8:	8f 5f       	subi	r24, 0xFF	; 255
    15aa:	80 93 9b 01 	sts	0x019B, r24
		if( pxCurrentTCB == NULL )
    15ae:	80 91 90 01 	lds	r24, 0x0190
    15b2:	90 91 91 01 	lds	r25, 0x0191
    15b6:	89 2b       	or	r24, r25
    15b8:	a9 f5       	brne	.+106    	; 0x1624 <xTaskCreate+0x164>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    15ba:	d0 93 91 01 	sts	0x0191, r29
    15be:	c0 93 90 01 	sts	0x0190, r28

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    15c2:	80 91 9b 01 	lds	r24, 0x019B
    15c6:	81 30       	cpi	r24, 0x01	; 1
    15c8:	e9 f5       	brne	.+122    	; 0x1644 <xTaskCreate+0x184>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    15ca:	81 ea       	ldi	r24, 0xA1	; 161
    15cc:	91 e0       	ldi	r25, 0x01	; 1
    15ce:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
    15d2:	8a ea       	ldi	r24, 0xAA	; 170
    15d4:	91 e0       	ldi	r25, 0x01	; 1
    15d6:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
    15da:	83 eb       	ldi	r24, 0xB3	; 179
    15dc:	91 e0       	ldi	r25, 0x01	; 1
    15de:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
    15e2:	8c eb       	ldi	r24, 0xBC	; 188
    15e4:	91 e0       	ldi	r25, 0x01	; 1
    15e6:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    15ea:	65 ec       	ldi	r22, 0xC5	; 197
    15ec:	e6 2e       	mov	r14, r22
    15ee:	61 e0       	ldi	r22, 0x01	; 1
    15f0:	f6 2e       	mov	r15, r22
    15f2:	c7 01       	movw	r24, r14
    15f4:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    15f8:	0e ec       	ldi	r16, 0xCE	; 206
    15fa:	11 e0       	ldi	r17, 0x01	; 1
    15fc:	c8 01       	movw	r24, r16
    15fe:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1602:	8b ed       	ldi	r24, 0xDB	; 219
    1604:	91 e0       	ldi	r25, 0x01	; 1
    1606:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    160a:	84 ee       	ldi	r24, 0xE4	; 228
    160c:	91 e0       	ldi	r25, 0x01	; 1
    160e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1612:	f0 92 d8 01 	sts	0x01D8, r15
    1616:	e0 92 d7 01 	sts	0x01D7, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    161a:	10 93 da 01 	sts	0x01DA, r17
    161e:	00 93 d9 01 	sts	0x01D9, r16
    1622:	10 c0       	rjmp	.+32     	; 0x1644 <xTaskCreate+0x184>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    1624:	80 91 9c 01 	lds	r24, 0x019C
    1628:	88 23       	and	r24, r24
    162a:	61 f4       	brne	.+24     	; 0x1644 <xTaskCreate+0x184>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    162c:	e0 91 90 01 	lds	r30, 0x0190
    1630:	f0 91 91 01 	lds	r31, 0x0191
    1634:	96 89       	ldd	r25, Z+22	; 0x16
    1636:	8e 89       	ldd	r24, Y+22	; 0x16
    1638:	89 17       	cp	r24, r25
    163a:	20 f0       	brcs	.+8      	; 0x1644 <xTaskCreate+0x184>
				{
					pxCurrentTCB = pxNewTCB;
    163c:	d0 93 91 01 	sts	0x0191, r29
    1640:	c0 93 90 01 	sts	0x0190, r28
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    1644:	80 91 a0 01 	lds	r24, 0x01A0
    1648:	8f 5f       	subi	r24, 0xFF	; 255
    164a:	80 93 a0 01 	sts	0x01A0, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    164e:	9e 89       	ldd	r25, Y+22	; 0x16
    1650:	80 91 93 01 	lds	r24, 0x0193
    1654:	89 17       	cp	r24, r25
    1656:	10 f4       	brcc	.+4      	; 0x165c <xTaskCreate+0x19c>
    1658:	90 93 93 01 	sts	0x0193, r25
    165c:	89 e0       	ldi	r24, 0x09	; 9
    165e:	98 9f       	mul	r25, r24
    1660:	c0 01       	movw	r24, r0
    1662:	11 24       	eor	r1, r1
    1664:	8f 55       	subi	r24, 0x5F	; 95
    1666:	9e 4f       	sbci	r25, 0xFE	; 254
    1668:	b4 01       	movw	r22, r8
    166a:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    166e:	0f 90       	pop	r0
    1670:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1672:	80 91 9c 01 	lds	r24, 0x019C
    1676:	88 23       	and	r24, r24
    1678:	51 f0       	breq	.+20     	; 0x168e <xTaskCreate+0x1ce>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    167a:	e0 91 90 01 	lds	r30, 0x0190
    167e:	f0 91 91 01 	lds	r31, 0x0191
    1682:	96 89       	ldd	r25, Z+22	; 0x16
    1684:	8e 89       	ldd	r24, Y+22	; 0x16
    1686:	98 17       	cp	r25, r24
    1688:	10 f4       	brcc	.+4      	; 0x168e <xTaskCreate+0x1ce>
		{
			taskYIELD_IF_USING_PREEMPTION();
    168a:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
    168e:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    1690:	df 91       	pop	r29
    1692:	cf 91       	pop	r28
    1694:	1f 91       	pop	r17
    1696:	0f 91       	pop	r16
    1698:	ff 90       	pop	r15
    169a:	ef 90       	pop	r14
    169c:	df 90       	pop	r13
    169e:	cf 90       	pop	r12
    16a0:	bf 90       	pop	r11
    16a2:	af 90       	pop	r10
    16a4:	9f 90       	pop	r9
    16a6:	8f 90       	pop	r8
    16a8:	7f 90       	pop	r7
    16aa:	6f 90       	pop	r6
    16ac:	5f 90       	pop	r5
    16ae:	4f 90       	pop	r4
    16b0:	08 95       	ret

000016b2 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    16b2:	ef 92       	push	r14
    16b4:	ff 92       	push	r15
    16b6:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    16b8:	86 eb       	ldi	r24, 0xB6	; 182
    16ba:	99 e0       	ldi	r25, 0x09	; 9
    16bc:	6b e2       	ldi	r22, 0x2B	; 43
    16be:	71 e0       	ldi	r23, 0x01	; 1
    16c0:	45 e5       	ldi	r20, 0x55	; 85
    16c2:	50 e0       	ldi	r21, 0x00	; 0
    16c4:	20 e0       	ldi	r18, 0x00	; 0
    16c6:	30 e0       	ldi	r19, 0x00	; 0
    16c8:	00 e0       	ldi	r16, 0x00	; 0
    16ca:	ed e9       	ldi	r30, 0x9D	; 157
    16cc:	ee 2e       	mov	r14, r30
    16ce:	e1 e0       	ldi	r30, 0x01	; 1
    16d0:	fe 2e       	mov	r15, r30
    16d2:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    16d6:	81 30       	cpi	r24, 0x01	; 1
    16d8:	81 f4       	brne	.+32     	; 0x16fa <vTaskStartScheduler+0x48>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    16da:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    16dc:	8f ef       	ldi	r24, 0xFF	; 255
    16de:	9f ef       	ldi	r25, 0xFF	; 255
    16e0:	90 93 98 01 	sts	0x0198, r25
    16e4:	80 93 97 01 	sts	0x0197, r24
		xSchedulerRunning = pdTRUE;
    16e8:	81 e0       	ldi	r24, 0x01	; 1
    16ea:	80 93 9c 01 	sts	0x019C, r24
		xTickCount = ( TickType_t ) 0U;
    16ee:	10 92 96 01 	sts	0x0196, r1
    16f2:	10 92 95 01 	sts	0x0195, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    16f6:	0e 94 65 12 	call	0x24ca	; 0x24ca <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    16fa:	0f 91       	pop	r16
    16fc:	ff 90       	pop	r15
    16fe:	ef 90       	pop	r14
    1700:	08 95       	ret

00001702 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1702:	0f b6       	in	r0, 0x3f	; 63
    1704:	f8 94       	cli
    1706:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1708:	fc 01       	movw	r30, r24
    170a:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    170c:	0f 90       	pop	r0
    170e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1710:	08 95       	ret

00001712 <uxQueueSpacesAvailable>:
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    1712:	fc 01       	movw	r30, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1714:	0f b6       	in	r0, 0x3f	; 63
    1716:	f8 94       	cli
    1718:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    171a:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    171c:	0f 90       	pop	r0
    171e:	0f be       	out	0x3f, r0	; 63
    1720:	83 8d       	ldd	r24, Z+27	; 0x1b

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1722:	89 1b       	sub	r24, r25
    1724:	08 95       	ret

00001726 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1726:	fc 01       	movw	r30, r24
    1728:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    172a:	08 95       	ret

0000172c <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    172c:	fc 01       	movw	r30, r24
    172e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	88 23       	and	r24, r24
    1734:	09 f4       	brne	.+2      	; 0x1738 <xQueueIsQueueEmptyFromISR+0xc>
    1736:	91 e0       	ldi	r25, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1738:	89 2f       	mov	r24, r25
    173a:	08 95       	ret

0000173c <xQueueIsQueueFullFromISR>:
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    173c:	fc 01       	movw	r30, r24
    173e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1740:	20 e0       	ldi	r18, 0x00	; 0
    1742:	83 8d       	ldd	r24, Z+27	; 0x1b
    1744:	98 17       	cp	r25, r24
    1746:	09 f4       	brne	.+2      	; 0x174a <xQueueIsQueueFullFromISR+0xe>
    1748:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    174a:	82 2f       	mov	r24, r18
    174c:	08 95       	ret

0000174e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    174e:	0f 93       	push	r16
    1750:	1f 93       	push	r17
    1752:	cf 93       	push	r28
    1754:	df 93       	push	r29
    1756:	ec 01       	movw	r28, r24
    1758:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    175a:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    175c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    175e:	44 23       	and	r20, r20
    1760:	c1 f1       	breq	.+112    	; 0x17d2 <prvCopyDataToQueue+0x84>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1762:	00 23       	and	r16, r16
    1764:	b1 f4       	brne	.+44     	; 0x1792 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1766:	8c 81       	ldd	r24, Y+4	; 0x04
    1768:	9d 81       	ldd	r25, Y+5	; 0x05
    176a:	50 e0       	ldi	r21, 0x00	; 0
    176c:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1770:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1772:	2c 81       	ldd	r18, Y+4	; 0x04
    1774:	3d 81       	ldd	r19, Y+5	; 0x05
    1776:	28 0f       	add	r18, r24
    1778:	31 1d       	adc	r19, r1
    177a:	3d 83       	std	Y+5, r19	; 0x05
    177c:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    177e:	8a 81       	ldd	r24, Y+2	; 0x02
    1780:	9b 81       	ldd	r25, Y+3	; 0x03
    1782:	28 17       	cp	r18, r24
    1784:	39 07       	cpc	r19, r25
    1786:	28 f1       	brcs	.+74     	; 0x17d2 <prvCopyDataToQueue+0x84>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1788:	88 81       	ld	r24, Y
    178a:	99 81       	ldd	r25, Y+1	; 0x01
    178c:	9d 83       	std	Y+5, r25	; 0x05
    178e:	8c 83       	std	Y+4, r24	; 0x04
    1790:	20 c0       	rjmp	.+64     	; 0x17d2 <prvCopyDataToQueue+0x84>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1792:	8e 81       	ldd	r24, Y+6	; 0x06
    1794:	9f 81       	ldd	r25, Y+7	; 0x07
    1796:	50 e0       	ldi	r21, 0x00	; 0
    1798:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    179c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    179e:	90 e0       	ldi	r25, 0x00	; 0
    17a0:	44 27       	eor	r20, r20
    17a2:	55 27       	eor	r21, r21
    17a4:	48 1b       	sub	r20, r24
    17a6:	59 0b       	sbc	r21, r25
    17a8:	8e 81       	ldd	r24, Y+6	; 0x06
    17aa:	9f 81       	ldd	r25, Y+7	; 0x07
    17ac:	84 0f       	add	r24, r20
    17ae:	95 1f       	adc	r25, r21
    17b0:	9f 83       	std	Y+7, r25	; 0x07
    17b2:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    17b4:	28 81       	ld	r18, Y
    17b6:	39 81       	ldd	r19, Y+1	; 0x01
    17b8:	82 17       	cp	r24, r18
    17ba:	93 07       	cpc	r25, r19
    17bc:	30 f4       	brcc	.+12     	; 0x17ca <prvCopyDataToQueue+0x7c>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    17be:	8a 81       	ldd	r24, Y+2	; 0x02
    17c0:	9b 81       	ldd	r25, Y+3	; 0x03
    17c2:	84 0f       	add	r24, r20
    17c4:	95 1f       	adc	r25, r21
    17c6:	9f 83       	std	Y+7, r25	; 0x07
    17c8:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    17ca:	02 30       	cpi	r16, 0x02	; 2
    17cc:	11 f4       	brne	.+4      	; 0x17d2 <prvCopyDataToQueue+0x84>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    17ce:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    17d0:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    17d2:	1f 5f       	subi	r17, 0xFF	; 255
    17d4:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    17d6:	80 e0       	ldi	r24, 0x00	; 0
    17d8:	df 91       	pop	r29
    17da:	cf 91       	pop	r28
    17dc:	1f 91       	pop	r17
    17de:	0f 91       	pop	r16
    17e0:	08 95       	ret

000017e2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    17e2:	fc 01       	movw	r30, r24
    17e4:	56 2f       	mov	r21, r22
    17e6:	a7 2f       	mov	r26, r23
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    17e8:	24 8d       	ldd	r18, Z+28	; 0x1c
    17ea:	22 23       	and	r18, r18
    17ec:	b9 f0       	breq	.+46     	; 0x181c <prvCopyDataFromQueue+0x3a>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    17ee:	86 81       	ldd	r24, Z+6	; 0x06
    17f0:	97 81       	ldd	r25, Z+7	; 0x07
    17f2:	82 0f       	add	r24, r18
    17f4:	91 1d       	adc	r25, r1
    17f6:	97 83       	std	Z+7, r25	; 0x07
    17f8:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    17fa:	22 81       	ldd	r18, Z+2	; 0x02
    17fc:	33 81       	ldd	r19, Z+3	; 0x03
    17fe:	82 17       	cp	r24, r18
    1800:	93 07       	cpc	r25, r19
    1802:	20 f0       	brcs	.+8      	; 0x180c <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1804:	80 81       	ld	r24, Z
    1806:	91 81       	ldd	r25, Z+1	; 0x01
    1808:	97 83       	std	Z+7, r25	; 0x07
    180a:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    180c:	44 8d       	ldd	r20, Z+28	; 0x1c
    180e:	66 81       	ldd	r22, Z+6	; 0x06
    1810:	77 81       	ldd	r23, Z+7	; 0x07
    1812:	85 2f       	mov	r24, r21
    1814:	9a 2f       	mov	r25, r26
    1816:	50 e0       	ldi	r21, 0x00	; 0
    1818:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <memcpy>
    181c:	08 95       	ret

0000181e <xQueuePeekFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    181e:	0f 93       	push	r16
    1820:	1f 93       	push	r17
    1822:	cf 93       	push	r28
    1824:	df 93       	push	r29
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1826:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1828:	8a 8d       	ldd	r24, Y+26	; 0x1a
    182a:	88 23       	and	r24, r24
    182c:	41 f0       	breq	.+16     	; 0x183e <xQueuePeekFromISR+0x20>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    182e:	0e 81       	ldd	r16, Y+6	; 0x06
    1830:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1832:	ce 01       	movw	r24, r28
    1834:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1838:	1f 83       	std	Y+7, r17	; 0x07
    183a:	0e 83       	std	Y+6, r16	; 0x06
    183c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    183e:	df 91       	pop	r29
    1840:	cf 91       	pop	r28
    1842:	1f 91       	pop	r17
    1844:	0f 91       	pop	r16
    1846:	08 95       	ret

00001848 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1848:	0f 93       	push	r16
    184a:	1f 93       	push	r17
    184c:	cf 93       	push	r28
    184e:	df 93       	push	r29
    1850:	fb 01       	movw	r30, r22
    1852:	8a 01       	movw	r16, r20
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1854:	ec 01       	movw	r28, r24

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1856:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1858:	88 23       	and	r24, r24
    185a:	61 f1       	breq	.+88     	; 0x18b4 <xQueueCRReceiveFromISR+0x6c>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    185c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    185e:	2e 81       	ldd	r18, Y+6	; 0x06
    1860:	3f 81       	ldd	r19, Y+7	; 0x07
    1862:	28 0f       	add	r18, r24
    1864:	31 1d       	adc	r19, r1
    1866:	3f 83       	std	Y+7, r19	; 0x07
    1868:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    186a:	8a 81       	ldd	r24, Y+2	; 0x02
    186c:	9b 81       	ldd	r25, Y+3	; 0x03
    186e:	28 17       	cp	r18, r24
    1870:	39 07       	cpc	r19, r25
    1872:	20 f0       	brcs	.+8      	; 0x187c <xQueueCRReceiveFromISR+0x34>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1874:	88 81       	ld	r24, Y
    1876:	99 81       	ldd	r25, Y+1	; 0x01
    1878:	9f 83       	std	Y+7, r25	; 0x07
    187a:	8e 83       	std	Y+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    187c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    187e:	81 50       	subi	r24, 0x01	; 1
    1880:	8a 8f       	std	Y+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1882:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1884:	6e 81       	ldd	r22, Y+6	; 0x06
    1886:	7f 81       	ldd	r23, Y+7	; 0x07
    1888:	cf 01       	movw	r24, r30
    188a:	50 e0       	ldi	r21, 0x00	; 0
    188c:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1890:	f8 01       	movw	r30, r16
    1892:	80 81       	ld	r24, Z
    1894:	88 23       	and	r24, r24
    1896:	69 f4       	brne	.+26     	; 0x18b2 <xQueueCRReceiveFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1898:	88 85       	ldd	r24, Y+8	; 0x08
    189a:	88 23       	and	r24, r24
    189c:	51 f0       	breq	.+20     	; 0x18b2 <xQueueCRReceiveFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    189e:	ce 01       	movw	r24, r28
    18a0:	08 96       	adiw	r24, 0x08	; 8
    18a2:	0e 94 1c 10 	call	0x2038	; 0x2038 <xCoRoutineRemoveFromEventList>
    18a6:	88 23       	and	r24, r24
    18a8:	21 f0       	breq	.+8      	; 0x18b2 <xQueueCRReceiveFromISR+0x6a>
					{
						*pxCoRoutineWoken = pdTRUE;
    18aa:	81 e0       	ldi	r24, 0x01	; 1
    18ac:	f8 01       	movw	r30, r16
    18ae:	80 83       	st	Z, r24
    18b0:	01 c0       	rjmp	.+2      	; 0x18b4 <xQueueCRReceiveFromISR+0x6c>
    18b2:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    18b4:	df 91       	pop	r29
    18b6:	cf 91       	pop	r28
    18b8:	1f 91       	pop	r17
    18ba:	0f 91       	pop	r16
    18bc:	08 95       	ret

000018be <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    18be:	1f 93       	push	r17
    18c0:	cf 93       	push	r28
    18c2:	df 93       	push	r29
    18c4:	14 2f       	mov	r17, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    18c6:	ec 01       	movw	r28, r24

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    18c8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18ca:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18cc:	98 17       	cp	r25, r24
    18ce:	88 f4       	brcc	.+34     	; 0x18f2 <xQueueCRSendFromISR+0x34>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    18d0:	ce 01       	movw	r24, r28
    18d2:	40 e0       	ldi	r20, 0x00	; 0
    18d4:	0e 94 a7 0b 	call	0x174e	; 0x174e <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    18d8:	11 23       	and	r17, r17
    18da:	59 f4       	brne	.+22     	; 0x18f2 <xQueueCRSendFromISR+0x34>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18dc:	89 89       	ldd	r24, Y+17	; 0x11
    18de:	88 23       	and	r24, r24
    18e0:	41 f0       	breq	.+16     	; 0x18f2 <xQueueCRSendFromISR+0x34>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18e2:	ce 01       	movw	r24, r28
    18e4:	41 96       	adiw	r24, 0x11	; 17
    18e6:	0e 94 1c 10 	call	0x2038	; 0x2038 <xCoRoutineRemoveFromEventList>
    18ea:	48 2f       	mov	r20, r24
    18ec:	81 11       	cpse	r24, r1
    18ee:	41 e0       	ldi	r20, 0x01	; 1
    18f0:	14 2f       	mov	r17, r20
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    18f2:	81 2f       	mov	r24, r17
    18f4:	df 91       	pop	r29
    18f6:	cf 91       	pop	r28
    18f8:	1f 91       	pop	r17
    18fa:	08 95       	ret

000018fc <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    18fc:	cf 93       	push	r28
    18fe:	df 93       	push	r29
    1900:	fb 01       	movw	r30, r22
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1902:	ec 01       	movw	r28, r24

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1904:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1906:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1908:	88 23       	and	r24, r24
    190a:	71 f4       	brne	.+28     	; 0x1928 <xQueueCRReceive+0x2c>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    190c:	41 15       	cp	r20, r1
    190e:	51 05       	cpc	r21, r1
    1910:	41 f0       	breq	.+16     	; 0x1922 <xQueueCRReceive+0x26>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1912:	61 96       	adiw	r28, 0x11	; 17
    1914:	ca 01       	movw	r24, r20
    1916:	be 01       	movw	r22, r28
    1918:	0e 94 24 11 	call	0x2248	; 0x2248 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    191c:	78 94       	sei
    191e:	8c ef       	ldi	r24, 0xFC	; 252
    1920:	2f c0       	rjmp	.+94     	; 0x1980 <xQueueCRReceive+0x84>
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
    1922:	78 94       	sei
    1924:	80 e0       	ldi	r24, 0x00	; 0
    1926:	2c c0       	rjmp	.+88     	; 0x1980 <xQueueCRReceive+0x84>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1928:	78 94       	sei

		portDISABLE_INTERRUPTS();
    192a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    192c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    192e:	88 23       	and	r24, r24
    1930:	31 f1       	breq	.+76     	; 0x197e <xQueueCRReceive+0x82>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1932:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1934:	2e 81       	ldd	r18, Y+6	; 0x06
    1936:	3f 81       	ldd	r19, Y+7	; 0x07
    1938:	28 0f       	add	r18, r24
    193a:	31 1d       	adc	r19, r1
    193c:	3f 83       	std	Y+7, r19	; 0x07
    193e:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1940:	8a 81       	ldd	r24, Y+2	; 0x02
    1942:	9b 81       	ldd	r25, Y+3	; 0x03
    1944:	28 17       	cp	r18, r24
    1946:	39 07       	cpc	r19, r25
    1948:	20 f0       	brcs	.+8      	; 0x1952 <xQueueCRReceive+0x56>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    194a:	88 81       	ld	r24, Y
    194c:	99 81       	ldd	r25, Y+1	; 0x01
    194e:	9f 83       	std	Y+7, r25	; 0x07
    1950:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1952:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1954:	81 50       	subi	r24, 0x01	; 1
    1956:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1958:	4c 8d       	ldd	r20, Y+28	; 0x1c
    195a:	6e 81       	ldd	r22, Y+6	; 0x06
    195c:	7f 81       	ldd	r23, Y+7	; 0x07
    195e:	cf 01       	movw	r24, r30
    1960:	50 e0       	ldi	r21, 0x00	; 0
    1962:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1966:	88 85       	ldd	r24, Y+8	; 0x08
    1968:	88 23       	and	r24, r24
    196a:	41 f0       	breq	.+16     	; 0x197c <xQueueCRReceive+0x80>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    196c:	ce 01       	movw	r24, r28
    196e:	08 96       	adiw	r24, 0x08	; 8
    1970:	0e 94 1c 10 	call	0x2038	; 0x2038 <xCoRoutineRemoveFromEventList>
    1974:	88 23       	and	r24, r24
    1976:	11 f0       	breq	.+4      	; 0x197c <xQueueCRReceive+0x80>
    1978:	8b ef       	ldi	r24, 0xFB	; 251
    197a:	01 c0       	rjmp	.+2      	; 0x197e <xQueueCRReceive+0x82>
    197c:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    197e:	78 94       	sei

		return xReturn;
	}
    1980:	df 91       	pop	r29
    1982:	cf 91       	pop	r28
    1984:	08 95       	ret

00001986 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1986:	cf 93       	push	r28
    1988:	df 93       	push	r29
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    198a:	ec 01       	movw	r28, r24

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    198c:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    198e:	0f b6       	in	r0, 0x3f	; 63
    1990:	f8 94       	cli
    1992:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1994:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1996:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1998:	0f 90       	pop	r0
    199a:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    199c:	89 17       	cp	r24, r25
    199e:	71 f4       	brne	.+28     	; 0x19bc <xQueueCRSend+0x36>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    19a0:	41 15       	cp	r20, r1
    19a2:	51 05       	cpc	r21, r1
    19a4:	41 f0       	breq	.+16     	; 0x19b6 <xQueueCRSend+0x30>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    19a6:	28 96       	adiw	r28, 0x08	; 8
    19a8:	ca 01       	movw	r24, r20
    19aa:	be 01       	movw	r22, r28
    19ac:	0e 94 24 11 	call	0x2248	; 0x2248 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    19b0:	78 94       	sei
    19b2:	8c ef       	ldi	r24, 0xFC	; 252
    19b4:	1b c0       	rjmp	.+54     	; 0x19ec <xQueueCRSend+0x66>
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
    19b6:	78 94       	sei
    19b8:	80 e0       	ldi	r24, 0x00	; 0
    19ba:	18 c0       	rjmp	.+48     	; 0x19ec <xQueueCRSend+0x66>
					return errQUEUE_FULL;
				}
			}
		}
		portENABLE_INTERRUPTS();
    19bc:	78 94       	sei

		portDISABLE_INTERRUPTS();
    19be:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    19c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19c2:	89 17       	cp	r24, r25
    19c4:	10 f0       	brcs	.+4      	; 0x19ca <xQueueCRSend+0x44>
    19c6:	80 e0       	ldi	r24, 0x00	; 0
    19c8:	10 c0       	rjmp	.+32     	; 0x19ea <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    19ca:	ce 01       	movw	r24, r28
    19cc:	40 e0       	ldi	r20, 0x00	; 0
    19ce:	0e 94 a7 0b 	call	0x174e	; 0x174e <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19d2:	89 89       	ldd	r24, Y+17	; 0x11
    19d4:	88 23       	and	r24, r24
    19d6:	41 f0       	breq	.+16     	; 0x19e8 <xQueueCRSend+0x62>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19d8:	ce 01       	movw	r24, r28
    19da:	41 96       	adiw	r24, 0x11	; 17
    19dc:	0e 94 1c 10 	call	0x2038	; 0x2038 <xCoRoutineRemoveFromEventList>
    19e0:	88 23       	and	r24, r24
    19e2:	11 f0       	breq	.+4      	; 0x19e8 <xQueueCRSend+0x62>
    19e4:	8b ef       	ldi	r24, 0xFB	; 251
    19e6:	01 c0       	rjmp	.+2      	; 0x19ea <xQueueCRSend+0x64>
    19e8:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    19ea:	78 94       	sei

		return xReturn;
	}
    19ec:	df 91       	pop	r29
    19ee:	cf 91       	pop	r28
    19f0:	08 95       	ret

000019f2 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    19f2:	0e 94 db 11 	call	0x23b6	; 0x23b6 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    19f6:	08 95       	ret

000019f8 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    19f8:	ef 92       	push	r14
    19fa:	ff 92       	push	r15
    19fc:	0f 93       	push	r16
    19fe:	1f 93       	push	r17
    1a00:	cf 93       	push	r28
    1a02:	df 93       	push	r29
    1a04:	7a 01       	movw	r14, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1a06:	ec 01       	movw	r28, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a08:	1a 8d       	ldd	r17, Y+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a0a:	11 23       	and	r17, r17
    1a0c:	11 f4       	brne	.+4      	; 0x1a12 <xQueueReceiveFromISR+0x1a>
    1a0e:	80 e0       	ldi	r24, 0x00	; 0
    1a10:	1a c0       	rjmp	.+52     	; 0x1a46 <xQueueReceiveFromISR+0x4e>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1a12:	0d 8d       	ldd	r16, Y+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a14:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1a18:	11 50       	subi	r17, 0x01	; 1
    1a1a:	1a 8f       	std	Y+26, r17	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1a1c:	0f 3f       	cpi	r16, 0xFF	; 255
    1a1e:	81 f4       	brne	.+32     	; 0x1a40 <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a20:	88 85       	ldd	r24, Y+8	; 0x08
    1a22:	88 23       	and	r24, r24
    1a24:	79 f0       	breq	.+30     	; 0x1a44 <xQueueReceiveFromISR+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a26:	ce 01       	movw	r24, r28
    1a28:	08 96       	adiw	r24, 0x08	; 8
    1a2a:	0e 94 24 06 	call	0xc48	; 0xc48 <xTaskRemoveFromEventList>
    1a2e:	88 23       	and	r24, r24
    1a30:	49 f0       	breq	.+18     	; 0x1a44 <xQueueReceiveFromISR+0x4c>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1a32:	e1 14       	cp	r14, r1
    1a34:	f1 04       	cpc	r15, r1
    1a36:	31 f0       	breq	.+12     	; 0x1a44 <xQueueReceiveFromISR+0x4c>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1a38:	81 e0       	ldi	r24, 0x01	; 1
    1a3a:	f7 01       	movw	r30, r14
    1a3c:	80 83       	st	Z, r24
    1a3e:	03 c0       	rjmp	.+6      	; 0x1a46 <xQueueReceiveFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1a40:	0f 5f       	subi	r16, 0xFF	; 255
    1a42:	0d 8f       	std	Y+29, r16	; 0x1d
    1a44:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a46:	df 91       	pop	r29
    1a48:	cf 91       	pop	r28
    1a4a:	1f 91       	pop	r17
    1a4c:	0f 91       	pop	r16
    1a4e:	ff 90       	pop	r15
    1a50:	ef 90       	pop	r14
    1a52:	08 95       	ret

00001a54 <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1a54:	cf 93       	push	r28
    1a56:	df 93       	push	r29
    1a58:	eb 01       	movw	r28, r22
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1a5a:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a5c:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1a5e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a60:	98 17       	cp	r25, r24
    1a62:	10 f0       	brcs	.+4      	; 0x1a68 <xQueueGiveFromISR+0x14>
    1a64:	80 e0       	ldi	r24, 0x00	; 0
    1a66:	16 c0       	rjmp	.+44     	; 0x1a94 <xQueueGiveFromISR+0x40>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1a68:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    1a6a:	9f 5f       	subi	r25, 0xFF	; 255
    1a6c:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1a6e:	8f 3f       	cpi	r24, 0xFF	; 255
    1a70:	71 f4       	brne	.+28     	; 0x1a8e <xQueueGiveFromISR+0x3a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a72:	81 89       	ldd	r24, Z+17	; 0x11
    1a74:	88 23       	and	r24, r24
    1a76:	69 f0       	breq	.+26     	; 0x1a92 <xQueueGiveFromISR+0x3e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a78:	cf 01       	movw	r24, r30
    1a7a:	41 96       	adiw	r24, 0x11	; 17
    1a7c:	0e 94 24 06 	call	0xc48	; 0xc48 <xTaskRemoveFromEventList>
    1a80:	88 23       	and	r24, r24
    1a82:	39 f0       	breq	.+14     	; 0x1a92 <xQueueGiveFromISR+0x3e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1a84:	20 97       	sbiw	r28, 0x00	; 0
    1a86:	29 f0       	breq	.+10     	; 0x1a92 <xQueueGiveFromISR+0x3e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1a88:	81 e0       	ldi	r24, 0x01	; 1
    1a8a:	88 83       	st	Y, r24
    1a8c:	03 c0       	rjmp	.+6      	; 0x1a94 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1a8e:	8f 5f       	subi	r24, 0xFF	; 255
    1a90:	86 8f       	std	Z+30, r24	; 0x1e
    1a92:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a94:	df 91       	pop	r29
    1a96:	cf 91       	pop	r28
    1a98:	08 95       	ret

00001a9a <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1a9a:	ef 92       	push	r14
    1a9c:	ff 92       	push	r15
    1a9e:	1f 93       	push	r17
    1aa0:	cf 93       	push	r28
    1aa2:	df 93       	push	r29
    1aa4:	7a 01       	movw	r14, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1aa6:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1aa8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1aaa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1aac:	98 17       	cp	r25, r24
    1aae:	20 f0       	brcs	.+8      	; 0x1ab8 <xQueueGenericSendFromISR+0x1e>
    1ab0:	22 30       	cpi	r18, 0x02	; 2
    1ab2:	11 f0       	breq	.+4      	; 0x1ab8 <xQueueGenericSendFromISR+0x1e>
    1ab4:	80 e0       	ldi	r24, 0x00	; 0
    1ab6:	1a c0       	rjmp	.+52     	; 0x1aec <xQueueGenericSendFromISR+0x52>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1ab8:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1aba:	ce 01       	movw	r24, r28
    1abc:	42 2f       	mov	r20, r18
    1abe:	0e 94 a7 0b 	call	0x174e	; 0x174e <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1ac2:	1f 3f       	cpi	r17, 0xFF	; 255
    1ac4:	81 f4       	brne	.+32     	; 0x1ae6 <xQueueGenericSendFromISR+0x4c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ac6:	89 89       	ldd	r24, Y+17	; 0x11
    1ac8:	88 23       	and	r24, r24
    1aca:	79 f0       	breq	.+30     	; 0x1aea <xQueueGenericSendFromISR+0x50>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1acc:	ce 01       	movw	r24, r28
    1ace:	41 96       	adiw	r24, 0x11	; 17
    1ad0:	0e 94 24 06 	call	0xc48	; 0xc48 <xTaskRemoveFromEventList>
    1ad4:	88 23       	and	r24, r24
    1ad6:	49 f0       	breq	.+18     	; 0x1aea <xQueueGenericSendFromISR+0x50>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1ad8:	e1 14       	cp	r14, r1
    1ada:	f1 04       	cpc	r15, r1
    1adc:	31 f0       	breq	.+12     	; 0x1aea <xQueueGenericSendFromISR+0x50>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1ade:	81 e0       	ldi	r24, 0x01	; 1
    1ae0:	f7 01       	movw	r30, r14
    1ae2:	80 83       	st	Z, r24
    1ae4:	03 c0       	rjmp	.+6      	; 0x1aec <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1ae6:	1f 5f       	subi	r17, 0xFF	; 255
    1ae8:	1e 8f       	std	Y+30, r17	; 0x1e
    1aea:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1aec:	df 91       	pop	r29
    1aee:	cf 91       	pop	r28
    1af0:	1f 91       	pop	r17
    1af2:	ff 90       	pop	r15
    1af4:	ef 90       	pop	r14
    1af6:	08 95       	ret

00001af8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1af8:	ef 92       	push	r14
    1afa:	ff 92       	push	r15
    1afc:	1f 93       	push	r17
    1afe:	cf 93       	push	r28
    1b00:	df 93       	push	r29
    1b02:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1b04:	0f b6       	in	r0, 0x3f	; 63
    1b06:	f8 94       	cli
    1b08:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1b0a:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b0c:	91 e1       	ldi	r25, 0x11	; 17
    1b0e:	e9 2e       	mov	r14, r25
    1b10:	f1 2c       	mov	r15, r1
    1b12:	ec 0e       	add	r14, r28
    1b14:	fd 1e       	adc	r15, r29
    1b16:	0b c0       	rjmp	.+22     	; 0x1b2e <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b18:	89 89       	ldd	r24, Y+17	; 0x11
    1b1a:	88 23       	and	r24, r24
    1b1c:	51 f0       	breq	.+20     	; 0x1b32 <prvUnlockQueue+0x3a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b1e:	c7 01       	movw	r24, r14
    1b20:	0e 94 24 06 	call	0xc48	; 0xc48 <xTaskRemoveFromEventList>
    1b24:	88 23       	and	r24, r24
    1b26:	11 f0       	breq	.+4      	; 0x1b2c <prvUnlockQueue+0x34>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1b28:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    1b2c:	11 50       	subi	r17, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1b2e:	11 16       	cp	r1, r17
    1b30:	9c f3       	brlt	.-26     	; 0x1b18 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1b32:	8f ef       	ldi	r24, 0xFF	; 255
    1b34:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1b36:	0f 90       	pop	r0
    1b38:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1b3a:	0f b6       	in	r0, 0x3f	; 63
    1b3c:	f8 94       	cli
    1b3e:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1b40:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b42:	88 e0       	ldi	r24, 0x08	; 8
    1b44:	e8 2e       	mov	r14, r24
    1b46:	f1 2c       	mov	r15, r1
    1b48:	ec 0e       	add	r14, r28
    1b4a:	fd 1e       	adc	r15, r29
    1b4c:	0b c0       	rjmp	.+22     	; 0x1b64 <prvUnlockQueue+0x6c>
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b4e:	88 85       	ldd	r24, Y+8	; 0x08
    1b50:	88 23       	and	r24, r24
    1b52:	51 f0       	breq	.+20     	; 0x1b68 <prvUnlockQueue+0x70>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b54:	c7 01       	movw	r24, r14
    1b56:	0e 94 24 06 	call	0xc48	; 0xc48 <xTaskRemoveFromEventList>
    1b5a:	88 23       	and	r24, r24
    1b5c:	11 f0       	breq	.+4      	; 0x1b62 <prvUnlockQueue+0x6a>
				{
					vTaskMissedYield();
    1b5e:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    1b62:	11 50       	subi	r17, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1b64:	11 16       	cp	r1, r17
    1b66:	9c f3       	brlt	.-26     	; 0x1b4e <prvUnlockQueue+0x56>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1b68:	8f ef       	ldi	r24, 0xFF	; 255
    1b6a:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1b6c:	0f 90       	pop	r0
    1b6e:	0f be       	out	0x3f, r0	; 63
}
    1b70:	df 91       	pop	r29
    1b72:	cf 91       	pop	r28
    1b74:	1f 91       	pop	r17
    1b76:	ff 90       	pop	r15
    1b78:	ef 90       	pop	r14
    1b7a:	08 95       	ret

00001b7c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1b7c:	6f 92       	push	r6
    1b7e:	7f 92       	push	r7
    1b80:	8f 92       	push	r8
    1b82:	9f 92       	push	r9
    1b84:	af 92       	push	r10
    1b86:	bf 92       	push	r11
    1b88:	cf 92       	push	r12
    1b8a:	df 92       	push	r13
    1b8c:	ef 92       	push	r14
    1b8e:	ff 92       	push	r15
    1b90:	0f 93       	push	r16
    1b92:	1f 93       	push	r17
    1b94:	df 93       	push	r29
    1b96:	cf 93       	push	r28
    1b98:	00 d0       	rcall	.+0      	; 0x1b9a <xQueueGenericReceive+0x1e>
    1b9a:	00 d0       	rcall	.+0      	; 0x1b9c <xQueueGenericReceive+0x20>
    1b9c:	0f 92       	push	r0
    1b9e:	cd b7       	in	r28, 0x3d	; 61
    1ba0:	de b7       	in	r29, 0x3e	; 62
    1ba2:	4b 01       	movw	r8, r22
    1ba4:	5d 83       	std	Y+5, r21	; 0x05
    1ba6:	4c 83       	std	Y+4, r20	; 0x04
    1ba8:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1baa:	8c 01       	movw	r16, r24
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1bac:	41 e1       	ldi	r20, 0x11	; 17
    1bae:	a4 2e       	mov	r10, r20
    1bb0:	b1 2c       	mov	r11, r1
    1bb2:	a8 0e       	add	r10, r24
    1bb4:	b9 1e       	adc	r11, r25
    1bb6:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1bb8:	6e 01       	movw	r12, r28
    1bba:	08 94       	sec
    1bbc:	c1 1c       	adc	r12, r1
    1bbe:	d1 1c       	adc	r13, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1bc0:	34 e0       	ldi	r19, 0x04	; 4
    1bc2:	63 2e       	mov	r6, r19
    1bc4:	71 2c       	mov	r7, r1
    1bc6:	6c 0e       	add	r6, r28
    1bc8:	7d 1e       	adc	r7, r29
    1bca:	01 c0       	rjmp	.+2      	; 0x1bce <xQueueGenericReceive+0x52>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1bcc:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1bce:	0f b6       	in	r0, 0x3f	; 63
    1bd0:	f8 94       	cli
    1bd2:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1bd4:	f8 01       	movw	r30, r16
    1bd6:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1bd8:	ff 20       	and	r15, r15
    1bda:	11 f1       	breq	.+68     	; 0x1c20 <xQueueGenericReceive+0xa4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1bdc:	c6 80       	ldd	r12, Z+6	; 0x06
    1bde:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1be0:	c8 01       	movw	r24, r16
    1be2:	b4 01       	movw	r22, r8
    1be4:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1be8:	ee 20       	and	r14, r14
    1bea:	49 f4       	brne	.+18     	; 0x1bfe <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1bec:	fa 94       	dec	r15
    1bee:	f8 01       	movw	r30, r16
    1bf0:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1bf2:	80 85       	ldd	r24, Z+8	; 0x08
    1bf4:	88 23       	and	r24, r24
    1bf6:	81 f0       	breq	.+32     	; 0x1c18 <xQueueGenericReceive+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bf8:	c8 01       	movw	r24, r16
    1bfa:	08 96       	adiw	r24, 0x08	; 8
    1bfc:	07 c0       	rjmp	.+14     	; 0x1c0c <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1bfe:	f8 01       	movw	r30, r16
    1c00:	d7 82       	std	Z+7, r13	; 0x07
    1c02:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c04:	81 89       	ldd	r24, Z+17	; 0x11
    1c06:	88 23       	and	r24, r24
    1c08:	39 f0       	breq	.+14     	; 0x1c18 <xQueueGenericReceive+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c0a:	c5 01       	movw	r24, r10
    1c0c:	0e 94 24 06 	call	0xc48	; 0xc48 <xTaskRemoveFromEventList>
    1c10:	88 23       	and	r24, r24
    1c12:	11 f0       	breq	.+4      	; 0x1c18 <xQueueGenericReceive+0x9c>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1c14:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1c18:	0f 90       	pop	r0
    1c1a:	0f be       	out	0x3f, r0	; 63
    1c1c:	81 e0       	ldi	r24, 0x01	; 1
    1c1e:	54 c0       	rjmp	.+168    	; 0x1cc8 <xQueueGenericReceive+0x14c>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1c20:	8c 81       	ldd	r24, Y+4	; 0x04
    1c22:	9d 81       	ldd	r25, Y+5	; 0x05
    1c24:	89 2b       	or	r24, r25
    1c26:	21 f4       	brne	.+8      	; 0x1c30 <xQueueGenericReceive+0xb4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1c28:	0f 90       	pop	r0
    1c2a:	0f be       	out	0x3f, r0	; 63
    1c2c:	80 e0       	ldi	r24, 0x00	; 0
    1c2e:	4c c0       	rjmp	.+152    	; 0x1cc8 <xQueueGenericReceive+0x14c>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1c30:	22 23       	and	r18, r18
    1c32:	19 f4       	brne	.+6      	; 0x1c3a <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c34:	c6 01       	movw	r24, r12
    1c36:	0e 94 b4 04 	call	0x968	; 0x968 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1c3a:	0f 90       	pop	r0
    1c3c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c3e:	0e 94 55 04 	call	0x8aa	; 0x8aa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c42:	0f b6       	in	r0, 0x3f	; 63
    1c44:	f8 94       	cli
    1c46:	0f 92       	push	r0
    1c48:	f8 01       	movw	r30, r16
    1c4a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c4c:	8f 3f       	cpi	r24, 0xFF	; 255
    1c4e:	09 f4       	brne	.+2      	; 0x1c52 <xQueueGenericReceive+0xd6>
    1c50:	15 8e       	std	Z+29, r1	; 0x1d
    1c52:	f8 01       	movw	r30, r16
    1c54:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c56:	8f 3f       	cpi	r24, 0xFF	; 255
    1c58:	09 f4       	brne	.+2      	; 0x1c5c <xQueueGenericReceive+0xe0>
    1c5a:	16 8e       	std	Z+30, r1	; 0x1e
    1c5c:	0f 90       	pop	r0
    1c5e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c60:	c6 01       	movw	r24, r12
    1c62:	b3 01       	movw	r22, r6
    1c64:	0e 94 bf 04 	call	0x97e	; 0x97e <xTaskCheckForTimeOut>
    1c68:	88 23       	and	r24, r24
    1c6a:	f9 f4       	brne	.+62     	; 0x1caa <xQueueGenericReceive+0x12e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1c6c:	0f b6       	in	r0, 0x3f	; 63
    1c6e:	f8 94       	cli
    1c70:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1c72:	f8 01       	movw	r30, r16
    1c74:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1c76:	0f 90       	pop	r0
    1c78:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c7a:	88 23       	and	r24, r24
    1c7c:	81 f4       	brne	.+32     	; 0x1c9e <xQueueGenericReceive+0x122>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c7e:	6c 81       	ldd	r22, Y+4	; 0x04
    1c80:	7d 81       	ldd	r23, Y+5	; 0x05
    1c82:	c5 01       	movw	r24, r10
    1c84:	0e 94 9e 09 	call	0x133c	; 0x133c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c88:	c8 01       	movw	r24, r16
    1c8a:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c8e:	0e 94 97 07 	call	0xf2e	; 0xf2e <xTaskResumeAll>
    1c92:	88 23       	and	r24, r24
    1c94:	09 f0       	breq	.+2      	; 0x1c98 <xQueueGenericReceive+0x11c>
    1c96:	9a cf       	rjmp	.-204    	; 0x1bcc <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    1c98:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
    1c9c:	97 cf       	rjmp	.-210    	; 0x1bcc <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1c9e:	c8 01       	movw	r24, r16
    1ca0:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ca4:	0e 94 97 07 	call	0xf2e	; 0xf2e <xTaskResumeAll>
    1ca8:	91 cf       	rjmp	.-222    	; 0x1bcc <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1caa:	c8 01       	movw	r24, r16
    1cac:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1cb0:	0e 94 97 07 	call	0xf2e	; 0xf2e <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1cb4:	0f b6       	in	r0, 0x3f	; 63
    1cb6:	f8 94       	cli
    1cb8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1cba:	f8 01       	movw	r30, r16
    1cbc:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1cbe:	0f 90       	pop	r0
    1cc0:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1cc2:	88 23       	and	r24, r24
    1cc4:	09 f0       	breq	.+2      	; 0x1cc8 <xQueueGenericReceive+0x14c>
    1cc6:	82 cf       	rjmp	.-252    	; 0x1bcc <xQueueGenericReceive+0x50>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1cc8:	0f 90       	pop	r0
    1cca:	0f 90       	pop	r0
    1ccc:	0f 90       	pop	r0
    1cce:	0f 90       	pop	r0
    1cd0:	0f 90       	pop	r0
    1cd2:	cf 91       	pop	r28
    1cd4:	df 91       	pop	r29
    1cd6:	1f 91       	pop	r17
    1cd8:	0f 91       	pop	r16
    1cda:	ff 90       	pop	r15
    1cdc:	ef 90       	pop	r14
    1cde:	df 90       	pop	r13
    1ce0:	cf 90       	pop	r12
    1ce2:	bf 90       	pop	r11
    1ce4:	af 90       	pop	r10
    1ce6:	9f 90       	pop	r9
    1ce8:	8f 90       	pop	r8
    1cea:	7f 90       	pop	r7
    1cec:	6f 90       	pop	r6
    1cee:	08 95       	ret

00001cf0 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1cf0:	6f 92       	push	r6
    1cf2:	7f 92       	push	r7
    1cf4:	9f 92       	push	r9
    1cf6:	af 92       	push	r10
    1cf8:	bf 92       	push	r11
    1cfa:	cf 92       	push	r12
    1cfc:	df 92       	push	r13
    1cfe:	ef 92       	push	r14
    1d00:	ff 92       	push	r15
    1d02:	0f 93       	push	r16
    1d04:	1f 93       	push	r17
    1d06:	df 93       	push	r29
    1d08:	cf 93       	push	r28
    1d0a:	00 d0       	rcall	.+0      	; 0x1d0c <xQueueGenericSend+0x1c>
    1d0c:	00 d0       	rcall	.+0      	; 0x1d0e <xQueueGenericSend+0x1e>
    1d0e:	0f 92       	push	r0
    1d10:	cd b7       	in	r28, 0x3d	; 61
    1d12:	de b7       	in	r29, 0x3e	; 62
    1d14:	6b 01       	movw	r12, r22
    1d16:	5d 83       	std	Y+5, r21	; 0x05
    1d18:	4c 83       	std	Y+4, r20	; 0x04
    1d1a:	92 2e       	mov	r9, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1d1c:	8c 01       	movw	r16, r24
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1d1e:	68 e0       	ldi	r22, 0x08	; 8
    1d20:	e6 2e       	mov	r14, r22
    1d22:	f1 2c       	mov	r15, r1
    1d24:	e8 0e       	add	r14, r24
    1d26:	f9 1e       	adc	r15, r25
    1d28:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1d2a:	5e 01       	movw	r10, r28
    1d2c:	08 94       	sec
    1d2e:	a1 1c       	adc	r10, r1
    1d30:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d32:	54 e0       	ldi	r21, 0x04	; 4
    1d34:	65 2e       	mov	r6, r21
    1d36:	71 2c       	mov	r7, r1
    1d38:	6c 0e       	add	r6, r28
    1d3a:	7d 1e       	adc	r7, r29
    1d3c:	01 c0       	rjmp	.+2      	; 0x1d40 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1d3e:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1d40:	0f b6       	in	r0, 0x3f	; 63
    1d42:	f8 94       	cli
    1d44:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1d46:	f8 01       	movw	r30, r16
    1d48:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d4a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d4c:	98 17       	cp	r25, r24
    1d4e:	18 f0       	brcs	.+6      	; 0x1d56 <xQueueGenericSend+0x66>
    1d50:	f2 e0       	ldi	r31, 0x02	; 2
    1d52:	9f 16       	cp	r9, r31
    1d54:	c9 f4       	brne	.+50     	; 0x1d88 <xQueueGenericSend+0x98>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1d56:	c8 01       	movw	r24, r16
    1d58:	b6 01       	movw	r22, r12
    1d5a:	49 2d       	mov	r20, r9
    1d5c:	0e 94 a7 0b 	call	0x174e	; 0x174e <prvCopyDataToQueue>
    1d60:	98 2f       	mov	r25, r24
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d62:	f8 01       	movw	r30, r16
    1d64:	81 89       	ldd	r24, Z+17	; 0x11
    1d66:	88 23       	and	r24, r24
    1d68:	39 f0       	breq	.+14     	; 0x1d78 <xQueueGenericSend+0x88>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d6a:	c8 01       	movw	r24, r16
    1d6c:	41 96       	adiw	r24, 0x11	; 17
    1d6e:	0e 94 24 06 	call	0xc48	; 0xc48 <xTaskRemoveFromEventList>
    1d72:	88 23       	and	r24, r24
    1d74:	29 f0       	breq	.+10     	; 0x1d80 <xQueueGenericSend+0x90>
    1d76:	02 c0       	rjmp	.+4      	; 0x1d7c <xQueueGenericSend+0x8c>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1d78:	99 23       	and	r25, r25
    1d7a:	11 f0       	breq	.+4      	; 0x1d80 <xQueueGenericSend+0x90>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1d7c:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1d80:	0f 90       	pop	r0
    1d82:	0f be       	out	0x3f, r0	; 63
    1d84:	81 e0       	ldi	r24, 0x01	; 1
    1d86:	4c c0       	rjmp	.+152    	; 0x1e20 <xQueueGenericSend+0x130>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1d88:	8c 81       	ldd	r24, Y+4	; 0x04
    1d8a:	9d 81       	ldd	r25, Y+5	; 0x05
    1d8c:	89 2b       	or	r24, r25
    1d8e:	19 f4       	brne	.+6      	; 0x1d96 <xQueueGenericSend+0xa6>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1d90:	0f 90       	pop	r0
    1d92:	0f be       	out	0x3f, r0	; 63
    1d94:	44 c0       	rjmp	.+136    	; 0x1e1e <xQueueGenericSend+0x12e>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1d96:	22 23       	and	r18, r18
    1d98:	19 f4       	brne	.+6      	; 0x1da0 <xQueueGenericSend+0xb0>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1d9a:	c5 01       	movw	r24, r10
    1d9c:	0e 94 b4 04 	call	0x968	; 0x968 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1da0:	0f 90       	pop	r0
    1da2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1da4:	0e 94 55 04 	call	0x8aa	; 0x8aa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1da8:	0f b6       	in	r0, 0x3f	; 63
    1daa:	f8 94       	cli
    1dac:	0f 92       	push	r0
    1dae:	f8 01       	movw	r30, r16
    1db0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1db2:	8f 3f       	cpi	r24, 0xFF	; 255
    1db4:	09 f4       	brne	.+2      	; 0x1db8 <xQueueGenericSend+0xc8>
    1db6:	15 8e       	std	Z+29, r1	; 0x1d
    1db8:	f8 01       	movw	r30, r16
    1dba:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dbc:	8f 3f       	cpi	r24, 0xFF	; 255
    1dbe:	09 f4       	brne	.+2      	; 0x1dc2 <xQueueGenericSend+0xd2>
    1dc0:	16 8e       	std	Z+30, r1	; 0x1e
    1dc2:	0f 90       	pop	r0
    1dc4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1dc6:	c5 01       	movw	r24, r10
    1dc8:	b3 01       	movw	r22, r6
    1dca:	0e 94 bf 04 	call	0x97e	; 0x97e <xTaskCheckForTimeOut>
    1dce:	88 23       	and	r24, r24
    1dd0:	09 f5       	brne	.+66     	; 0x1e14 <xQueueGenericSend+0x124>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1dd2:	0f b6       	in	r0, 0x3f	; 63
    1dd4:	f8 94       	cli
    1dd6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1dd8:	f8 01       	movw	r30, r16
    1dda:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1ddc:	0f 90       	pop	r0
    1dde:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1de0:	f8 01       	movw	r30, r16
    1de2:	83 8d       	ldd	r24, Z+27	; 0x1b
    1de4:	98 17       	cp	r25, r24
    1de6:	81 f4       	brne	.+32     	; 0x1e08 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1de8:	6c 81       	ldd	r22, Y+4	; 0x04
    1dea:	7d 81       	ldd	r23, Y+5	; 0x05
    1dec:	c7 01       	movw	r24, r14
    1dee:	0e 94 9e 09 	call	0x133c	; 0x133c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1df2:	c8 01       	movw	r24, r16
    1df4:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1df8:	0e 94 97 07 	call	0xf2e	; 0xf2e <xTaskResumeAll>
    1dfc:	88 23       	and	r24, r24
    1dfe:	09 f0       	breq	.+2      	; 0x1e02 <xQueueGenericSend+0x112>
    1e00:	9e cf       	rjmp	.-196    	; 0x1d3e <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    1e02:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
    1e06:	9b cf       	rjmp	.-202    	; 0x1d3e <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1e08:	c8 01       	movw	r24, r16
    1e0a:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1e0e:	0e 94 97 07 	call	0xf2e	; 0xf2e <xTaskResumeAll>
    1e12:	95 cf       	rjmp	.-214    	; 0x1d3e <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1e14:	c8 01       	movw	r24, r16
    1e16:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1e1a:	0e 94 97 07 	call	0xf2e	; 0xf2e <xTaskResumeAll>
    1e1e:	80 e0       	ldi	r24, 0x00	; 0

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    1e20:	0f 90       	pop	r0
    1e22:	0f 90       	pop	r0
    1e24:	0f 90       	pop	r0
    1e26:	0f 90       	pop	r0
    1e28:	0f 90       	pop	r0
    1e2a:	cf 91       	pop	r28
    1e2c:	df 91       	pop	r29
    1e2e:	1f 91       	pop	r17
    1e30:	0f 91       	pop	r16
    1e32:	ff 90       	pop	r15
    1e34:	ef 90       	pop	r14
    1e36:	df 90       	pop	r13
    1e38:	cf 90       	pop	r12
    1e3a:	bf 90       	pop	r11
    1e3c:	af 90       	pop	r10
    1e3e:	9f 90       	pop	r9
    1e40:	7f 90       	pop	r7
    1e42:	6f 90       	pop	r6
    1e44:	08 95       	ret

00001e46 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1e46:	cf 93       	push	r28
    1e48:	df 93       	push	r29
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1e4a:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1e4c:	0f b6       	in	r0, 0x3f	; 63
    1e4e:	f8 94       	cli
    1e50:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1e52:	ec 8d       	ldd	r30, Y+28	; 0x1c
    1e54:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1e56:	e2 9f       	mul	r30, r18
    1e58:	c0 01       	movw	r24, r0
    1e5a:	11 24       	eor	r1, r1
    1e5c:	48 81       	ld	r20, Y
    1e5e:	59 81       	ldd	r21, Y+1	; 0x01
    1e60:	84 0f       	add	r24, r20
    1e62:	95 1f       	adc	r25, r21
    1e64:	9b 83       	std	Y+3, r25	; 0x03
    1e66:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1e68:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1e6a:	5d 83       	std	Y+5, r21	; 0x05
    1e6c:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1e6e:	30 e0       	ldi	r19, 0x00	; 0
    1e70:	21 50       	subi	r18, 0x01	; 1
    1e72:	30 40       	sbci	r19, 0x00	; 0
    1e74:	f0 e0       	ldi	r31, 0x00	; 0
    1e76:	2e 9f       	mul	r18, r30
    1e78:	c0 01       	movw	r24, r0
    1e7a:	2f 9f       	mul	r18, r31
    1e7c:	90 0d       	add	r25, r0
    1e7e:	3e 9f       	mul	r19, r30
    1e80:	90 0d       	add	r25, r0
    1e82:	11 24       	eor	r1, r1
    1e84:	48 0f       	add	r20, r24
    1e86:	59 1f       	adc	r21, r25
    1e88:	5f 83       	std	Y+7, r21	; 0x07
    1e8a:	4e 83       	std	Y+6, r20	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1e8c:	8f ef       	ldi	r24, 0xFF	; 255
    1e8e:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1e90:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1e92:	66 23       	and	r22, r22
    1e94:	61 f4       	brne	.+24     	; 0x1eae <xQueueGenericReset+0x68>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e96:	88 85       	ldd	r24, Y+8	; 0x08
    1e98:	88 23       	and	r24, r24
    1e9a:	89 f0       	breq	.+34     	; 0x1ebe <xQueueGenericReset+0x78>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e9c:	ce 01       	movw	r24, r28
    1e9e:	08 96       	adiw	r24, 0x08	; 8
    1ea0:	0e 94 24 06 	call	0xc48	; 0xc48 <xTaskRemoveFromEventList>
    1ea4:	88 23       	and	r24, r24
    1ea6:	59 f0       	breq	.+22     	; 0x1ebe <xQueueGenericReset+0x78>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1ea8:	0e 94 00 13 	call	0x2600	; 0x2600 <vPortYield>
    1eac:	08 c0       	rjmp	.+16     	; 0x1ebe <xQueueGenericReset+0x78>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1eae:	ce 01       	movw	r24, r28
    1eb0:	08 96       	adiw	r24, 0x08	; 8
    1eb2:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1eb6:	ce 01       	movw	r24, r28
    1eb8:	41 96       	adiw	r24, 0x11	; 17
    1eba:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1ebe:	0f 90       	pop	r0
    1ec0:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1ec2:	81 e0       	ldi	r24, 0x01	; 1
    1ec4:	df 91       	pop	r29
    1ec6:	cf 91       	pop	r28
    1ec8:	08 95       	ret

00001eca <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1eca:	0f 93       	push	r16
    1ecc:	1f 93       	push	r17
    1ece:	cf 93       	push	r28
    1ed0:	df 93       	push	r29
    1ed2:	08 2f       	mov	r16, r24
    1ed4:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1ed6:	66 23       	and	r22, r22
    1ed8:	19 f4       	brne	.+6      	; 0x1ee0 <xQueueGenericCreate+0x16>
    1eda:	80 e0       	ldi	r24, 0x00	; 0
    1edc:	90 e0       	ldi	r25, 0x00	; 0
    1ede:	03 c0       	rjmp	.+6      	; 0x1ee6 <xQueueGenericCreate+0x1c>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1ee0:	68 9f       	mul	r22, r24
    1ee2:	c0 01       	movw	r24, r0
    1ee4:	11 24       	eor	r1, r1
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    1ee6:	4f 96       	adiw	r24, 0x1f	; 31
    1ee8:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <pvPortMalloc>
    1eec:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1eee:	00 97       	sbiw	r24, 0x00	; 0
    1ef0:	71 f0       	breq	.+28     	; 0x1f0e <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1ef2:	11 23       	and	r17, r17
    1ef4:	19 f4       	brne	.+6      	; 0x1efc <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1ef6:	99 83       	std	Y+1, r25	; 0x01
    1ef8:	88 83       	st	Y, r24
    1efa:	03 c0       	rjmp	.+6      	; 0x1f02 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1efc:	4f 96       	adiw	r24, 0x1f	; 31
    1efe:	99 83       	std	Y+1, r25	; 0x01
    1f00:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1f02:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1f04:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1f06:	ce 01       	movw	r24, r28
    1f08:	61 e0       	ldi	r22, 0x01	; 1
    1f0a:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <xQueueGenericReset>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
    1f0e:	ce 01       	movw	r24, r28
    1f10:	df 91       	pop	r29
    1f12:	cf 91       	pop	r28
    1f14:	1f 91       	pop	r17
    1f16:	0f 91       	pop	r16
    1f18:	08 95       	ret

00001f1a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1f1a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1f1c:	9c 01       	movw	r18, r24
    1f1e:	2d 5f       	subi	r18, 0xFD	; 253
    1f20:	3f 4f       	sbci	r19, 0xFF	; 255
    1f22:	32 83       	std	Z+2, r19	; 0x02
    1f24:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1f26:	8f ef       	ldi	r24, 0xFF	; 255
    1f28:	9f ef       	ldi	r25, 0xFF	; 255
    1f2a:	94 83       	std	Z+4, r25	; 0x04
    1f2c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1f2e:	36 83       	std	Z+6, r19	; 0x06
    1f30:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1f32:	30 87       	std	Z+8, r19	; 0x08
    1f34:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1f36:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1f38:	08 95       	ret

00001f3a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1f3a:	fc 01       	movw	r30, r24
    1f3c:	11 86       	std	Z+9, r1	; 0x09
    1f3e:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1f40:	08 95       	ret

00001f42 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1f42:	ac 01       	movw	r20, r24
ListItem_t * const pxIndex = pxList->pxIndex;
    1f44:	fc 01       	movw	r30, r24
    1f46:	a1 81       	ldd	r26, Z+1	; 0x01
    1f48:	b2 81       	ldd	r27, Z+2	; 0x02
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1f4a:	fb 01       	movw	r30, r22
    1f4c:	b3 83       	std	Z+3, r27	; 0x03
    1f4e:	a2 83       	std	Z+2, r26	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1f50:	14 96       	adiw	r26, 0x04	; 4
    1f52:	8d 91       	ld	r24, X+
    1f54:	9c 91       	ld	r25, X
    1f56:	15 97       	sbiw	r26, 0x05	; 5
    1f58:	95 83       	std	Z+5, r25	; 0x05
    1f5a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1f5c:	14 96       	adiw	r26, 0x04	; 4
    1f5e:	ed 91       	ld	r30, X+
    1f60:	fc 91       	ld	r31, X
    1f62:	15 97       	sbiw	r26, 0x05	; 5
    1f64:	73 83       	std	Z+3, r23	; 0x03
    1f66:	62 83       	std	Z+2, r22	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1f68:	15 96       	adiw	r26, 0x05	; 5
    1f6a:	7c 93       	st	X, r23
    1f6c:	6e 93       	st	-X, r22
    1f6e:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1f70:	fb 01       	movw	r30, r22
    1f72:	51 87       	std	Z+9, r21	; 0x09
    1f74:	40 87       	std	Z+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    1f76:	fa 01       	movw	r30, r20
    1f78:	80 81       	ld	r24, Z
    1f7a:	8f 5f       	subi	r24, 0xFF	; 255
    1f7c:	80 83       	st	Z, r24
}
    1f7e:	08 95       	ret

00001f80 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1f80:	cf 93       	push	r28
    1f82:	df 93       	push	r29
    1f84:	9c 01       	movw	r18, r24
    1f86:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1f88:	48 81       	ld	r20, Y
    1f8a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1f8c:	8f ef       	ldi	r24, 0xFF	; 255
    1f8e:	4f 3f       	cpi	r20, 0xFF	; 255
    1f90:	58 07       	cpc	r21, r24
    1f92:	21 f4       	brne	.+8      	; 0x1f9c <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1f94:	f9 01       	movw	r30, r18
    1f96:	a7 81       	ldd	r26, Z+7	; 0x07
    1f98:	b0 85       	ldd	r27, Z+8	; 0x08
    1f9a:	0d c0       	rjmp	.+26     	; 0x1fb6 <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1f9c:	d9 01       	movw	r26, r18
    1f9e:	13 96       	adiw	r26, 0x03	; 3
    1fa0:	12 96       	adiw	r26, 0x02	; 2
    1fa2:	ed 91       	ld	r30, X+
    1fa4:	fc 91       	ld	r31, X
    1fa6:	13 97       	sbiw	r26, 0x03	; 3
    1fa8:	80 81       	ld	r24, Z
    1faa:	91 81       	ldd	r25, Z+1	; 0x01
    1fac:	48 17       	cp	r20, r24
    1fae:	59 07       	cpc	r21, r25
    1fb0:	10 f0       	brcs	.+4      	; 0x1fb6 <vListInsert+0x36>
    1fb2:	df 01       	movw	r26, r30
    1fb4:	f5 cf       	rjmp	.-22     	; 0x1fa0 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1fb6:	12 96       	adiw	r26, 0x02	; 2
    1fb8:	ed 91       	ld	r30, X+
    1fba:	fc 91       	ld	r31, X
    1fbc:	13 97       	sbiw	r26, 0x03	; 3
    1fbe:	fb 83       	std	Y+3, r31	; 0x03
    1fc0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1fc2:	d5 83       	std	Z+5, r29	; 0x05
    1fc4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1fc6:	bd 83       	std	Y+5, r27	; 0x05
    1fc8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1fca:	13 96       	adiw	r26, 0x03	; 3
    1fcc:	dc 93       	st	X, r29
    1fce:	ce 93       	st	-X, r28
    1fd0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1fd2:	39 87       	std	Y+9, r19	; 0x09
    1fd4:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1fd6:	f9 01       	movw	r30, r18
    1fd8:	80 81       	ld	r24, Z
    1fda:	8f 5f       	subi	r24, 0xFF	; 255
    1fdc:	80 83       	st	Z, r24
}
    1fde:	df 91       	pop	r29
    1fe0:	cf 91       	pop	r28
    1fe2:	08 95       	ret

00001fe4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1fe4:	cf 93       	push	r28
    1fe6:	df 93       	push	r29
    1fe8:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1fea:	18 96       	adiw	r26, 0x08	; 8
    1fec:	cd 91       	ld	r28, X+
    1fee:	dc 91       	ld	r29, X
    1ff0:	19 97       	sbiw	r26, 0x09	; 9

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1ff2:	12 96       	adiw	r26, 0x02	; 2
    1ff4:	4d 91       	ld	r20, X+
    1ff6:	5c 91       	ld	r21, X
    1ff8:	13 97       	sbiw	r26, 0x03	; 3
    1ffa:	14 96       	adiw	r26, 0x04	; 4
    1ffc:	8d 91       	ld	r24, X+
    1ffe:	9c 91       	ld	r25, X
    2000:	15 97       	sbiw	r26, 0x05	; 5
    2002:	fa 01       	movw	r30, r20
    2004:	95 83       	std	Z+5, r25	; 0x05
    2006:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2008:	14 96       	adiw	r26, 0x04	; 4
    200a:	2d 91       	ld	r18, X+
    200c:	3c 91       	ld	r19, X
    200e:	15 97       	sbiw	r26, 0x05	; 5
    2010:	f9 01       	movw	r30, r18
    2012:	53 83       	std	Z+3, r21	; 0x03
    2014:	42 83       	std	Z+2, r20	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2016:	89 81       	ldd	r24, Y+1	; 0x01
    2018:	9a 81       	ldd	r25, Y+2	; 0x02
    201a:	8a 17       	cp	r24, r26
    201c:	9b 07       	cpc	r25, r27
    201e:	11 f4       	brne	.+4      	; 0x2024 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2020:	3a 83       	std	Y+2, r19	; 0x02
    2022:	29 83       	std	Y+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    2024:	19 96       	adiw	r26, 0x09	; 9
    2026:	1c 92       	st	X, r1
    2028:	1e 92       	st	-X, r1
    202a:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    202c:	88 81       	ld	r24, Y
    202e:	81 50       	subi	r24, 0x01	; 1
    2030:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
    2032:	df 91       	pop	r29
    2034:	cf 91       	pop	r28
    2036:	08 95       	ret

00002038 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    2038:	ef 92       	push	r14
    203a:	ff 92       	push	r15
    203c:	0f 93       	push	r16
    203e:	1f 93       	push	r17
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2040:	dc 01       	movw	r26, r24
    2042:	15 96       	adiw	r26, 0x05	; 5
    2044:	ed 91       	ld	r30, X+
    2046:	fc 91       	ld	r31, X
    2048:	16 97       	sbiw	r26, 0x06	; 6
    204a:	e6 80       	ldd	r14, Z+6	; 0x06
    204c:	f7 80       	ldd	r15, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    204e:	87 01       	movw	r16, r14
    2050:	04 5f       	subi	r16, 0xF4	; 244
    2052:	1f 4f       	sbci	r17, 0xFF	; 255
    2054:	c8 01       	movw	r24, r16
    2056:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    205a:	8e e1       	ldi	r24, 0x1E	; 30
    205c:	92 e0       	ldi	r25, 0x02	; 2
    205e:	b8 01       	movw	r22, r16
    2060:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>
    2064:	20 e0       	ldi	r18, 0x00	; 0
    2066:	e0 91 ed 01 	lds	r30, 0x01ED
    206a:	f0 91 ee 01 	lds	r31, 0x01EE
    206e:	d7 01       	movw	r26, r14
    2070:	56 96       	adiw	r26, 0x16	; 22
    2072:	9c 91       	ld	r25, X
    2074:	86 89       	ldd	r24, Z+22	; 0x16
    2076:	98 17       	cp	r25, r24
    2078:	08 f0       	brcs	.+2      	; 0x207c <xCoRoutineRemoveFromEventList+0x44>
    207a:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    207c:	82 2f       	mov	r24, r18
    207e:	1f 91       	pop	r17
    2080:	0f 91       	pop	r16
    2082:	ff 90       	pop	r15
    2084:	ef 90       	pop	r14
    2086:	08 95       	ret

00002088 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2088:	ff 92       	push	r15
    208a:	0f 93       	push	r16
    208c:	1f 93       	push	r17
    208e:	cf 93       	push	r28
    2090:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2092:	99 e0       	ldi	r25, 0x09	; 9
    2094:	f9 2e       	mov	r15, r25
    2096:	21 c0       	rjmp	.+66     	; 0x20da <vCoRoutineSchedule+0x52>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2098:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    209a:	e0 91 23 02 	lds	r30, 0x0223
    209e:	f0 91 24 02 	lds	r31, 0x0224
    20a2:	06 81       	ldd	r16, Z+6	; 0x06
    20a4:	17 81       	ldd	r17, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    20a6:	c8 01       	movw	r24, r16
    20a8:	0c 96       	adiw	r24, 0x0c	; 12
    20aa:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    20ae:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    20b0:	e8 01       	movw	r28, r16
    20b2:	22 96       	adiw	r28, 0x02	; 2
    20b4:	ce 01       	movw	r24, r28
    20b6:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    20ba:	f8 01       	movw	r30, r16
    20bc:	96 89       	ldd	r25, Z+22	; 0x16
    20be:	80 91 ef 01 	lds	r24, 0x01EF
    20c2:	89 17       	cp	r24, r25
    20c4:	10 f4       	brcc	.+4      	; 0x20ca <vCoRoutineSchedule+0x42>
    20c6:	90 93 ef 01 	sts	0x01EF, r25
    20ca:	9f 9d       	mul	r25, r15
    20cc:	c0 01       	movw	r24, r0
    20ce:	11 24       	eor	r1, r1
    20d0:	8a 50       	subi	r24, 0x0A	; 10
    20d2:	9e 4f       	sbci	r25, 0xFE	; 254
    20d4:	be 01       	movw	r22, r28
    20d6:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    20da:	80 91 1e 02 	lds	r24, 0x021E
    20de:	88 23       	and	r24, r24
    20e0:	d9 f6       	brne	.-74     	; 0x2098 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    20e2:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <xTaskGetTickCount>
    20e6:	20 91 f0 01 	lds	r18, 0x01F0
    20ea:	30 91 f1 01 	lds	r19, 0x01F1
    20ee:	82 1b       	sub	r24, r18
    20f0:	93 0b       	sbc	r25, r19
    20f2:	90 93 f3 01 	sts	0x01F3, r25
    20f6:	80 93 f2 01 	sts	0x01F2, r24
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    20fa:	89 e0       	ldi	r24, 0x09	; 9
    20fc:	f8 2e       	mov	r15, r24
    20fe:	53 c0       	rjmp	.+166    	; 0x21a6 <vCoRoutineSchedule+0x11e>
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2100:	01 96       	adiw	r24, 0x01	; 1
    2102:	90 93 f5 01 	sts	0x01F5, r25
    2106:	80 93 f4 01 	sts	0x01F4, r24
		xPassedTicks--;
    210a:	21 50       	subi	r18, 0x01	; 1
    210c:	30 40       	sbci	r19, 0x00	; 0
    210e:	30 93 f3 01 	sts	0x01F3, r19
    2112:	20 93 f2 01 	sts	0x01F2, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2116:	89 2b       	or	r24, r25
    2118:	09 f0       	breq	.+2      	; 0x211c <vCoRoutineSchedule+0x94>
    211a:	3e c0       	rjmp	.+124    	; 0x2198 <vCoRoutineSchedule+0x110>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    211c:	20 91 1a 02 	lds	r18, 0x021A
    2120:	30 91 1b 02 	lds	r19, 0x021B
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2124:	80 91 1c 02 	lds	r24, 0x021C
    2128:	90 91 1d 02 	lds	r25, 0x021D
    212c:	90 93 1b 02 	sts	0x021B, r25
    2130:	80 93 1a 02 	sts	0x021A, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2134:	30 93 1d 02 	sts	0x021D, r19
    2138:	20 93 1c 02 	sts	0x021C, r18
    213c:	2d c0       	rjmp	.+90     	; 0x2198 <vCoRoutineSchedule+0x110>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    213e:	05 80       	ldd	r0, Z+5	; 0x05
    2140:	f6 81       	ldd	r31, Z+6	; 0x06
    2142:	e0 2d       	mov	r30, r0
    2144:	c6 81       	ldd	r28, Z+6	; 0x06
    2146:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    2148:	20 91 f4 01 	lds	r18, 0x01F4
    214c:	30 91 f5 01 	lds	r19, 0x01F5
    2150:	8a 81       	ldd	r24, Y+2	; 0x02
    2152:	9b 81       	ldd	r25, Y+3	; 0x03
    2154:	28 17       	cp	r18, r24
    2156:	39 07       	cpc	r19, r25
    2158:	30 f1       	brcs	.+76     	; 0x21a6 <vCoRoutineSchedule+0x11e>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    215a:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    215c:	8e 01       	movw	r16, r28
    215e:	0e 5f       	subi	r16, 0xFE	; 254
    2160:	1f 4f       	sbci	r17, 0xFF	; 255
    2162:	c8 01       	movw	r24, r16
    2164:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    2168:	8c 89       	ldd	r24, Y+20	; 0x14
    216a:	9d 89       	ldd	r25, Y+21	; 0x15
    216c:	89 2b       	or	r24, r25
    216e:	21 f0       	breq	.+8      	; 0x2178 <vCoRoutineSchedule+0xf0>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    2170:	ce 01       	movw	r24, r28
    2172:	0c 96       	adiw	r24, 0x0c	; 12
    2174:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2178:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    217a:	9e 89       	ldd	r25, Y+22	; 0x16
    217c:	80 91 ef 01 	lds	r24, 0x01EF
    2180:	89 17       	cp	r24, r25
    2182:	10 f4       	brcc	.+4      	; 0x2188 <vCoRoutineSchedule+0x100>
    2184:	90 93 ef 01 	sts	0x01EF, r25
    2188:	9f 9d       	mul	r25, r15
    218a:	c0 01       	movw	r24, r0
    218c:	11 24       	eor	r1, r1
    218e:	8a 50       	subi	r24, 0x0A	; 10
    2190:	9e 4f       	sbci	r25, 0xFE	; 254
    2192:	b8 01       	movw	r22, r16
    2194:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2198:	e0 91 1a 02 	lds	r30, 0x021A
    219c:	f0 91 1b 02 	lds	r31, 0x021B
    21a0:	80 81       	ld	r24, Z
    21a2:	88 23       	and	r24, r24
    21a4:	61 f6       	brne	.-104    	; 0x213e <vCoRoutineSchedule+0xb6>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    21a6:	20 91 f2 01 	lds	r18, 0x01F2
    21aa:	30 91 f3 01 	lds	r19, 0x01F3
    21ae:	80 91 f4 01 	lds	r24, 0x01F4
    21b2:	90 91 f5 01 	lds	r25, 0x01F5
    21b6:	21 15       	cp	r18, r1
    21b8:	31 05       	cpc	r19, r1
    21ba:	09 f0       	breq	.+2      	; 0x21be <vCoRoutineSchedule+0x136>
    21bc:	a1 cf       	rjmp	.-190    	; 0x2100 <vCoRoutineSchedule+0x78>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    21be:	90 93 f1 01 	sts	0x01F1, r25
    21c2:	80 93 f0 01 	sts	0x01F0, r24
    21c6:	90 91 ef 01 	lds	r25, 0x01EF

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    21ca:	29 e0       	ldi	r18, 0x09	; 9
    21cc:	06 c0       	rjmp	.+12     	; 0x21da <vCoRoutineSchedule+0x152>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    21ce:	99 23       	and	r25, r25
    21d0:	19 f4       	brne	.+6      	; 0x21d8 <vCoRoutineSchedule+0x150>
    21d2:	10 92 ef 01 	sts	0x01EF, r1
    21d6:	32 c0       	rjmp	.+100    	; 0x223c <vCoRoutineSchedule+0x1b4>
    21d8:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    21da:	92 9f       	mul	r25, r18
    21dc:	d0 01       	movw	r26, r0
    21de:	11 24       	eor	r1, r1
    21e0:	aa 50       	subi	r26, 0x0A	; 10
    21e2:	be 4f       	sbci	r27, 0xFE	; 254
    21e4:	8c 91       	ld	r24, X
    21e6:	88 23       	and	r24, r24
    21e8:	91 f3       	breq	.-28     	; 0x21ce <vCoRoutineSchedule+0x146>
    21ea:	90 93 ef 01 	sts	0x01EF, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    21ee:	11 96       	adiw	r26, 0x01	; 1
    21f0:	ed 91       	ld	r30, X+
    21f2:	fc 91       	ld	r31, X
    21f4:	12 97       	sbiw	r26, 0x02	; 2
    21f6:	02 80       	ldd	r0, Z+2	; 0x02
    21f8:	f3 81       	ldd	r31, Z+3	; 0x03
    21fa:	e0 2d       	mov	r30, r0
    21fc:	12 96       	adiw	r26, 0x02	; 2
    21fe:	fc 93       	st	X, r31
    2200:	ee 93       	st	-X, r30
    2202:	11 97       	sbiw	r26, 0x01	; 1
    2204:	cd 01       	movw	r24, r26
    2206:	03 96       	adiw	r24, 0x03	; 3
    2208:	e8 17       	cp	r30, r24
    220a:	f9 07       	cpc	r31, r25
    220c:	31 f4       	brne	.+12     	; 0x221a <vCoRoutineSchedule+0x192>
    220e:	82 81       	ldd	r24, Z+2	; 0x02
    2210:	93 81       	ldd	r25, Z+3	; 0x03
    2212:	12 96       	adiw	r26, 0x02	; 2
    2214:	9c 93       	st	X, r25
    2216:	8e 93       	st	-X, r24
    2218:	11 97       	sbiw	r26, 0x01	; 1
    221a:	11 96       	adiw	r26, 0x01	; 1
    221c:	ed 91       	ld	r30, X+
    221e:	fc 91       	ld	r31, X
    2220:	12 97       	sbiw	r26, 0x02	; 2
    2222:	06 80       	ldd	r0, Z+6	; 0x06
    2224:	f7 81       	ldd	r31, Z+7	; 0x07
    2226:	e0 2d       	mov	r30, r0
    2228:	f0 93 ee 01 	sts	0x01EE, r31
    222c:	e0 93 ed 01 	sts	0x01ED, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2230:	20 81       	ld	r18, Z
    2232:	31 81       	ldd	r19, Z+1	; 0x01
    2234:	cf 01       	movw	r24, r30
    2236:	67 89       	ldd	r22, Z+23	; 0x17
    2238:	f9 01       	movw	r30, r18
    223a:	09 95       	icall

	return;
}
    223c:	df 91       	pop	r29
    223e:	cf 91       	pop	r28
    2240:	1f 91       	pop	r17
    2242:	0f 91       	pop	r16
    2244:	ff 90       	pop	r15
    2246:	08 95       	ret

00002248 <vCoRoutineAddToDelayedList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    2248:	0f 93       	push	r16
    224a:	1f 93       	push	r17
    224c:	cf 93       	push	r28
    224e:	df 93       	push	r29
    2250:	eb 01       	movw	r28, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2252:	00 91 f4 01 	lds	r16, 0x01F4
    2256:	10 91 f5 01 	lds	r17, 0x01F5
    225a:	08 0f       	add	r16, r24
    225c:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    225e:	80 91 ed 01 	lds	r24, 0x01ED
    2262:	90 91 ee 01 	lds	r25, 0x01EE
    2266:	02 96       	adiw	r24, 0x02	; 2
    2268:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    226c:	e0 91 ed 01 	lds	r30, 0x01ED
    2270:	f0 91 ee 01 	lds	r31, 0x01EE
    2274:	13 83       	std	Z+3, r17	; 0x03
    2276:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2278:	80 91 f4 01 	lds	r24, 0x01F4
    227c:	90 91 f5 01 	lds	r25, 0x01F5
    2280:	bf 01       	movw	r22, r30
    2282:	6e 5f       	subi	r22, 0xFE	; 254
    2284:	7f 4f       	sbci	r23, 0xFF	; 255
    2286:	08 17       	cp	r16, r24
    2288:	19 07       	cpc	r17, r25
    228a:	28 f4       	brcc	.+10     	; 0x2296 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    228c:	80 91 1c 02 	lds	r24, 0x021C
    2290:	90 91 1d 02 	lds	r25, 0x021D
    2294:	04 c0       	rjmp	.+8      	; 0x229e <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2296:	80 91 1a 02 	lds	r24, 0x021A
    229a:	90 91 1b 02 	lds	r25, 0x021B
    229e:	0e 94 c0 0f 	call	0x1f80	; 0x1f80 <vListInsert>
	}

	if( pxEventList )
    22a2:	20 97       	sbiw	r28, 0x00	; 0
    22a4:	49 f0       	breq	.+18     	; 0x22b8 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    22a6:	60 91 ed 01 	lds	r22, 0x01ED
    22aa:	70 91 ee 01 	lds	r23, 0x01EE
    22ae:	64 5f       	subi	r22, 0xF4	; 244
    22b0:	7f 4f       	sbci	r23, 0xFF	; 255
    22b2:	ce 01       	movw	r24, r28
    22b4:	0e 94 c0 0f 	call	0x1f80	; 0x1f80 <vListInsert>
	}
}
    22b8:	df 91       	pop	r29
    22ba:	cf 91       	pop	r28
    22bc:	1f 91       	pop	r17
    22be:	0f 91       	pop	r16
    22c0:	08 95       	ret

000022c2 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    22c2:	af 92       	push	r10
    22c4:	bf 92       	push	r11
    22c6:	cf 92       	push	r12
    22c8:	df 92       	push	r13
    22ca:	ef 92       	push	r14
    22cc:	ff 92       	push	r15
    22ce:	0f 93       	push	r16
    22d0:	1f 93       	push	r17
    22d2:	cf 93       	push	r28
    22d4:	df 93       	push	r29
    22d6:	6c 01       	movw	r12, r24
    22d8:	b6 2e       	mov	r11, r22
    22da:	a4 2e       	mov	r10, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    22dc:	8a e1       	ldi	r24, 0x1A	; 26
    22de:	90 e0       	ldi	r25, 0x00	; 0
    22e0:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <pvPortMalloc>
    22e4:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    22e6:	00 97       	sbiw	r24, 0x00	; 0
    22e8:	11 f4       	brne	.+4      	; 0x22ee <xCoRoutineCreate+0x2c>
    22ea:	8f ef       	ldi	r24, 0xFF	; 255
    22ec:	59 c0       	rjmp	.+178    	; 0x23a0 <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    22ee:	80 91 ed 01 	lds	r24, 0x01ED
    22f2:	90 91 ee 01 	lds	r25, 0x01EE
    22f6:	89 2b       	or	r24, r25
    22f8:	21 f5       	brne	.+72     	; 0x2342 <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    22fa:	d0 93 ee 01 	sts	0x01EE, r29
    22fe:	c0 93 ed 01 	sts	0x01ED, r28
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2302:	86 ef       	ldi	r24, 0xF6	; 246
    2304:	91 e0       	ldi	r25, 0x01	; 1
    2306:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
    230a:	8f ef       	ldi	r24, 0xFF	; 255
    230c:	91 e0       	ldi	r25, 0x01	; 1
    230e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    2312:	28 e0       	ldi	r18, 0x08	; 8
    2314:	e2 2e       	mov	r14, r18
    2316:	22 e0       	ldi	r18, 0x02	; 2
    2318:	f2 2e       	mov	r15, r18
    231a:	c7 01       	movw	r24, r14
    231c:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    2320:	01 e1       	ldi	r16, 0x11	; 17
    2322:	12 e0       	ldi	r17, 0x02	; 2
    2324:	c8 01       	movw	r24, r16
    2326:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    232a:	8e e1       	ldi	r24, 0x1E	; 30
    232c:	92 e0       	ldi	r25, 0x02	; 2
    232e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2332:	f0 92 1b 02 	sts	0x021B, r15
    2336:	e0 92 1a 02 	sts	0x021A, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    233a:	10 93 1d 02 	sts	0x021D, r17
    233e:	00 93 1c 02 	sts	0x021C, r16
    2342:	eb 2c       	mov	r14, r11
    2344:	bb 20       	and	r11, r11
    2346:	11 f0       	breq	.+4      	; 0x234c <xCoRoutineCreate+0x8a>
    2348:	ee 24       	eor	r14, r14
    234a:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    234c:	19 8e       	std	Y+25, r1	; 0x19
    234e:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2350:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2352:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2354:	fe 01       	movw	r30, r28
    2356:	c1 92       	st	Z+, r12
    2358:	d1 92       	st	Z+, r13
    235a:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    235c:	cf 01       	movw	r24, r30
    235e:	0e 94 9d 0f 	call	0x1f3a	; 0x1f3a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2362:	ce 01       	movw	r24, r28
    2364:	0c 96       	adiw	r24, 0x0c	; 12
    2366:	0e 94 9d 0f 	call	0x1f3a	; 0x1f3a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    236a:	d9 87       	std	Y+9, r29	; 0x09
    236c:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    236e:	db 8b       	std	Y+19, r29	; 0x13
    2370:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2372:	82 e0       	ldi	r24, 0x02	; 2
    2374:	90 e0       	ldi	r25, 0x00	; 0
    2376:	8e 19       	sub	r24, r14
    2378:	91 09       	sbc	r25, r1
    237a:	9d 87       	std	Y+13, r25	; 0x0d
    237c:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    237e:	9e 89       	ldd	r25, Y+22	; 0x16
    2380:	80 91 ef 01 	lds	r24, 0x01EF
    2384:	89 17       	cp	r24, r25
    2386:	10 f4       	brcc	.+4      	; 0x238c <xCoRoutineCreate+0xca>
    2388:	90 93 ef 01 	sts	0x01EF, r25
    238c:	89 e0       	ldi	r24, 0x09	; 9
    238e:	98 9f       	mul	r25, r24
    2390:	c0 01       	movw	r24, r0
    2392:	11 24       	eor	r1, r1
    2394:	8a 50       	subi	r24, 0x0A	; 10
    2396:	9e 4f       	sbci	r25, 0xFE	; 254
    2398:	b8 01       	movw	r22, r16
    239a:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInsertEnd>
    239e:	81 e0       	ldi	r24, 0x01	; 1
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}

	return xReturn;
}
    23a0:	df 91       	pop	r29
    23a2:	cf 91       	pop	r28
    23a4:	1f 91       	pop	r17
    23a6:	0f 91       	pop	r16
    23a8:	ff 90       	pop	r15
    23aa:	ef 90       	pop	r14
    23ac:	df 90       	pop	r13
    23ae:	cf 90       	pop	r12
    23b0:	bf 90       	pop	r11
    23b2:	af 90       	pop	r10
    23b4:	08 95       	ret

000023b6 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    23b6:	08 95       	ret

000023b8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    23b8:	10 92 28 02 	sts	0x0228, r1
    23bc:	10 92 27 02 	sts	0x0227, r1
}
    23c0:	08 95       	ret

000023c2 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    23c2:	2b ed       	ldi	r18, 0xDB	; 219
    23c4:	35 e0       	ldi	r19, 0x05	; 5
    23c6:	80 91 27 02 	lds	r24, 0x0227
    23ca:	90 91 28 02 	lds	r25, 0x0228
    23ce:	28 1b       	sub	r18, r24
    23d0:	39 0b       	sbc	r19, r25
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
    23d2:	c9 01       	movw	r24, r18
    23d4:	08 95       	ret

000023d6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    23d6:	cf 93       	push	r28
    23d8:	df 93       	push	r29
    23da:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    23dc:	0e 94 55 04 	call	0x8aa	; 0x8aa <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    23e0:	80 91 29 02 	lds	r24, 0x0229
    23e4:	90 91 2a 02 	lds	r25, 0x022A
    23e8:	89 2b       	or	r24, r25
    23ea:	31 f4       	brne	.+12     	; 0x23f8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    23ec:	8c e2       	ldi	r24, 0x2C	; 44
    23ee:	92 e0       	ldi	r25, 0x02	; 2
    23f0:	90 93 2a 02 	sts	0x022A, r25
    23f4:	80 93 29 02 	sts	0x0229, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    23f8:	20 91 27 02 	lds	r18, 0x0227
    23fc:	30 91 28 02 	lds	r19, 0x0228
    2400:	ce 01       	movw	r24, r28
    2402:	82 0f       	add	r24, r18
    2404:	93 1f       	adc	r25, r19
    2406:	45 e0       	ldi	r20, 0x05	; 5
    2408:	8b 3d       	cpi	r24, 0xDB	; 219
    240a:	94 07       	cpc	r25, r20
    240c:	70 f4       	brcc	.+28     	; 0x242a <pvPortMalloc+0x54>
    240e:	28 17       	cp	r18, r24
    2410:	39 07       	cpc	r19, r25
    2412:	58 f4       	brcc	.+22     	; 0x242a <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2414:	c0 91 29 02 	lds	r28, 0x0229
    2418:	d0 91 2a 02 	lds	r29, 0x022A
    241c:	c2 0f       	add	r28, r18
    241e:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2420:	90 93 28 02 	sts	0x0228, r25
    2424:	80 93 27 02 	sts	0x0227, r24
    2428:	02 c0       	rjmp	.+4      	; 0x242e <pvPortMalloc+0x58>
    242a:	c0 e0       	ldi	r28, 0x00	; 0
    242c:	d0 e0       	ldi	r29, 0x00	; 0
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    242e:	0e 94 97 07 	call	0xf2e	; 0xf2e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2432:	ce 01       	movw	r24, r28
    2434:	df 91       	pop	r29
    2436:	cf 91       	pop	r28
    2438:	08 95       	ret

0000243a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    243a:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    243c:	91 e1       	ldi	r25, 0x11	; 17
    243e:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2440:	22 e2       	ldi	r18, 0x22	; 34
    2442:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2444:	83 e3       	ldi	r24, 0x33	; 51
    2446:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2448:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    244a:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    244c:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    244e:	80 e8       	ldi	r24, 0x80	; 128
    2450:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2452:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2454:	82 e0       	ldi	r24, 0x02	; 2
    2456:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2458:	83 e0       	ldi	r24, 0x03	; 3
    245a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    245c:	84 e0       	ldi	r24, 0x04	; 4
    245e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2460:	85 e0       	ldi	r24, 0x05	; 5
    2462:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2464:	86 e0       	ldi	r24, 0x06	; 6
    2466:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2468:	87 e0       	ldi	r24, 0x07	; 7
    246a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    246c:	88 e0       	ldi	r24, 0x08	; 8
    246e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2470:	89 e0       	ldi	r24, 0x09	; 9
    2472:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2474:	80 e1       	ldi	r24, 0x10	; 16
    2476:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2478:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    247a:	82 e1       	ldi	r24, 0x12	; 18
    247c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    247e:	83 e1       	ldi	r24, 0x13	; 19
    2480:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2482:	84 e1       	ldi	r24, 0x14	; 20
    2484:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2486:	85 e1       	ldi	r24, 0x15	; 21
    2488:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    248a:	86 e1       	ldi	r24, 0x16	; 22
    248c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    248e:	87 e1       	ldi	r24, 0x17	; 23
    2490:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2492:	88 e1       	ldi	r24, 0x18	; 24
    2494:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2496:	89 e1       	ldi	r24, 0x19	; 25
    2498:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    249a:	80 e2       	ldi	r24, 0x20	; 32
    249c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    249e:	81 e2       	ldi	r24, 0x21	; 33
    24a0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    24a2:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    24a4:	83 e2       	ldi	r24, 0x23	; 35
    24a6:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    24a8:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    24aa:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    24ac:	86 e2       	ldi	r24, 0x26	; 38
    24ae:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    24b0:	87 e2       	ldi	r24, 0x27	; 39
    24b2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    24b4:	88 e2       	ldi	r24, 0x28	; 40
    24b6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    24b8:	89 e2       	ldi	r24, 0x29	; 41
    24ba:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    24bc:	80 e3       	ldi	r24, 0x30	; 48
    24be:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    24c0:	81 e3       	ldi	r24, 0x31	; 49
    24c2:	82 93       	st	-Z, r24
    24c4:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    24c6:	cf 01       	movw	r24, r30
    24c8:	08 95       	ret

000024ca <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    24ca:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    24ce:	89 ef       	ldi	r24, 0xF9	; 249
    24d0:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    24d4:	8b e0       	ldi	r24, 0x0B	; 11
    24d6:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    24da:	ef e6       	ldi	r30, 0x6F	; 111
    24dc:	f0 e0       	ldi	r31, 0x00	; 0
    24de:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    24e0:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    24e2:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    24e4:	a0 91 90 01 	lds	r26, 0x0190
    24e8:	b0 91 91 01 	lds	r27, 0x0191
    24ec:	cd 91       	ld	r28, X+
    24ee:	cd bf       	out	0x3d, r28	; 61
    24f0:	dd 91       	ld	r29, X+
    24f2:	de bf       	out	0x3e, r29	; 62
    24f4:	ff 91       	pop	r31
    24f6:	ef 91       	pop	r30
    24f8:	df 91       	pop	r29
    24fa:	cf 91       	pop	r28
    24fc:	bf 91       	pop	r27
    24fe:	af 91       	pop	r26
    2500:	9f 91       	pop	r25
    2502:	8f 91       	pop	r24
    2504:	7f 91       	pop	r23
    2506:	6f 91       	pop	r22
    2508:	5f 91       	pop	r21
    250a:	4f 91       	pop	r20
    250c:	3f 91       	pop	r19
    250e:	2f 91       	pop	r18
    2510:	1f 91       	pop	r17
    2512:	0f 91       	pop	r16
    2514:	ff 90       	pop	r15
    2516:	ef 90       	pop	r14
    2518:	df 90       	pop	r13
    251a:	cf 90       	pop	r12
    251c:	bf 90       	pop	r11
    251e:	af 90       	pop	r10
    2520:	9f 90       	pop	r9
    2522:	8f 90       	pop	r8
    2524:	7f 90       	pop	r7
    2526:	6f 90       	pop	r6
    2528:	5f 90       	pop	r5
    252a:	4f 90       	pop	r4
    252c:	3f 90       	pop	r3
    252e:	2f 90       	pop	r2
    2530:	1f 90       	pop	r1
    2532:	0f 90       	pop	r0
    2534:	0f be       	out	0x3f, r0	; 63
    2536:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2538:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    253a:	81 e0       	ldi	r24, 0x01	; 1
    253c:	08 95       	ret

0000253e <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    253e:	08 95       	ret

00002540 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2540:	0f 92       	push	r0
    2542:	0f b6       	in	r0, 0x3f	; 63
    2544:	f8 94       	cli
    2546:	0f 92       	push	r0
    2548:	1f 92       	push	r1
    254a:	11 24       	eor	r1, r1
    254c:	2f 92       	push	r2
    254e:	3f 92       	push	r3
    2550:	4f 92       	push	r4
    2552:	5f 92       	push	r5
    2554:	6f 92       	push	r6
    2556:	7f 92       	push	r7
    2558:	8f 92       	push	r8
    255a:	9f 92       	push	r9
    255c:	af 92       	push	r10
    255e:	bf 92       	push	r11
    2560:	cf 92       	push	r12
    2562:	df 92       	push	r13
    2564:	ef 92       	push	r14
    2566:	ff 92       	push	r15
    2568:	0f 93       	push	r16
    256a:	1f 93       	push	r17
    256c:	2f 93       	push	r18
    256e:	3f 93       	push	r19
    2570:	4f 93       	push	r20
    2572:	5f 93       	push	r21
    2574:	6f 93       	push	r22
    2576:	7f 93       	push	r23
    2578:	8f 93       	push	r24
    257a:	9f 93       	push	r25
    257c:	af 93       	push	r26
    257e:	bf 93       	push	r27
    2580:	cf 93       	push	r28
    2582:	df 93       	push	r29
    2584:	ef 93       	push	r30
    2586:	ff 93       	push	r31
    2588:	a0 91 90 01 	lds	r26, 0x0190
    258c:	b0 91 91 01 	lds	r27, 0x0191
    2590:	0d b6       	in	r0, 0x3d	; 61
    2592:	0d 92       	st	X+, r0
    2594:	0e b6       	in	r0, 0x3e	; 62
    2596:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2598:	0e 94 64 06 	call	0xcc8	; 0xcc8 <xTaskIncrementTick>
    259c:	88 23       	and	r24, r24
    259e:	11 f0       	breq	.+4      	; 0x25a4 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    25a0:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    25a4:	a0 91 90 01 	lds	r26, 0x0190
    25a8:	b0 91 91 01 	lds	r27, 0x0191
    25ac:	cd 91       	ld	r28, X+
    25ae:	cd bf       	out	0x3d, r28	; 61
    25b0:	dd 91       	ld	r29, X+
    25b2:	de bf       	out	0x3e, r29	; 62
    25b4:	ff 91       	pop	r31
    25b6:	ef 91       	pop	r30
    25b8:	df 91       	pop	r29
    25ba:	cf 91       	pop	r28
    25bc:	bf 91       	pop	r27
    25be:	af 91       	pop	r26
    25c0:	9f 91       	pop	r25
    25c2:	8f 91       	pop	r24
    25c4:	7f 91       	pop	r23
    25c6:	6f 91       	pop	r22
    25c8:	5f 91       	pop	r21
    25ca:	4f 91       	pop	r20
    25cc:	3f 91       	pop	r19
    25ce:	2f 91       	pop	r18
    25d0:	1f 91       	pop	r17
    25d2:	0f 91       	pop	r16
    25d4:	ff 90       	pop	r15
    25d6:	ef 90       	pop	r14
    25d8:	df 90       	pop	r13
    25da:	cf 90       	pop	r12
    25dc:	bf 90       	pop	r11
    25de:	af 90       	pop	r10
    25e0:	9f 90       	pop	r9
    25e2:	8f 90       	pop	r8
    25e4:	7f 90       	pop	r7
    25e6:	6f 90       	pop	r6
    25e8:	5f 90       	pop	r5
    25ea:	4f 90       	pop	r4
    25ec:	3f 90       	pop	r3
    25ee:	2f 90       	pop	r2
    25f0:	1f 90       	pop	r1
    25f2:	0f 90       	pop	r0
    25f4:	0f be       	out	0x3f, r0	; 63
    25f6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    25f8:	08 95       	ret

000025fa <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    25fa:	0e 94 a0 12 	call	0x2540	; 0x2540 <vPortYieldFromTick>
		asm volatile ( "reti" );
    25fe:	18 95       	reti

00002600 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2600:	0f 92       	push	r0
    2602:	0f b6       	in	r0, 0x3f	; 63
    2604:	f8 94       	cli
    2606:	0f 92       	push	r0
    2608:	1f 92       	push	r1
    260a:	11 24       	eor	r1, r1
    260c:	2f 92       	push	r2
    260e:	3f 92       	push	r3
    2610:	4f 92       	push	r4
    2612:	5f 92       	push	r5
    2614:	6f 92       	push	r6
    2616:	7f 92       	push	r7
    2618:	8f 92       	push	r8
    261a:	9f 92       	push	r9
    261c:	af 92       	push	r10
    261e:	bf 92       	push	r11
    2620:	cf 92       	push	r12
    2622:	df 92       	push	r13
    2624:	ef 92       	push	r14
    2626:	ff 92       	push	r15
    2628:	0f 93       	push	r16
    262a:	1f 93       	push	r17
    262c:	2f 93       	push	r18
    262e:	3f 93       	push	r19
    2630:	4f 93       	push	r20
    2632:	5f 93       	push	r21
    2634:	6f 93       	push	r22
    2636:	7f 93       	push	r23
    2638:	8f 93       	push	r24
    263a:	9f 93       	push	r25
    263c:	af 93       	push	r26
    263e:	bf 93       	push	r27
    2640:	cf 93       	push	r28
    2642:	df 93       	push	r29
    2644:	ef 93       	push	r30
    2646:	ff 93       	push	r31
    2648:	a0 91 90 01 	lds	r26, 0x0190
    264c:	b0 91 91 01 	lds	r27, 0x0191
    2650:	0d b6       	in	r0, 0x3d	; 61
    2652:	0d 92       	st	X+, r0
    2654:	0e b6       	in	r0, 0x3e	; 62
    2656:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2658:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    265c:	a0 91 90 01 	lds	r26, 0x0190
    2660:	b0 91 91 01 	lds	r27, 0x0191
    2664:	cd 91       	ld	r28, X+
    2666:	cd bf       	out	0x3d, r28	; 61
    2668:	dd 91       	ld	r29, X+
    266a:	de bf       	out	0x3e, r29	; 62
    266c:	ff 91       	pop	r31
    266e:	ef 91       	pop	r30
    2670:	df 91       	pop	r29
    2672:	cf 91       	pop	r28
    2674:	bf 91       	pop	r27
    2676:	af 91       	pop	r26
    2678:	9f 91       	pop	r25
    267a:	8f 91       	pop	r24
    267c:	7f 91       	pop	r23
    267e:	6f 91       	pop	r22
    2680:	5f 91       	pop	r21
    2682:	4f 91       	pop	r20
    2684:	3f 91       	pop	r19
    2686:	2f 91       	pop	r18
    2688:	1f 91       	pop	r17
    268a:	0f 91       	pop	r16
    268c:	ff 90       	pop	r15
    268e:	ef 90       	pop	r14
    2690:	df 90       	pop	r13
    2692:	cf 90       	pop	r12
    2694:	bf 90       	pop	r11
    2696:	af 90       	pop	r10
    2698:	9f 90       	pop	r9
    269a:	8f 90       	pop	r8
    269c:	7f 90       	pop	r7
    269e:	6f 90       	pop	r6
    26a0:	5f 90       	pop	r5
    26a2:	4f 90       	pop	r4
    26a4:	3f 90       	pop	r3
    26a6:	2f 90       	pop	r2
    26a8:	1f 90       	pop	r1
    26aa:	0f 90       	pop	r0
    26ac:	0f be       	out	0x3f, r0	; 63
    26ae:	0f 90       	pop	r0

	asm volatile ( "ret" );
    26b0:	08 95       	ret

000026b2 <xAreFlashCoRoutinesStillRunning>:
BaseType_t xAreFlashCoRoutinesStillRunning( void )
{
	/* Return pdPASS or pdFAIL depending on whether an error has been detected
	or not. */
	return xCoRoutineFlashStatus;
}
    26b2:	80 91 30 01 	lds	r24, 0x0130
    26b6:	08 95       	ret

000026b8 <vStartFlashCoRoutines>:

/*
 * See the header file for details.
 */
void vStartFlashCoRoutines( UBaseType_t uxNumberToCreate )
{
    26b8:	0f 93       	push	r16
    26ba:	1f 93       	push	r17
    26bc:	08 2f       	mov	r16, r24
    26be:	89 30       	cpi	r24, 0x09	; 9
    26c0:	08 f0       	brcs	.+2      	; 0x26c4 <vStartFlashCoRoutines+0xc>
    26c2:	08 e0       	ldi	r16, 0x08	; 8
	{
		uxNumberToCreate = crfMAX_FLASH_TASKS;
	}

	/* Create the queue used to pass data between the co-routines. */
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );
    26c4:	81 e0       	ldi	r24, 0x01	; 1
    26c6:	61 e0       	ldi	r22, 0x01	; 1
    26c8:	40 e0       	ldi	r20, 0x00	; 0
    26ca:	0e 94 65 0f 	call	0x1eca	; 0x1eca <xQueueGenericCreate>
    26ce:	90 93 08 08 	sts	0x0808, r25
    26d2:	80 93 07 08 	sts	0x0807, r24

	if( xFlashQueue )
    26d6:	89 2b       	or	r24, r25
    26d8:	89 f0       	breq	.+34     	; 0x26fc <vStartFlashCoRoutines+0x44>
    26da:	10 e0       	ldi	r17, 0x00	; 0
    26dc:	07 c0       	rjmp	.+14     	; 0x26ec <vStartFlashCoRoutines+0x34>
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
    26de:	88 ec       	ldi	r24, 0xC8	; 200
    26e0:	93 e1       	ldi	r25, 0x13	; 19
    26e2:	60 e0       	ldi	r22, 0x00	; 0
    26e4:	41 2f       	mov	r20, r17
    26e6:	0e 94 61 11 	call	0x22c2	; 0x22c2 <xCoRoutineCreate>
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );

	if( xFlashQueue )
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    26ea:	1f 5f       	subi	r17, 0xFF	; 255
    26ec:	10 17       	cp	r17, r16
    26ee:	b8 f3       	brcs	.-18     	; 0x26de <vStartFlashCoRoutines+0x26>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    26f0:	81 e8       	ldi	r24, 0x81	; 129
    26f2:	93 e1       	ldi	r25, 0x13	; 19
    26f4:	61 e0       	ldi	r22, 0x01	; 1
    26f6:	40 e0       	ldi	r20, 0x00	; 0
    26f8:	0e 94 61 11 	call	0x22c2	; 0x22c2 <xCoRoutineCreate>
	}
}
    26fc:	1f 91       	pop	r17
    26fe:	0f 91       	pop	r16
    2700:	08 95       	ret

00002702 <prvFlashCoRoutine>:
	crEND();
}
/*-----------------------------------------------------------*/

static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    2702:	0f 93       	push	r16
    2704:	1f 93       	push	r17
    2706:	df 93       	push	r29
    2708:	cf 93       	push	r28
    270a:	0f 92       	push	r0
    270c:	cd b7       	in	r28, 0x3d	; 61
    270e:	de b7       	in	r29, 0x3e	; 62
static as we do not need it to maintain their state between blocks. */
BaseType_t xResult;
UBaseType_t uxLEDToFlash;

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    2710:	8c 01       	movw	r16, r24
    2712:	fc 01       	movw	r30, r24
    2714:	80 8d       	ldd	r24, Z+24	; 0x18
    2716:	91 8d       	ldd	r25, Z+25	; 0x19
    2718:	f1 e0       	ldi	r31, 0x01	; 1
    271a:	82 3c       	cpi	r24, 0xC2	; 194
    271c:	9f 07       	cpc	r25, r31
    271e:	b1 f0       	breq	.+44     	; 0x274c <prvFlashCoRoutine+0x4a>
    2720:	21 e0       	ldi	r18, 0x01	; 1
    2722:	83 3c       	cpi	r24, 0xC3	; 195
    2724:	92 07       	cpc	r25, r18
    2726:	51 f1       	breq	.+84     	; 0x277c <prvFlashCoRoutine+0x7a>
    2728:	89 2b       	or	r24, r25
    272a:	61 f5       	brne	.+88     	; 0x2784 <prvFlashCoRoutine+0x82>
	( void ) uxIndex;
	
	for( ;; )
	{
		/* Block to wait for the number of the LED to flash. */
		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );		
    272c:	80 91 07 08 	lds	r24, 0x0807
    2730:	90 91 08 08 	lds	r25, 0x0808
    2734:	be 01       	movw	r22, r28
    2736:	6f 5f       	subi	r22, 0xFF	; 255
    2738:	7f 4f       	sbci	r23, 0xFF	; 255
    273a:	4f ef       	ldi	r20, 0xFF	; 255
    273c:	5f ef       	ldi	r21, 0xFF	; 255
    273e:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <xQueueCRReceive>
    2742:	8c 3f       	cpi	r24, 0xFC	; 252
    2744:	71 f4       	brne	.+28     	; 0x2762 <prvFlashCoRoutine+0x60>
    2746:	82 ec       	ldi	r24, 0xC2	; 194
    2748:	91 e0       	ldi	r25, 0x01	; 1
    274a:	0f c0       	rjmp	.+30     	; 0x276a <prvFlashCoRoutine+0x68>
    274c:	80 91 07 08 	lds	r24, 0x0807
    2750:	90 91 08 08 	lds	r25, 0x0808
    2754:	be 01       	movw	r22, r28
    2756:	6f 5f       	subi	r22, 0xFF	; 255
    2758:	7f 4f       	sbci	r23, 0xFF	; 255
    275a:	40 e0       	ldi	r20, 0x00	; 0
    275c:	50 e0       	ldi	r21, 0x00	; 0
    275e:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <xQueueCRReceive>
    2762:	8b 3f       	cpi	r24, 0xFB	; 251
    2764:	31 f4       	brne	.+12     	; 0x2772 <prvFlashCoRoutine+0x70>
    2766:	83 ec       	ldi	r24, 0xC3	; 195
    2768:	91 e0       	ldi	r25, 0x01	; 1
    276a:	f8 01       	movw	r30, r16
    276c:	91 8f       	std	Z+25, r25	; 0x19
    276e:	80 8f       	std	Z+24, r24	; 0x18
    2770:	09 c0       	rjmp	.+18     	; 0x2784 <prvFlashCoRoutine+0x82>

		if( xResult != pdPASS )
    2772:	81 30       	cpi	r24, 0x01	; 1
    2774:	19 f0       	breq	.+6      	; 0x277c <prvFlashCoRoutine+0x7a>
		{
			/* We would not expect to wake unless we received something. */
			xCoRoutineFlashStatus = pdFAIL;
    2776:	10 92 30 01 	sts	0x0130, r1
    277a:	d8 cf       	rjmp	.-80     	; 0x272c <prvFlashCoRoutine+0x2a>
		}
		else
		{
			/* We received the number of an LED to flash - flash it! */
			vParTestToggleLED( uxLEDToFlash );
    277c:	89 81       	ldd	r24, Y+1	; 0x01
    277e:	0e 94 9c 02 	call	0x538	; 0x538 <vParTestToggleLED>
    2782:	d4 cf       	rjmp	.-88     	; 0x272c <prvFlashCoRoutine+0x2a>
		}
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    2784:	0f 90       	pop	r0
    2786:	cf 91       	pop	r28
    2788:	df 91       	pop	r29
    278a:	1f 91       	pop	r17
    278c:	0f 91       	pop	r16
    278e:	08 95       	ret

00002790 <prvFixedDelayCoRoutine>:
	}
}
/*-----------------------------------------------------------*/

static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    2790:	0f 93       	push	r16
    2792:	1f 93       	push	r17
    2794:	df 93       	push	r29
    2796:	cf 93       	push	r28
    2798:	0f 92       	push	r0
    279a:	cd b7       	in	r28, 0x3d	; 61
    279c:	de b7       	in	r29, 0x3e	; 62
    279e:	69 83       	std	Y+1, r22	; 0x01
																400 / portTICK_PERIOD_MS,
																450 / portTICK_PERIOD_MS,
																500  / portTICK_PERIOD_MS };

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    27a0:	8c 01       	movw	r16, r24
    27a2:	fc 01       	movw	r30, r24
    27a4:	80 8d       	ldd	r24, Z+24	; 0x18
    27a6:	91 8d       	ldd	r25, Z+25	; 0x19
    27a8:	f1 e0       	ldi	r31, 0x01	; 1
    27aa:	82 38       	cpi	r24, 0x82	; 130
    27ac:	9f 07       	cpc	r25, r31
    27ae:	f1 f0       	breq	.+60     	; 0x27ec <prvFixedDelayCoRoutine+0x5c>
    27b0:	21 e0       	ldi	r18, 0x01	; 1
    27b2:	83 38       	cpi	r24, 0x83	; 131
    27b4:	92 07       	cpc	r25, r18
    27b6:	18 f4       	brcc	.+6      	; 0x27be <prvFixedDelayCoRoutine+0x2e>
    27b8:	89 2b       	or	r24, r25
    27ba:	41 f0       	breq	.+16     	; 0x27cc <prvFixedDelayCoRoutine+0x3c>
    27bc:	3e c0       	rjmp	.+124    	; 0x283a <prvFixedDelayCoRoutine+0xaa>
    27be:	e1 e0       	ldi	r30, 0x01	; 1
    27c0:	83 38       	cpi	r24, 0x83	; 131
    27c2:	9e 07       	cpc	r25, r30
    27c4:	39 f1       	breq	.+78     	; 0x2814 <prvFixedDelayCoRoutine+0x84>
    27c6:	86 59       	subi	r24, 0x96	; 150
    27c8:	91 40       	sbci	r25, 0x01	; 1
    27ca:	b9 f5       	brne	.+110    	; 0x283a <prvFixedDelayCoRoutine+0xaa>

	for( ;; )
	{
		/* Post our uxIndex value onto the queue.  This is used as the LED to
		flash. */
		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
    27cc:	80 91 07 08 	lds	r24, 0x0807
    27d0:	90 91 08 08 	lds	r25, 0x0808
    27d4:	be 01       	movw	r22, r28
    27d6:	6f 5f       	subi	r22, 0xFF	; 255
    27d8:	7f 4f       	sbci	r23, 0xFF	; 255
    27da:	40 e0       	ldi	r20, 0x00	; 0
    27dc:	50 e0       	ldi	r21, 0x00	; 0
    27de:	0e 94 c3 0c 	call	0x1986	; 0x1986 <xQueueCRSend>
    27e2:	8c 3f       	cpi	r24, 0xFC	; 252
    27e4:	71 f4       	brne	.+28     	; 0x2802 <prvFixedDelayCoRoutine+0x72>
    27e6:	82 e8       	ldi	r24, 0x82	; 130
    27e8:	91 e0       	ldi	r25, 0x01	; 1
    27ea:	24 c0       	rjmp	.+72     	; 0x2834 <prvFixedDelayCoRoutine+0xa4>
    27ec:	80 91 07 08 	lds	r24, 0x0807
    27f0:	90 91 08 08 	lds	r25, 0x0808
    27f4:	be 01       	movw	r22, r28
    27f6:	6f 5f       	subi	r22, 0xFF	; 255
    27f8:	7f 4f       	sbci	r23, 0xFF	; 255
    27fa:	40 e0       	ldi	r20, 0x00	; 0
    27fc:	50 e0       	ldi	r21, 0x00	; 0
    27fe:	0e 94 c3 0c 	call	0x1986	; 0x1986 <xQueueCRSend>
    2802:	8b 3f       	cpi	r24, 0xFB	; 251
    2804:	19 f4       	brne	.+6      	; 0x280c <prvFixedDelayCoRoutine+0x7c>
    2806:	83 e8       	ldi	r24, 0x83	; 131
    2808:	91 e0       	ldi	r25, 0x01	; 1
    280a:	14 c0       	rjmp	.+40     	; 0x2834 <prvFixedDelayCoRoutine+0xa4>

		if( xResult != pdPASS )
    280c:	81 30       	cpi	r24, 0x01	; 1
    280e:	11 f0       	breq	.+4      	; 0x2814 <prvFixedDelayCoRoutine+0x84>
		{
			/* For the reasons stated at the top of the file we should always
			find that we can post to the queue.  If we could not then an error
			has occurred. */
			xCoRoutineFlashStatus = pdFAIL;
    2810:	10 92 30 01 	sts	0x0130, r1
		}

		crDELAY( xHandle, xFlashRates[ uxIndex ] );
    2814:	e9 81       	ldd	r30, Y+1	; 0x01
    2816:	f0 e0       	ldi	r31, 0x00	; 0
    2818:	ee 0f       	add	r30, r30
    281a:	ff 1f       	adc	r31, r31
    281c:	ef 5c       	subi	r30, 0xCF	; 207
    281e:	fe 4f       	sbci	r31, 0xFE	; 254
    2820:	80 81       	ld	r24, Z
    2822:	91 81       	ldd	r25, Z+1	; 0x01
    2824:	00 97       	sbiw	r24, 0x00	; 0
    2826:	21 f0       	breq	.+8      	; 0x2830 <prvFixedDelayCoRoutine+0xa0>
    2828:	60 e0       	ldi	r22, 0x00	; 0
    282a:	70 e0       	ldi	r23, 0x00	; 0
    282c:	0e 94 24 11 	call	0x2248	; 0x2248 <vCoRoutineAddToDelayedList>
    2830:	86 e9       	ldi	r24, 0x96	; 150
    2832:	91 e0       	ldi	r25, 0x01	; 1
    2834:	f8 01       	movw	r30, r16
    2836:	91 8f       	std	Z+25, r25	; 0x19
    2838:	80 8f       	std	Z+24, r24	; 0x18
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    283a:	0f 90       	pop	r0
    283c:	cf 91       	pop	r28
    283e:	df 91       	pop	r29
    2840:	1f 91       	pop	r17
    2842:	0f 91       	pop	r16
    2844:	08 95       	ret

00002846 <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    2846:	9f 92       	push	r9
    2848:	af 92       	push	r10
    284a:	bf 92       	push	r11
    284c:	cf 92       	push	r12
    284e:	df 92       	push	r13
    2850:	ef 92       	push	r14
    2852:	ff 92       	push	r15
    2854:	0f 93       	push	r16
    2856:	1f 93       	push	r17
    2858:	df 93       	push	r29
    285a:	cf 93       	push	r28
    285c:	00 d0       	rcall	.+0      	; 0x285e <vCompeteingIntMathTask+0x18>
    285e:	00 d0       	rcall	.+0      	; 0x2860 <vCompeteingIntMathTask+0x1a>
    2860:	cd b7       	in	r28, 0x3d	; 61
    2862:	de b7       	in	r29, 0x3e	; 62
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    2864:	8c 01       	movw	r16, r24
    2866:	ee 24       	eor	r14, r14
    2868:	ff 24       	eor	r15, r15
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    286a:	9b e7       	ldi	r25, 0x7B	; 123
    286c:	a9 2e       	mov	r10, r25
    286e:	b1 2c       	mov	r11, r1
    2870:	c1 2c       	mov	r12, r1
    2872:	d1 2c       	mov	r13, r1
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
    2874:	99 24       	eor	r9, r9
    2876:	93 94       	inc	r9
    2878:	03 c0       	rjmp	.+6      	; 0x2880 <vCompeteingIntMathTask+0x3a>
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    287a:	81 e0       	ldi	r24, 0x01	; 1
    287c:	e8 2e       	mov	r14, r24
    287e:	f1 2c       	mov	r15, r1
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    2880:	a9 82       	std	Y+1, r10	; 0x01
    2882:	ba 82       	std	Y+2, r11	; 0x02
    2884:	cb 82       	std	Y+3, r12	; 0x03
    2886:	dc 82       	std	Y+4, r13	; 0x04
		lValue += intgCONST2;
    2888:	89 81       	ldd	r24, Y+1	; 0x01
    288a:	9a 81       	ldd	r25, Y+2	; 0x02
    288c:	ab 81       	ldd	r26, Y+3	; 0x03
    288e:	bc 81       	ldd	r27, Y+4	; 0x04
    2890:	89 5b       	subi	r24, 0xB9	; 185
    2892:	9b 46       	sbci	r25, 0x6B	; 107
    2894:	ac 4f       	sbci	r26, 0xFC	; 252
    2896:	bf 4f       	sbci	r27, 0xFF	; 255
    2898:	89 83       	std	Y+1, r24	; 0x01
    289a:	9a 83       	std	Y+2, r25	; 0x02
    289c:	ab 83       	std	Y+3, r26	; 0x03
    289e:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    28a0:	69 81       	ldd	r22, Y+1	; 0x01
    28a2:	7a 81       	ldd	r23, Y+2	; 0x02
    28a4:	8b 81       	ldd	r24, Y+3	; 0x03
    28a6:	9c 81       	ldd	r25, Y+4	; 0x04
    28a8:	2d ef       	ldi	r18, 0xFD	; 253
    28aa:	3f ef       	ldi	r19, 0xFF	; 255
    28ac:	4f ef       	ldi	r20, 0xFF	; 255
    28ae:	5f ef       	ldi	r21, 0xFF	; 255
    28b0:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsi3>
    28b4:	69 83       	std	Y+1, r22	; 0x01
    28b6:	7a 83       	std	Y+2, r23	; 0x02
    28b8:	8b 83       	std	Y+3, r24	; 0x03
    28ba:	9c 83       	std	Y+4, r25	; 0x04
		lValue /= intgCONST4;
    28bc:	69 81       	ldd	r22, Y+1	; 0x01
    28be:	7a 81       	ldd	r23, Y+2	; 0x02
    28c0:	8b 81       	ldd	r24, Y+3	; 0x03
    28c2:	9c 81       	ldd	r25, Y+4	; 0x04
    28c4:	27 e0       	ldi	r18, 0x07	; 7
    28c6:	30 e0       	ldi	r19, 0x00	; 0
    28c8:	40 e0       	ldi	r20, 0x00	; 0
    28ca:	50 e0       	ldi	r21, 0x00	; 0
    28cc:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <__divmodsi4>
    28d0:	c9 01       	movw	r24, r18
    28d2:	da 01       	movw	r26, r20
    28d4:	89 83       	std	Y+1, r24	; 0x01
    28d6:	9a 83       	std	Y+2, r25	; 0x02
    28d8:	ab 83       	std	Y+3, r26	; 0x03
    28da:	bc 83       	std	Y+4, r27	; 0x04

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    28dc:	89 81       	ldd	r24, Y+1	; 0x01
    28de:	9a 81       	ldd	r25, Y+2	; 0x02
    28e0:	ab 81       	ldd	r26, Y+3	; 0x03
    28e2:	bc 81       	ldd	r27, Y+4	; 0x04
    28e4:	8b 51       	subi	r24, 0x1B	; 27
    28e6:	97 47       	sbci	r25, 0x77	; 119
    28e8:	ae 4f       	sbci	r26, 0xFE	; 254
    28ea:	bf 4f       	sbci	r27, 0xFF	; 255
    28ec:	31 f6       	brne	.-116    	; 0x287a <vCompeteingIntMathTask+0x34>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
    28ee:	e1 14       	cp	r14, r1
    28f0:	f1 04       	cpc	r15, r1
    28f2:	09 f0       	breq	.+2      	; 0x28f6 <vCompeteingIntMathTask+0xb0>
    28f4:	c2 cf       	rjmp	.-124    	; 0x287a <vCompeteingIntMathTask+0x34>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    28f6:	0f b6       	in	r0, 0x3f	; 63
    28f8:	f8 94       	cli
    28fa:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    28fc:	f8 01       	movw	r30, r16
    28fe:	90 82       	st	Z, r9
			portEXIT_CRITICAL();
    2900:	0f 90       	pop	r0
    2902:	0f be       	out	0x3f, r0	; 63
    2904:	bd cf       	rjmp	.-134    	; 0x2880 <vCompeteingIntMathTask+0x3a>

00002906 <xAreIntegerMathsTaskStillRunning>:

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    2906:	80 91 09 08 	lds	r24, 0x0809
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    290a:	10 92 09 08 	sts	0x0809, r1
    290e:	81 11       	cpse	r24, r1
    2910:	81 e0       	ldi	r24, 0x01	; 1
	}

	return xReturn;
}
    2912:	08 95       	ret

00002914 <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    2914:	ef 92       	push	r14
    2916:	ff 92       	push	r15
    2918:	0f 93       	push	r16
    291a:	08 2f       	mov	r16, r24
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    291c:	83 e2       	ldi	r24, 0x23	; 35
    291e:	94 e1       	ldi	r25, 0x14	; 20
    2920:	61 e4       	ldi	r22, 0x41	; 65
    2922:	71 e0       	ldi	r23, 0x01	; 1
    2924:	45 e5       	ldi	r20, 0x55	; 85
    2926:	50 e0       	ldi	r21, 0x00	; 0
    2928:	29 e0       	ldi	r18, 0x09	; 9
    292a:	38 e0       	ldi	r19, 0x08	; 8
    292c:	ee 24       	eor	r14, r14
    292e:	ff 24       	eor	r15, r15
    2930:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <xTaskCreate>
	}
}
    2934:	0f 91       	pop	r16
    2936:	ff 90       	pop	r15
    2938:	ef 90       	pop	r14
    293a:	08 95       	ret

0000293c <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    293c:	80 91 0a 08 	lds	r24, 0x080A
    2940:	88 23       	and	r24, r24
    2942:	21 f0       	breq	.+8      	; 0x294c <xArePollingQueuesStillRunning+0x10>
    2944:	80 91 0b 08 	lds	r24, 0x080B
    2948:	81 11       	cpse	r24, r1
    294a:	81 e0       	ldi	r24, 0x01	; 1
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    294c:	10 92 0a 08 	sts	0x080A, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    2950:	10 92 0b 08 	sts	0x080B, r1

	return xReturn;
}
    2954:	08 95       	ret

00002956 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    2956:	ef 92       	push	r14
    2958:	ff 92       	push	r15
    295a:	0f 93       	push	r16
    295c:	1f 93       	push	r17
    295e:	18 2f       	mov	r17, r24
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    2960:	8a e0       	ldi	r24, 0x0A	; 10
    2962:	62 e0       	ldi	r22, 0x02	; 2
    2964:	40 e0       	ldi	r20, 0x00	; 0
    2966:	0e 94 65 0f 	call	0x1eca	; 0x1eca <xQueueGenericCreate>
    296a:	90 93 0d 08 	sts	0x080D, r25
    296e:	80 93 0c 08 	sts	0x080C, r24

	if( xPolledQueue != NULL )
    2972:	89 2b       	or	r24, r25
    2974:	b9 f0       	breq	.+46     	; 0x29a4 <vStartPolledQueueTasks+0x4e>
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

		/* Spawn the producer and consumer. */
		xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    2976:	83 e1       	ldi	r24, 0x13	; 19
    2978:	95 e1       	ldi	r25, 0x15	; 21
    297a:	69 e4       	ldi	r22, 0x49	; 73
    297c:	71 e0       	ldi	r23, 0x01	; 1
    297e:	45 e5       	ldi	r20, 0x55	; 85
    2980:	50 e0       	ldi	r21, 0x00	; 0
    2982:	2c e0       	ldi	r18, 0x0C	; 12
    2984:	38 e0       	ldi	r19, 0x08	; 8
    2986:	01 2f       	mov	r16, r17
    2988:	ee 24       	eor	r14, r14
    298a:	ff 24       	eor	r15, r15
    298c:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <xTaskCreate>
		xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    2990:	87 ed       	ldi	r24, 0xD7	; 215
    2992:	94 e1       	ldi	r25, 0x14	; 20
    2994:	61 e5       	ldi	r22, 0x51	; 81
    2996:	71 e0       	ldi	r23, 0x01	; 1
    2998:	45 e5       	ldi	r20, 0x55	; 85
    299a:	50 e0       	ldi	r21, 0x00	; 0
    299c:	2c e0       	ldi	r18, 0x0C	; 12
    299e:	38 e0       	ldi	r19, 0x08	; 8
    29a0:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <xTaskCreate>
	}
}
    29a4:	1f 91       	pop	r17
    29a6:	0f 91       	pop	r16
    29a8:	ff 90       	pop	r15
    29aa:	ef 90       	pop	r14
    29ac:	08 95       	ret

000029ae <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    29ae:	cf 92       	push	r12
    29b0:	df 92       	push	r13
    29b2:	ef 92       	push	r14
    29b4:	ff 92       	push	r15
    29b6:	0f 93       	push	r16
    29b8:	1f 93       	push	r17
    29ba:	df 93       	push	r29
    29bc:	cf 93       	push	r28
    29be:	00 d0       	rcall	.+0      	; 0x29c0 <vPolledQueueProducer+0x12>
    29c0:	cd b7       	in	r28, 0x3d	; 61
    29c2:	de b7       	in	r29, 0x3e	; 62
    29c4:	7c 01       	movw	r14, r24
uint16_t usValue = ( uint16_t ) 0;
    29c6:	1a 82       	std	Y+2, r1	; 0x02
    29c8:	19 82       	std	Y+1, r1	; 0x01
    29ca:	00 e0       	ldi	r16, 0x00	; 0
    29cc:	10 e0       	ldi	r17, 0x00	; 0
	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    29ce:	6e 01       	movw	r12, r28
    29d0:	08 94       	sec
    29d2:	c1 1c       	adc	r12, r1
    29d4:	d1 1c       	adc	r13, r1
    29d6:	1f c0       	rjmp	.+62     	; 0x2a16 <vPolledQueueProducer+0x68>
    29d8:	f7 01       	movw	r30, r14
    29da:	80 81       	ld	r24, Z
    29dc:	91 81       	ldd	r25, Z+1	; 0x01
    29de:	b6 01       	movw	r22, r12
    29e0:	40 e0       	ldi	r20, 0x00	; 0
    29e2:	50 e0       	ldi	r21, 0x00	; 0
    29e4:	20 e0       	ldi	r18, 0x00	; 0
    29e6:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <xQueueGenericSend>
    29ea:	81 30       	cpi	r24, 0x01	; 1
    29ec:	11 f0       	breq	.+4      	; 0x29f2 <vPolledQueueProducer+0x44>
    29ee:	01 e0       	ldi	r16, 0x01	; 1
    29f0:	11 c0       	rjmp	.+34     	; 0x2a14 <vPolledQueueProducer+0x66>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
    29f2:	00 23       	and	r16, r16
    29f4:	51 f4       	brne	.+20     	; 0x2a0a <vPolledQueueProducer+0x5c>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    29f6:	0f b6       	in	r0, 0x3f	; 63
    29f8:	f8 94       	cli
    29fa:	0f 92       	push	r0
						xPollingProducerCount++;
    29fc:	80 91 0b 08 	lds	r24, 0x080B
    2a00:	8f 5f       	subi	r24, 0xFF	; 255
    2a02:	80 93 0b 08 	sts	0x080B, r24
					portEXIT_CRITICAL();
    2a06:	0f 90       	pop	r0
    2a08:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    2a0a:	89 81       	ldd	r24, Y+1	; 0x01
    2a0c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a0e:	01 96       	adiw	r24, 0x01	; 1
    2a10:	9a 83       	std	Y+2, r25	; 0x02
    2a12:	89 83       	std	Y+1, r24	; 0x01
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    2a14:	1f 5f       	subi	r17, 0xFF	; 255
    2a16:	13 30       	cpi	r17, 0x03	; 3
    2a18:	fc f2       	brlt	.-66     	; 0x29d8 <vPolledQueueProducer+0x2a>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    2a1a:	83 e0       	ldi	r24, 0x03	; 3
    2a1c:	90 e0       	ldi	r25, 0x00	; 0
    2a1e:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <vTaskDelay>
    2a22:	10 e0       	ldi	r17, 0x00	; 0
    2a24:	d9 cf       	rjmp	.-78     	; 0x29d8 <vPolledQueueProducer+0x2a>

00002a26 <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    2a26:	9f 92       	push	r9
    2a28:	af 92       	push	r10
    2a2a:	bf 92       	push	r11
    2a2c:	cf 92       	push	r12
    2a2e:	df 92       	push	r13
    2a30:	ef 92       	push	r14
    2a32:	ff 92       	push	r15
    2a34:	0f 93       	push	r16
    2a36:	1f 93       	push	r17
    2a38:	df 93       	push	r29
    2a3a:	cf 93       	push	r28
    2a3c:	00 d0       	rcall	.+0      	; 0x2a3e <vPolledQueueConsumer+0x18>
    2a3e:	cd b7       	in	r28, 0x3d	; 61
    2a40:	de b7       	in	r29, 0x3e	; 62
    2a42:	98 2e       	mov	r9, r24
    2a44:	c9 2e       	mov	r12, r25
    2a46:	dd 24       	eor	r13, r13
    2a48:	ee 24       	eor	r14, r14
    2a4a:	ff 24       	eor	r15, r15
	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    2a4c:	5e 01       	movw	r10, r28
    2a4e:	08 94       	sec
    2a50:	a1 1c       	adc	r10, r1
    2a52:	b1 1c       	adc	r11, r1
    2a54:	23 c0       	rjmp	.+70     	; 0x2a9c <vPolledQueueConsumer+0x76>
    2a56:	f8 01       	movw	r30, r16
    2a58:	80 81       	ld	r24, Z
    2a5a:	91 81       	ldd	r25, Z+1	; 0x01
    2a5c:	b5 01       	movw	r22, r10
    2a5e:	40 e0       	ldi	r20, 0x00	; 0
    2a60:	50 e0       	ldi	r21, 0x00	; 0
    2a62:	20 e0       	ldi	r18, 0x00	; 0
    2a64:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <xQueueGenericReceive>
    2a68:	81 30       	cpi	r24, 0x01	; 1
    2a6a:	c1 f4       	brne	.+48     	; 0x2a9c <vPolledQueueConsumer+0x76>
			{
				if( usData != usExpectedValue )
    2a6c:	29 81       	ldd	r18, Y+1	; 0x01
    2a6e:	3a 81       	ldd	r19, Y+2	; 0x02
    2a70:	2e 15       	cp	r18, r14
    2a72:	3f 05       	cpc	r19, r15
    2a74:	19 f0       	breq	.+6      	; 0x2a7c <vPolledQueueConsumer+0x56>
    2a76:	dd 24       	eor	r13, r13
    2a78:	d3 94       	inc	r13
    2a7a:	0c c0       	rjmp	.+24     	; 0x2a94 <vPolledQueueConsumer+0x6e>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
    2a7c:	dd 20       	and	r13, r13
    2a7e:	51 f4       	brne	.+20     	; 0x2a94 <vPolledQueueConsumer+0x6e>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    2a80:	0f b6       	in	r0, 0x3f	; 63
    2a82:	f8 94       	cli
    2a84:	0f 92       	push	r0
							xPollingConsumerCount++;
    2a86:	80 91 0a 08 	lds	r24, 0x080A
    2a8a:	8f 5f       	subi	r24, 0xFF	; 255
    2a8c:	80 93 0a 08 	sts	0x080A, r24
						portEXIT_CRITICAL();
    2a90:	0f 90       	pop	r0
    2a92:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    2a94:	79 01       	movw	r14, r18
    2a96:	08 94       	sec
    2a98:	e1 1c       	adc	r14, r1
    2a9a:	f1 1c       	adc	r15, r1
BaseType_t xError = pdFALSE;

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    2a9c:	09 2d       	mov	r16, r9
    2a9e:	1c 2d       	mov	r17, r12
    2aa0:	f8 01       	movw	r30, r16
    2aa2:	80 81       	ld	r24, Z
    2aa4:	91 81       	ldd	r25, Z+1	; 0x01
    2aa6:	0e 94 81 0b 	call	0x1702	; 0x1702 <uxQueueMessagesWaiting>
    2aaa:	88 23       	and	r24, r24
    2aac:	a1 f6       	brne	.-88     	; 0x2a56 <vPolledQueueConsumer+0x30>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    2aae:	8f ee       	ldi	r24, 0xEF	; 239
    2ab0:	9f ef       	ldi	r25, 0xFF	; 255
    2ab2:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <vTaskDelay>
    2ab6:	f2 cf       	rjmp	.-28     	; 0x2a9c <vPolledQueueConsumer+0x76>

00002ab8 <xAreComTestTasksStillRunning>:
BaseType_t xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
    2ab8:	80 91 0e 08 	lds	r24, 0x080E
		xReturn = pdTRUE;
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
    2abc:	10 92 0e 08 	sts	0x080E, r1
    2ac0:	81 11       	cpse	r24, r1
    2ac2:	81 e0       	ldi	r24, 0x01	; 1

	return xReturn;
}
    2ac4:	08 95       	ret

00002ac6 <vAltStartComTestTasks>:
static volatile UBaseType_t uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED )
{
    2ac6:	ef 92       	push	r14
    2ac8:	ff 92       	push	r15
    2aca:	0f 93       	push	r16
    2acc:	1f 93       	push	r17
    2ace:	18 2f       	mov	r17, r24
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
    2ad0:	20 93 0f 08 	sts	0x080F, r18
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
    2ad4:	cb 01       	movw	r24, r22
    2ad6:	ba 01       	movw	r22, r20
    2ad8:	48 e1       	ldi	r20, 0x18	; 24
    2ada:	0e 94 9c 03 	call	0x738	; 0x738 <xSerialPortInitMinimal>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( TaskHandle_t * ) NULL );
    2ade:	01 2f       	mov	r16, r17
    2ae0:	01 50       	subi	r16, 0x01	; 1
    2ae2:	80 ed       	ldi	r24, 0xD0	; 208
    2ae4:	95 e1       	ldi	r25, 0x15	; 21
    2ae6:	69 e5       	ldi	r22, 0x59	; 89
    2ae8:	71 e0       	ldi	r23, 0x01	; 1
    2aea:	45 e5       	ldi	r20, 0x55	; 85
    2aec:	50 e0       	ldi	r21, 0x00	; 0
    2aee:	20 e0       	ldi	r18, 0x00	; 0
    2af0:	30 e0       	ldi	r19, 0x00	; 0
    2af2:	ee 24       	eor	r14, r14
    2af4:	ff 24       	eor	r15, r15
    2af6:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <xTaskCreate>
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
    2afa:	8d e8       	ldi	r24, 0x8D	; 141
    2afc:	95 e1       	ldi	r25, 0x15	; 21
    2afe:	6f e5       	ldi	r22, 0x5F	; 95
    2b00:	71 e0       	ldi	r23, 0x01	; 1
    2b02:	45 e5       	ldi	r20, 0x55	; 85
    2b04:	50 e0       	ldi	r21, 0x00	; 0
    2b06:	20 e0       	ldi	r18, 0x00	; 0
    2b08:	30 e0       	ldi	r19, 0x00	; 0
    2b0a:	01 2f       	mov	r16, r17
    2b0c:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <xTaskCreate>
}
    2b10:	1f 91       	pop	r17
    2b12:	0f 91       	pop	r16
    2b14:	ff 90       	pop	r15
    2b16:	ef 90       	pop	r14
    2b18:	08 95       	ret

00002b1a <vComRxTask>:
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    2b1a:	ef 92       	push	r14
    2b1c:	ff 92       	push	r15
    2b1e:	0f 93       	push	r16
    2b20:	1f 93       	push	r17
    2b22:	df 93       	push	r29
    2b24:	cf 93       	push	r28
    2b26:	0f 92       	push	r0
    2b28:	cd b7       	in	r28, 0x3d	; 61
    2b2a:	de b7       	in	r29, 0x3e	; 62
    2b2c:	00 e0       	ldi	r16, 0x00	; 0
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    2b2e:	7e 01       	movw	r14, r28
    2b30:	08 94       	sec
    2b32:	e1 1c       	adc	r14, r1
    2b34:	f1 1c       	adc	r15, r1
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    2b36:	11 e4       	ldi	r17, 0x41	; 65
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    2b38:	80 e0       	ldi	r24, 0x00	; 0
    2b3a:	90 e0       	ldi	r25, 0x00	; 0
    2b3c:	b7 01       	movw	r22, r14
    2b3e:	4f ef       	ldi	r20, 0xFF	; 255
    2b40:	5f ef       	ldi	r21, 0xFF	; 255
    2b42:	0e 94 92 03 	call	0x724	; 0x724 <xSerialGetChar>
    2b46:	88 23       	and	r24, r24
    2b48:	51 f0       	breq	.+20     	; 0x2b5e <vComRxTask+0x44>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
    2b4a:	89 81       	ldd	r24, Y+1	; 0x01
    2b4c:	81 17       	cp	r24, r17
    2b4e:	11 f0       	breq	.+4      	; 0x2b54 <vComRxTask+0x3a>
    2b50:	11 e0       	ldi	r17, 0x01	; 1
    2b52:	09 c0       	rjmp	.+18     	; 0x2b66 <vComRxTask+0x4c>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
    2b54:	80 91 0f 08 	lds	r24, 0x080F
    2b58:	8f 5f       	subi	r24, 0xFF	; 255
    2b5a:	0e 94 9c 02 	call	0x538	; 0x538 <vParTestToggleLED>

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    2b5e:	1f 5f       	subi	r17, 0xFF	; 255
    2b60:	19 35       	cpi	r17, 0x59	; 89
    2b62:	51 f7       	brne	.-44     	; 0x2b38 <vComRxTask+0x1e>
    2b64:	10 e0       	ldi	r17, 0x00	; 0
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
    2b66:	80 91 0f 08 	lds	r24, 0x080F
    2b6a:	8f 5f       	subi	r24, 0xFF	; 255
    2b6c:	60 e0       	ldi	r22, 0x00	; 0
    2b6e:	0e 94 bf 02 	call	0x57e	; 0x57e <vParTestSetLED>

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
    2b72:	11 30       	cpi	r17, 0x01	; 1
    2b74:	69 f4       	brne	.+26     	; 0x2b90 <vComRxTask+0x76>
    2b76:	07 c0       	rjmp	.+14     	; 0x2b86 <vComRxTask+0x6c>
		{
			while( cByteRxed != comLAST_BYTE )
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
    2b78:	80 e0       	ldi	r24, 0x00	; 0
    2b7a:	90 e0       	ldi	r25, 0x00	; 0
    2b7c:	b7 01       	movw	r22, r14
    2b7e:	4f ef       	ldi	r20, 0xFF	; 255
    2b80:	5f ef       	ldi	r21, 0xFF	; 255
    2b82:	0e 94 92 03 	call	0x724	; 0x724 <xSerialGetChar>
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
    2b86:	89 81       	ldd	r24, Y+1	; 0x01
    2b88:	88 35       	cpi	r24, 0x58	; 88
    2b8a:	b1 f7       	brne	.-20     	; 0x2b78 <vComRxTask+0x5e>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
    2b8c:	0f 5f       	subi	r16, 0xFF	; 255
    2b8e:	d3 cf       	rjmp	.-90     	; 0x2b36 <vComRxTask+0x1c>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
    2b90:	02 30       	cpi	r16, 0x02	; 2
    2b92:	8c f6       	brge	.-94     	; 0x2b36 <vComRxTask+0x1c>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
    2b94:	80 91 0e 08 	lds	r24, 0x080E
    2b98:	8f 5f       	subi	r24, 0xFF	; 255
    2b9a:	80 93 0e 08 	sts	0x080E, r24
    2b9e:	cb cf       	rjmp	.-106    	; 0x2b36 <vComRxTask+0x1c>

00002ba0 <vComTxTask>:
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComTxTask, pvParameters )
{
    2ba0:	1f 93       	push	r17
    2ba2:	11 e4       	ldi	r17, 0x41	; 65
    2ba4:	0e c0       	rjmp	.+28     	; 0x2bc2 <vComTxTask+0x22>
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
    2ba6:	80 e0       	ldi	r24, 0x00	; 0
    2ba8:	90 e0       	ldi	r25, 0x00	; 0
    2baa:	61 2f       	mov	r22, r17
    2bac:	40 e0       	ldi	r20, 0x00	; 0
    2bae:	50 e0       	ldi	r21, 0x00	; 0
    2bb0:	0e 94 74 03 	call	0x6e8	; 0x6e8 <xSerialPutChar>
    2bb4:	81 30       	cpi	r24, 0x01	; 1
    2bb6:	21 f4       	brne	.+8      	; 0x2bc0 <vComTxTask+0x20>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
    2bb8:	80 91 0f 08 	lds	r24, 0x080F
    2bbc:	0e 94 9c 02 	call	0x538	; 0x538 <vParTestToggleLED>

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    2bc0:	1f 5f       	subi	r17, 0xFF	; 255
    2bc2:	19 35       	cpi	r17, 0x59	; 89
    2bc4:	84 f3       	brlt	.-32     	; 0x2ba6 <vComTxTask+0x6>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
    2bc6:	80 91 0f 08 	lds	r24, 0x080F
    2bca:	60 e0       	ldi	r22, 0x00	; 0
    2bcc:	0e 94 bf 02 	call	0x57e	; 0x57e <vParTestSetLED>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
    2bd0:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <xTaskGetTickCount>

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    2bd4:	03 96       	adiw	r24, 0x03	; 3
    2bd6:	66 e9       	ldi	r22, 0x96	; 150
    2bd8:	70 e0       	ldi	r23, 0x00	; 0
    2bda:	0e 94 17 16 	call	0x2c2e	; 0x2c2e <__udivmodhi4>

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
    2bde:	82 33       	cpi	r24, 0x32	; 50
    2be0:	91 05       	cpc	r25, r1
    2be2:	10 f4       	brcc	.+4      	; 0x2be8 <vComTxTask+0x48>
    2be4:	82 e3       	ldi	r24, 0x32	; 50
    2be6:	90 e0       	ldi	r25, 0x00	; 0
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
		}

		vTaskDelay( xTimeToWait );
    2be8:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <vTaskDelay>
    2bec:	11 e4       	ldi	r17, 0x41	; 65
    2bee:	db cf       	rjmp	.-74     	; 0x2ba6 <vComTxTask+0x6>

00002bf0 <__mulsi3>:
    2bf0:	62 9f       	mul	r22, r18
    2bf2:	d0 01       	movw	r26, r0
    2bf4:	73 9f       	mul	r23, r19
    2bf6:	f0 01       	movw	r30, r0
    2bf8:	82 9f       	mul	r24, r18
    2bfa:	e0 0d       	add	r30, r0
    2bfc:	f1 1d       	adc	r31, r1
    2bfe:	64 9f       	mul	r22, r20
    2c00:	e0 0d       	add	r30, r0
    2c02:	f1 1d       	adc	r31, r1
    2c04:	92 9f       	mul	r25, r18
    2c06:	f0 0d       	add	r31, r0
    2c08:	83 9f       	mul	r24, r19
    2c0a:	f0 0d       	add	r31, r0
    2c0c:	74 9f       	mul	r23, r20
    2c0e:	f0 0d       	add	r31, r0
    2c10:	65 9f       	mul	r22, r21
    2c12:	f0 0d       	add	r31, r0
    2c14:	99 27       	eor	r25, r25
    2c16:	72 9f       	mul	r23, r18
    2c18:	b0 0d       	add	r27, r0
    2c1a:	e1 1d       	adc	r30, r1
    2c1c:	f9 1f       	adc	r31, r25
    2c1e:	63 9f       	mul	r22, r19
    2c20:	b0 0d       	add	r27, r0
    2c22:	e1 1d       	adc	r30, r1
    2c24:	f9 1f       	adc	r31, r25
    2c26:	bd 01       	movw	r22, r26
    2c28:	cf 01       	movw	r24, r30
    2c2a:	11 24       	eor	r1, r1
    2c2c:	08 95       	ret

00002c2e <__udivmodhi4>:
    2c2e:	aa 1b       	sub	r26, r26
    2c30:	bb 1b       	sub	r27, r27
    2c32:	51 e1       	ldi	r21, 0x11	; 17
    2c34:	07 c0       	rjmp	.+14     	; 0x2c44 <__udivmodhi4_ep>

00002c36 <__udivmodhi4_loop>:
    2c36:	aa 1f       	adc	r26, r26
    2c38:	bb 1f       	adc	r27, r27
    2c3a:	a6 17       	cp	r26, r22
    2c3c:	b7 07       	cpc	r27, r23
    2c3e:	10 f0       	brcs	.+4      	; 0x2c44 <__udivmodhi4_ep>
    2c40:	a6 1b       	sub	r26, r22
    2c42:	b7 0b       	sbc	r27, r23

00002c44 <__udivmodhi4_ep>:
    2c44:	88 1f       	adc	r24, r24
    2c46:	99 1f       	adc	r25, r25
    2c48:	5a 95       	dec	r21
    2c4a:	a9 f7       	brne	.-22     	; 0x2c36 <__udivmodhi4_loop>
    2c4c:	80 95       	com	r24
    2c4e:	90 95       	com	r25
    2c50:	bc 01       	movw	r22, r24
    2c52:	cd 01       	movw	r24, r26
    2c54:	08 95       	ret

00002c56 <__udivmodsi4>:
    2c56:	a1 e2       	ldi	r26, 0x21	; 33
    2c58:	1a 2e       	mov	r1, r26
    2c5a:	aa 1b       	sub	r26, r26
    2c5c:	bb 1b       	sub	r27, r27
    2c5e:	fd 01       	movw	r30, r26
    2c60:	0d c0       	rjmp	.+26     	; 0x2c7c <__udivmodsi4_ep>

00002c62 <__udivmodsi4_loop>:
    2c62:	aa 1f       	adc	r26, r26
    2c64:	bb 1f       	adc	r27, r27
    2c66:	ee 1f       	adc	r30, r30
    2c68:	ff 1f       	adc	r31, r31
    2c6a:	a2 17       	cp	r26, r18
    2c6c:	b3 07       	cpc	r27, r19
    2c6e:	e4 07       	cpc	r30, r20
    2c70:	f5 07       	cpc	r31, r21
    2c72:	20 f0       	brcs	.+8      	; 0x2c7c <__udivmodsi4_ep>
    2c74:	a2 1b       	sub	r26, r18
    2c76:	b3 0b       	sbc	r27, r19
    2c78:	e4 0b       	sbc	r30, r20
    2c7a:	f5 0b       	sbc	r31, r21

00002c7c <__udivmodsi4_ep>:
    2c7c:	66 1f       	adc	r22, r22
    2c7e:	77 1f       	adc	r23, r23
    2c80:	88 1f       	adc	r24, r24
    2c82:	99 1f       	adc	r25, r25
    2c84:	1a 94       	dec	r1
    2c86:	69 f7       	brne	.-38     	; 0x2c62 <__udivmodsi4_loop>
    2c88:	60 95       	com	r22
    2c8a:	70 95       	com	r23
    2c8c:	80 95       	com	r24
    2c8e:	90 95       	com	r25
    2c90:	9b 01       	movw	r18, r22
    2c92:	ac 01       	movw	r20, r24
    2c94:	bd 01       	movw	r22, r26
    2c96:	cf 01       	movw	r24, r30
    2c98:	08 95       	ret

00002c9a <__divmodsi4>:
    2c9a:	97 fb       	bst	r25, 7
    2c9c:	09 2e       	mov	r0, r25
    2c9e:	05 26       	eor	r0, r21
    2ca0:	0e d0       	rcall	.+28     	; 0x2cbe <__divmodsi4_neg1>
    2ca2:	57 fd       	sbrc	r21, 7
    2ca4:	04 d0       	rcall	.+8      	; 0x2cae <__divmodsi4_neg2>
    2ca6:	d7 df       	rcall	.-82     	; 0x2c56 <__udivmodsi4>
    2ca8:	0a d0       	rcall	.+20     	; 0x2cbe <__divmodsi4_neg1>
    2caa:	00 1c       	adc	r0, r0
    2cac:	38 f4       	brcc	.+14     	; 0x2cbc <__divmodsi4_exit>

00002cae <__divmodsi4_neg2>:
    2cae:	50 95       	com	r21
    2cb0:	40 95       	com	r20
    2cb2:	30 95       	com	r19
    2cb4:	21 95       	neg	r18
    2cb6:	3f 4f       	sbci	r19, 0xFF	; 255
    2cb8:	4f 4f       	sbci	r20, 0xFF	; 255
    2cba:	5f 4f       	sbci	r21, 0xFF	; 255

00002cbc <__divmodsi4_exit>:
    2cbc:	08 95       	ret

00002cbe <__divmodsi4_neg1>:
    2cbe:	f6 f7       	brtc	.-4      	; 0x2cbc <__divmodsi4_exit>
    2cc0:	90 95       	com	r25
    2cc2:	80 95       	com	r24
    2cc4:	70 95       	com	r23
    2cc6:	61 95       	neg	r22
    2cc8:	7f 4f       	sbci	r23, 0xFF	; 255
    2cca:	8f 4f       	sbci	r24, 0xFF	; 255
    2ccc:	9f 4f       	sbci	r25, 0xFF	; 255
    2cce:	08 95       	ret

00002cd0 <memcpy>:
    2cd0:	fb 01       	movw	r30, r22
    2cd2:	dc 01       	movw	r26, r24
    2cd4:	02 c0       	rjmp	.+4      	; 0x2cda <memcpy+0xa>
    2cd6:	01 90       	ld	r0, Z+
    2cd8:	0d 92       	st	X+, r0
    2cda:	41 50       	subi	r20, 0x01	; 1
    2cdc:	50 40       	sbci	r21, 0x00	; 0
    2cde:	d8 f7       	brcc	.-10     	; 0x2cd6 <memcpy+0x6>
    2ce0:	08 95       	ret

00002ce2 <sprintf>:
    2ce2:	ae e0       	ldi	r26, 0x0E	; 14
    2ce4:	b0 e0       	ldi	r27, 0x00	; 0
    2ce6:	e7 e7       	ldi	r30, 0x77	; 119
    2ce8:	f6 e1       	ldi	r31, 0x16	; 22
    2cea:	0c 94 3e 19 	jmp	0x327c	; 0x327c <__prologue_saves__+0x1c>
    2cee:	0d 89       	ldd	r16, Y+21	; 0x15
    2cf0:	1e 89       	ldd	r17, Y+22	; 0x16
    2cf2:	86 e0       	ldi	r24, 0x06	; 6
    2cf4:	8c 83       	std	Y+4, r24	; 0x04
    2cf6:	1a 83       	std	Y+2, r17	; 0x02
    2cf8:	09 83       	std	Y+1, r16	; 0x01
    2cfa:	8f ef       	ldi	r24, 0xFF	; 255
    2cfc:	9f e7       	ldi	r25, 0x7F	; 127
    2cfe:	9e 83       	std	Y+6, r25	; 0x06
    2d00:	8d 83       	std	Y+5, r24	; 0x05
    2d02:	9e 01       	movw	r18, r28
    2d04:	27 5e       	subi	r18, 0xE7	; 231
    2d06:	3f 4f       	sbci	r19, 0xFF	; 255
    2d08:	ce 01       	movw	r24, r28
    2d0a:	01 96       	adiw	r24, 0x01	; 1
    2d0c:	6f 89       	ldd	r22, Y+23	; 0x17
    2d0e:	78 8d       	ldd	r23, Y+24	; 0x18
    2d10:	a9 01       	movw	r20, r18
    2d12:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <vfprintf>
    2d16:	2f 81       	ldd	r18, Y+7	; 0x07
    2d18:	38 85       	ldd	r19, Y+8	; 0x08
    2d1a:	02 0f       	add	r16, r18
    2d1c:	13 1f       	adc	r17, r19
    2d1e:	f8 01       	movw	r30, r16
    2d20:	10 82       	st	Z, r1
    2d22:	2e 96       	adiw	r28, 0x0e	; 14
    2d24:	e4 e0       	ldi	r30, 0x04	; 4
    2d26:	0c 94 5a 19 	jmp	0x32b4	; 0x32b4 <__epilogue_restores__+0x1c>

00002d2a <vfprintf>:
    2d2a:	ab e0       	ldi	r26, 0x0B	; 11
    2d2c:	b0 e0       	ldi	r27, 0x00	; 0
    2d2e:	eb e9       	ldi	r30, 0x9B	; 155
    2d30:	f6 e1       	ldi	r31, 0x16	; 22
    2d32:	0c 94 30 19 	jmp	0x3260	; 0x3260 <__prologue_saves__>
    2d36:	3c 01       	movw	r6, r24
    2d38:	2b 01       	movw	r4, r22
    2d3a:	5a 01       	movw	r10, r20
    2d3c:	fc 01       	movw	r30, r24
    2d3e:	17 82       	std	Z+7, r1	; 0x07
    2d40:	16 82       	std	Z+6, r1	; 0x06
    2d42:	83 81       	ldd	r24, Z+3	; 0x03
    2d44:	81 fd       	sbrc	r24, 1
    2d46:	03 c0       	rjmp	.+6      	; 0x2d4e <vfprintf+0x24>
    2d48:	6f ef       	ldi	r22, 0xFF	; 255
    2d4a:	7f ef       	ldi	r23, 0xFF	; 255
    2d4c:	c6 c1       	rjmp	.+908    	; 0x30da <vfprintf+0x3b0>
    2d4e:	9a e0       	ldi	r25, 0x0A	; 10
    2d50:	89 2e       	mov	r8, r25
    2d52:	1e 01       	movw	r2, r28
    2d54:	08 94       	sec
    2d56:	21 1c       	adc	r2, r1
    2d58:	31 1c       	adc	r3, r1
    2d5a:	f3 01       	movw	r30, r6
    2d5c:	23 81       	ldd	r18, Z+3	; 0x03
    2d5e:	f2 01       	movw	r30, r4
    2d60:	23 fd       	sbrc	r18, 3
    2d62:	85 91       	lpm	r24, Z+
    2d64:	23 ff       	sbrs	r18, 3
    2d66:	81 91       	ld	r24, Z+
    2d68:	2f 01       	movw	r4, r30
    2d6a:	88 23       	and	r24, r24
    2d6c:	09 f4       	brne	.+2      	; 0x2d70 <vfprintf+0x46>
    2d6e:	b2 c1       	rjmp	.+868    	; 0x30d4 <vfprintf+0x3aa>
    2d70:	85 32       	cpi	r24, 0x25	; 37
    2d72:	39 f4       	brne	.+14     	; 0x2d82 <vfprintf+0x58>
    2d74:	23 fd       	sbrc	r18, 3
    2d76:	85 91       	lpm	r24, Z+
    2d78:	23 ff       	sbrs	r18, 3
    2d7a:	81 91       	ld	r24, Z+
    2d7c:	2f 01       	movw	r4, r30
    2d7e:	85 32       	cpi	r24, 0x25	; 37
    2d80:	29 f4       	brne	.+10     	; 0x2d8c <vfprintf+0x62>
    2d82:	90 e0       	ldi	r25, 0x00	; 0
    2d84:	b3 01       	movw	r22, r6
    2d86:	0e 94 a6 18 	call	0x314c	; 0x314c <fputc>
    2d8a:	e7 cf       	rjmp	.-50     	; 0x2d5a <vfprintf+0x30>
    2d8c:	98 2f       	mov	r25, r24
    2d8e:	ff 24       	eor	r15, r15
    2d90:	ee 24       	eor	r14, r14
    2d92:	99 24       	eor	r9, r9
    2d94:	ff e1       	ldi	r31, 0x1F	; 31
    2d96:	ff 15       	cp	r31, r15
    2d98:	d0 f0       	brcs	.+52     	; 0x2dce <vfprintf+0xa4>
    2d9a:	9b 32       	cpi	r25, 0x2B	; 43
    2d9c:	69 f0       	breq	.+26     	; 0x2db8 <vfprintf+0x8e>
    2d9e:	9c 32       	cpi	r25, 0x2C	; 44
    2da0:	28 f4       	brcc	.+10     	; 0x2dac <vfprintf+0x82>
    2da2:	90 32       	cpi	r25, 0x20	; 32
    2da4:	59 f0       	breq	.+22     	; 0x2dbc <vfprintf+0x92>
    2da6:	93 32       	cpi	r25, 0x23	; 35
    2da8:	91 f4       	brne	.+36     	; 0x2dce <vfprintf+0xa4>
    2daa:	0e c0       	rjmp	.+28     	; 0x2dc8 <vfprintf+0x9e>
    2dac:	9d 32       	cpi	r25, 0x2D	; 45
    2dae:	49 f0       	breq	.+18     	; 0x2dc2 <vfprintf+0x98>
    2db0:	90 33       	cpi	r25, 0x30	; 48
    2db2:	69 f4       	brne	.+26     	; 0x2dce <vfprintf+0xa4>
    2db4:	41 e0       	ldi	r20, 0x01	; 1
    2db6:	24 c0       	rjmp	.+72     	; 0x2e00 <vfprintf+0xd6>
    2db8:	52 e0       	ldi	r21, 0x02	; 2
    2dba:	f5 2a       	or	r15, r21
    2dbc:	84 e0       	ldi	r24, 0x04	; 4
    2dbe:	f8 2a       	or	r15, r24
    2dc0:	28 c0       	rjmp	.+80     	; 0x2e12 <vfprintf+0xe8>
    2dc2:	98 e0       	ldi	r25, 0x08	; 8
    2dc4:	f9 2a       	or	r15, r25
    2dc6:	25 c0       	rjmp	.+74     	; 0x2e12 <vfprintf+0xe8>
    2dc8:	e0 e1       	ldi	r30, 0x10	; 16
    2dca:	fe 2a       	or	r15, r30
    2dcc:	22 c0       	rjmp	.+68     	; 0x2e12 <vfprintf+0xe8>
    2dce:	f7 fc       	sbrc	r15, 7
    2dd0:	29 c0       	rjmp	.+82     	; 0x2e24 <vfprintf+0xfa>
    2dd2:	89 2f       	mov	r24, r25
    2dd4:	80 53       	subi	r24, 0x30	; 48
    2dd6:	8a 30       	cpi	r24, 0x0A	; 10
    2dd8:	70 f4       	brcc	.+28     	; 0x2df6 <vfprintf+0xcc>
    2dda:	f6 fe       	sbrs	r15, 6
    2ddc:	05 c0       	rjmp	.+10     	; 0x2de8 <vfprintf+0xbe>
    2dde:	98 9c       	mul	r9, r8
    2de0:	90 2c       	mov	r9, r0
    2de2:	11 24       	eor	r1, r1
    2de4:	98 0e       	add	r9, r24
    2de6:	15 c0       	rjmp	.+42     	; 0x2e12 <vfprintf+0xe8>
    2de8:	e8 9c       	mul	r14, r8
    2dea:	e0 2c       	mov	r14, r0
    2dec:	11 24       	eor	r1, r1
    2dee:	e8 0e       	add	r14, r24
    2df0:	f0 e2       	ldi	r31, 0x20	; 32
    2df2:	ff 2a       	or	r15, r31
    2df4:	0e c0       	rjmp	.+28     	; 0x2e12 <vfprintf+0xe8>
    2df6:	9e 32       	cpi	r25, 0x2E	; 46
    2df8:	29 f4       	brne	.+10     	; 0x2e04 <vfprintf+0xda>
    2dfa:	f6 fc       	sbrc	r15, 6
    2dfc:	6b c1       	rjmp	.+726    	; 0x30d4 <vfprintf+0x3aa>
    2dfe:	40 e4       	ldi	r20, 0x40	; 64
    2e00:	f4 2a       	or	r15, r20
    2e02:	07 c0       	rjmp	.+14     	; 0x2e12 <vfprintf+0xe8>
    2e04:	9c 36       	cpi	r25, 0x6C	; 108
    2e06:	19 f4       	brne	.+6      	; 0x2e0e <vfprintf+0xe4>
    2e08:	50 e8       	ldi	r21, 0x80	; 128
    2e0a:	f5 2a       	or	r15, r21
    2e0c:	02 c0       	rjmp	.+4      	; 0x2e12 <vfprintf+0xe8>
    2e0e:	98 36       	cpi	r25, 0x68	; 104
    2e10:	49 f4       	brne	.+18     	; 0x2e24 <vfprintf+0xfa>
    2e12:	f2 01       	movw	r30, r4
    2e14:	23 fd       	sbrc	r18, 3
    2e16:	95 91       	lpm	r25, Z+
    2e18:	23 ff       	sbrs	r18, 3
    2e1a:	91 91       	ld	r25, Z+
    2e1c:	2f 01       	movw	r4, r30
    2e1e:	99 23       	and	r25, r25
    2e20:	09 f0       	breq	.+2      	; 0x2e24 <vfprintf+0xfa>
    2e22:	b8 cf       	rjmp	.-144    	; 0x2d94 <vfprintf+0x6a>
    2e24:	89 2f       	mov	r24, r25
    2e26:	85 54       	subi	r24, 0x45	; 69
    2e28:	83 30       	cpi	r24, 0x03	; 3
    2e2a:	18 f0       	brcs	.+6      	; 0x2e32 <vfprintf+0x108>
    2e2c:	80 52       	subi	r24, 0x20	; 32
    2e2e:	83 30       	cpi	r24, 0x03	; 3
    2e30:	38 f4       	brcc	.+14     	; 0x2e40 <vfprintf+0x116>
    2e32:	44 e0       	ldi	r20, 0x04	; 4
    2e34:	50 e0       	ldi	r21, 0x00	; 0
    2e36:	a4 0e       	add	r10, r20
    2e38:	b5 1e       	adc	r11, r21
    2e3a:	5f e3       	ldi	r21, 0x3F	; 63
    2e3c:	59 83       	std	Y+1, r21	; 0x01
    2e3e:	0f c0       	rjmp	.+30     	; 0x2e5e <vfprintf+0x134>
    2e40:	93 36       	cpi	r25, 0x63	; 99
    2e42:	31 f0       	breq	.+12     	; 0x2e50 <vfprintf+0x126>
    2e44:	93 37       	cpi	r25, 0x73	; 115
    2e46:	79 f0       	breq	.+30     	; 0x2e66 <vfprintf+0x13c>
    2e48:	93 35       	cpi	r25, 0x53	; 83
    2e4a:	09 f0       	breq	.+2      	; 0x2e4e <vfprintf+0x124>
    2e4c:	56 c0       	rjmp	.+172    	; 0x2efa <vfprintf+0x1d0>
    2e4e:	20 c0       	rjmp	.+64     	; 0x2e90 <vfprintf+0x166>
    2e50:	f5 01       	movw	r30, r10
    2e52:	80 81       	ld	r24, Z
    2e54:	89 83       	std	Y+1, r24	; 0x01
    2e56:	42 e0       	ldi	r20, 0x02	; 2
    2e58:	50 e0       	ldi	r21, 0x00	; 0
    2e5a:	a4 0e       	add	r10, r20
    2e5c:	b5 1e       	adc	r11, r21
    2e5e:	61 01       	movw	r12, r2
    2e60:	01 e0       	ldi	r16, 0x01	; 1
    2e62:	10 e0       	ldi	r17, 0x00	; 0
    2e64:	12 c0       	rjmp	.+36     	; 0x2e8a <vfprintf+0x160>
    2e66:	f5 01       	movw	r30, r10
    2e68:	c0 80       	ld	r12, Z
    2e6a:	d1 80       	ldd	r13, Z+1	; 0x01
    2e6c:	f6 fc       	sbrc	r15, 6
    2e6e:	03 c0       	rjmp	.+6      	; 0x2e76 <vfprintf+0x14c>
    2e70:	6f ef       	ldi	r22, 0xFF	; 255
    2e72:	7f ef       	ldi	r23, 0xFF	; 255
    2e74:	02 c0       	rjmp	.+4      	; 0x2e7a <vfprintf+0x150>
    2e76:	69 2d       	mov	r22, r9
    2e78:	70 e0       	ldi	r23, 0x00	; 0
    2e7a:	42 e0       	ldi	r20, 0x02	; 2
    2e7c:	50 e0       	ldi	r21, 0x00	; 0
    2e7e:	a4 0e       	add	r10, r20
    2e80:	b5 1e       	adc	r11, r21
    2e82:	c6 01       	movw	r24, r12
    2e84:	0e 94 9b 18 	call	0x3136	; 0x3136 <strnlen>
    2e88:	8c 01       	movw	r16, r24
    2e8a:	5f e7       	ldi	r21, 0x7F	; 127
    2e8c:	f5 22       	and	r15, r21
    2e8e:	14 c0       	rjmp	.+40     	; 0x2eb8 <vfprintf+0x18e>
    2e90:	f5 01       	movw	r30, r10
    2e92:	c0 80       	ld	r12, Z
    2e94:	d1 80       	ldd	r13, Z+1	; 0x01
    2e96:	f6 fc       	sbrc	r15, 6
    2e98:	03 c0       	rjmp	.+6      	; 0x2ea0 <vfprintf+0x176>
    2e9a:	6f ef       	ldi	r22, 0xFF	; 255
    2e9c:	7f ef       	ldi	r23, 0xFF	; 255
    2e9e:	02 c0       	rjmp	.+4      	; 0x2ea4 <vfprintf+0x17a>
    2ea0:	69 2d       	mov	r22, r9
    2ea2:	70 e0       	ldi	r23, 0x00	; 0
    2ea4:	42 e0       	ldi	r20, 0x02	; 2
    2ea6:	50 e0       	ldi	r21, 0x00	; 0
    2ea8:	a4 0e       	add	r10, r20
    2eaa:	b5 1e       	adc	r11, r21
    2eac:	c6 01       	movw	r24, r12
    2eae:	0e 94 90 18 	call	0x3120	; 0x3120 <strnlen_P>
    2eb2:	8c 01       	movw	r16, r24
    2eb4:	50 e8       	ldi	r21, 0x80	; 128
    2eb6:	f5 2a       	or	r15, r21
    2eb8:	f3 fe       	sbrs	r15, 3
    2eba:	07 c0       	rjmp	.+14     	; 0x2eca <vfprintf+0x1a0>
    2ebc:	1a c0       	rjmp	.+52     	; 0x2ef2 <vfprintf+0x1c8>
    2ebe:	80 e2       	ldi	r24, 0x20	; 32
    2ec0:	90 e0       	ldi	r25, 0x00	; 0
    2ec2:	b3 01       	movw	r22, r6
    2ec4:	0e 94 a6 18 	call	0x314c	; 0x314c <fputc>
    2ec8:	ea 94       	dec	r14
    2eca:	8e 2d       	mov	r24, r14
    2ecc:	90 e0       	ldi	r25, 0x00	; 0
    2ece:	08 17       	cp	r16, r24
    2ed0:	19 07       	cpc	r17, r25
    2ed2:	a8 f3       	brcs	.-22     	; 0x2ebe <vfprintf+0x194>
    2ed4:	0e c0       	rjmp	.+28     	; 0x2ef2 <vfprintf+0x1c8>
    2ed6:	f6 01       	movw	r30, r12
    2ed8:	f7 fc       	sbrc	r15, 7
    2eda:	85 91       	lpm	r24, Z+
    2edc:	f7 fe       	sbrs	r15, 7
    2ede:	81 91       	ld	r24, Z+
    2ee0:	6f 01       	movw	r12, r30
    2ee2:	90 e0       	ldi	r25, 0x00	; 0
    2ee4:	b3 01       	movw	r22, r6
    2ee6:	0e 94 a6 18 	call	0x314c	; 0x314c <fputc>
    2eea:	e1 10       	cpse	r14, r1
    2eec:	ea 94       	dec	r14
    2eee:	01 50       	subi	r16, 0x01	; 1
    2ef0:	10 40       	sbci	r17, 0x00	; 0
    2ef2:	01 15       	cp	r16, r1
    2ef4:	11 05       	cpc	r17, r1
    2ef6:	79 f7       	brne	.-34     	; 0x2ed6 <vfprintf+0x1ac>
    2ef8:	ea c0       	rjmp	.+468    	; 0x30ce <vfprintf+0x3a4>
    2efa:	94 36       	cpi	r25, 0x64	; 100
    2efc:	11 f0       	breq	.+4      	; 0x2f02 <vfprintf+0x1d8>
    2efe:	99 36       	cpi	r25, 0x69	; 105
    2f00:	69 f5       	brne	.+90     	; 0x2f5c <vfprintf+0x232>
    2f02:	f7 fe       	sbrs	r15, 7
    2f04:	08 c0       	rjmp	.+16     	; 0x2f16 <vfprintf+0x1ec>
    2f06:	f5 01       	movw	r30, r10
    2f08:	20 81       	ld	r18, Z
    2f0a:	31 81       	ldd	r19, Z+1	; 0x01
    2f0c:	42 81       	ldd	r20, Z+2	; 0x02
    2f0e:	53 81       	ldd	r21, Z+3	; 0x03
    2f10:	84 e0       	ldi	r24, 0x04	; 4
    2f12:	90 e0       	ldi	r25, 0x00	; 0
    2f14:	0a c0       	rjmp	.+20     	; 0x2f2a <vfprintf+0x200>
    2f16:	f5 01       	movw	r30, r10
    2f18:	80 81       	ld	r24, Z
    2f1a:	91 81       	ldd	r25, Z+1	; 0x01
    2f1c:	9c 01       	movw	r18, r24
    2f1e:	44 27       	eor	r20, r20
    2f20:	37 fd       	sbrc	r19, 7
    2f22:	40 95       	com	r20
    2f24:	54 2f       	mov	r21, r20
    2f26:	82 e0       	ldi	r24, 0x02	; 2
    2f28:	90 e0       	ldi	r25, 0x00	; 0
    2f2a:	a8 0e       	add	r10, r24
    2f2c:	b9 1e       	adc	r11, r25
    2f2e:	9f e6       	ldi	r25, 0x6F	; 111
    2f30:	f9 22       	and	r15, r25
    2f32:	57 ff       	sbrs	r21, 7
    2f34:	09 c0       	rjmp	.+18     	; 0x2f48 <vfprintf+0x21e>
    2f36:	50 95       	com	r21
    2f38:	40 95       	com	r20
    2f3a:	30 95       	com	r19
    2f3c:	21 95       	neg	r18
    2f3e:	3f 4f       	sbci	r19, 0xFF	; 255
    2f40:	4f 4f       	sbci	r20, 0xFF	; 255
    2f42:	5f 4f       	sbci	r21, 0xFF	; 255
    2f44:	e0 e8       	ldi	r30, 0x80	; 128
    2f46:	fe 2a       	or	r15, r30
    2f48:	ca 01       	movw	r24, r20
    2f4a:	b9 01       	movw	r22, r18
    2f4c:	a1 01       	movw	r20, r2
    2f4e:	2a e0       	ldi	r18, 0x0A	; 10
    2f50:	30 e0       	ldi	r19, 0x00	; 0
    2f52:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <__ultoa_invert>
    2f56:	d8 2e       	mov	r13, r24
    2f58:	d2 18       	sub	r13, r2
    2f5a:	40 c0       	rjmp	.+128    	; 0x2fdc <vfprintf+0x2b2>
    2f5c:	95 37       	cpi	r25, 0x75	; 117
    2f5e:	29 f4       	brne	.+10     	; 0x2f6a <vfprintf+0x240>
    2f60:	1f 2d       	mov	r17, r15
    2f62:	1f 7e       	andi	r17, 0xEF	; 239
    2f64:	2a e0       	ldi	r18, 0x0A	; 10
    2f66:	30 e0       	ldi	r19, 0x00	; 0
    2f68:	1d c0       	rjmp	.+58     	; 0x2fa4 <vfprintf+0x27a>
    2f6a:	1f 2d       	mov	r17, r15
    2f6c:	19 7f       	andi	r17, 0xF9	; 249
    2f6e:	9f 36       	cpi	r25, 0x6F	; 111
    2f70:	61 f0       	breq	.+24     	; 0x2f8a <vfprintf+0x260>
    2f72:	90 37       	cpi	r25, 0x70	; 112
    2f74:	20 f4       	brcc	.+8      	; 0x2f7e <vfprintf+0x254>
    2f76:	98 35       	cpi	r25, 0x58	; 88
    2f78:	09 f0       	breq	.+2      	; 0x2f7c <vfprintf+0x252>
    2f7a:	ac c0       	rjmp	.+344    	; 0x30d4 <vfprintf+0x3aa>
    2f7c:	0f c0       	rjmp	.+30     	; 0x2f9c <vfprintf+0x272>
    2f7e:	90 37       	cpi	r25, 0x70	; 112
    2f80:	39 f0       	breq	.+14     	; 0x2f90 <vfprintf+0x266>
    2f82:	98 37       	cpi	r25, 0x78	; 120
    2f84:	09 f0       	breq	.+2      	; 0x2f88 <vfprintf+0x25e>
    2f86:	a6 c0       	rjmp	.+332    	; 0x30d4 <vfprintf+0x3aa>
    2f88:	04 c0       	rjmp	.+8      	; 0x2f92 <vfprintf+0x268>
    2f8a:	28 e0       	ldi	r18, 0x08	; 8
    2f8c:	30 e0       	ldi	r19, 0x00	; 0
    2f8e:	0a c0       	rjmp	.+20     	; 0x2fa4 <vfprintf+0x27a>
    2f90:	10 61       	ori	r17, 0x10	; 16
    2f92:	14 fd       	sbrc	r17, 4
    2f94:	14 60       	ori	r17, 0x04	; 4
    2f96:	20 e1       	ldi	r18, 0x10	; 16
    2f98:	30 e0       	ldi	r19, 0x00	; 0
    2f9a:	04 c0       	rjmp	.+8      	; 0x2fa4 <vfprintf+0x27a>
    2f9c:	14 fd       	sbrc	r17, 4
    2f9e:	16 60       	ori	r17, 0x06	; 6
    2fa0:	20 e1       	ldi	r18, 0x10	; 16
    2fa2:	32 e0       	ldi	r19, 0x02	; 2
    2fa4:	17 ff       	sbrs	r17, 7
    2fa6:	08 c0       	rjmp	.+16     	; 0x2fb8 <vfprintf+0x28e>
    2fa8:	f5 01       	movw	r30, r10
    2faa:	60 81       	ld	r22, Z
    2fac:	71 81       	ldd	r23, Z+1	; 0x01
    2fae:	82 81       	ldd	r24, Z+2	; 0x02
    2fb0:	93 81       	ldd	r25, Z+3	; 0x03
    2fb2:	44 e0       	ldi	r20, 0x04	; 4
    2fb4:	50 e0       	ldi	r21, 0x00	; 0
    2fb6:	08 c0       	rjmp	.+16     	; 0x2fc8 <vfprintf+0x29e>
    2fb8:	f5 01       	movw	r30, r10
    2fba:	80 81       	ld	r24, Z
    2fbc:	91 81       	ldd	r25, Z+1	; 0x01
    2fbe:	bc 01       	movw	r22, r24
    2fc0:	80 e0       	ldi	r24, 0x00	; 0
    2fc2:	90 e0       	ldi	r25, 0x00	; 0
    2fc4:	42 e0       	ldi	r20, 0x02	; 2
    2fc6:	50 e0       	ldi	r21, 0x00	; 0
    2fc8:	a4 0e       	add	r10, r20
    2fca:	b5 1e       	adc	r11, r21
    2fcc:	a1 01       	movw	r20, r2
    2fce:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <__ultoa_invert>
    2fd2:	d8 2e       	mov	r13, r24
    2fd4:	d2 18       	sub	r13, r2
    2fd6:	8f e7       	ldi	r24, 0x7F	; 127
    2fd8:	f8 2e       	mov	r15, r24
    2fda:	f1 22       	and	r15, r17
    2fdc:	f6 fe       	sbrs	r15, 6
    2fde:	0b c0       	rjmp	.+22     	; 0x2ff6 <vfprintf+0x2cc>
    2fe0:	5e ef       	ldi	r21, 0xFE	; 254
    2fe2:	f5 22       	and	r15, r21
    2fe4:	d9 14       	cp	r13, r9
    2fe6:	38 f4       	brcc	.+14     	; 0x2ff6 <vfprintf+0x2cc>
    2fe8:	f4 fe       	sbrs	r15, 4
    2fea:	07 c0       	rjmp	.+14     	; 0x2ffa <vfprintf+0x2d0>
    2fec:	f2 fc       	sbrc	r15, 2
    2fee:	05 c0       	rjmp	.+10     	; 0x2ffa <vfprintf+0x2d0>
    2ff0:	8f ee       	ldi	r24, 0xEF	; 239
    2ff2:	f8 22       	and	r15, r24
    2ff4:	02 c0       	rjmp	.+4      	; 0x2ffa <vfprintf+0x2d0>
    2ff6:	1d 2d       	mov	r17, r13
    2ff8:	01 c0       	rjmp	.+2      	; 0x2ffc <vfprintf+0x2d2>
    2ffa:	19 2d       	mov	r17, r9
    2ffc:	f4 fe       	sbrs	r15, 4
    2ffe:	0d c0       	rjmp	.+26     	; 0x301a <vfprintf+0x2f0>
    3000:	fe 01       	movw	r30, r28
    3002:	ed 0d       	add	r30, r13
    3004:	f1 1d       	adc	r31, r1
    3006:	80 81       	ld	r24, Z
    3008:	80 33       	cpi	r24, 0x30	; 48
    300a:	19 f4       	brne	.+6      	; 0x3012 <vfprintf+0x2e8>
    300c:	99 ee       	ldi	r25, 0xE9	; 233
    300e:	f9 22       	and	r15, r25
    3010:	08 c0       	rjmp	.+16     	; 0x3022 <vfprintf+0x2f8>
    3012:	1f 5f       	subi	r17, 0xFF	; 255
    3014:	f2 fe       	sbrs	r15, 2
    3016:	05 c0       	rjmp	.+10     	; 0x3022 <vfprintf+0x2f8>
    3018:	03 c0       	rjmp	.+6      	; 0x3020 <vfprintf+0x2f6>
    301a:	8f 2d       	mov	r24, r15
    301c:	86 78       	andi	r24, 0x86	; 134
    301e:	09 f0       	breq	.+2      	; 0x3022 <vfprintf+0x2f8>
    3020:	1f 5f       	subi	r17, 0xFF	; 255
    3022:	0f 2d       	mov	r16, r15
    3024:	f3 fc       	sbrc	r15, 3
    3026:	14 c0       	rjmp	.+40     	; 0x3050 <vfprintf+0x326>
    3028:	f0 fe       	sbrs	r15, 0
    302a:	0f c0       	rjmp	.+30     	; 0x304a <vfprintf+0x320>
    302c:	1e 15       	cp	r17, r14
    302e:	10 f0       	brcs	.+4      	; 0x3034 <vfprintf+0x30a>
    3030:	9d 2c       	mov	r9, r13
    3032:	0b c0       	rjmp	.+22     	; 0x304a <vfprintf+0x320>
    3034:	9d 2c       	mov	r9, r13
    3036:	9e 0c       	add	r9, r14
    3038:	91 1a       	sub	r9, r17
    303a:	1e 2d       	mov	r17, r14
    303c:	06 c0       	rjmp	.+12     	; 0x304a <vfprintf+0x320>
    303e:	80 e2       	ldi	r24, 0x20	; 32
    3040:	90 e0       	ldi	r25, 0x00	; 0
    3042:	b3 01       	movw	r22, r6
    3044:	0e 94 a6 18 	call	0x314c	; 0x314c <fputc>
    3048:	1f 5f       	subi	r17, 0xFF	; 255
    304a:	1e 15       	cp	r17, r14
    304c:	c0 f3       	brcs	.-16     	; 0x303e <vfprintf+0x314>
    304e:	04 c0       	rjmp	.+8      	; 0x3058 <vfprintf+0x32e>
    3050:	1e 15       	cp	r17, r14
    3052:	10 f4       	brcc	.+4      	; 0x3058 <vfprintf+0x32e>
    3054:	e1 1a       	sub	r14, r17
    3056:	01 c0       	rjmp	.+2      	; 0x305a <vfprintf+0x330>
    3058:	ee 24       	eor	r14, r14
    305a:	04 ff       	sbrs	r16, 4
    305c:	0f c0       	rjmp	.+30     	; 0x307c <vfprintf+0x352>
    305e:	80 e3       	ldi	r24, 0x30	; 48
    3060:	90 e0       	ldi	r25, 0x00	; 0
    3062:	b3 01       	movw	r22, r6
    3064:	0e 94 a6 18 	call	0x314c	; 0x314c <fputc>
    3068:	02 ff       	sbrs	r16, 2
    306a:	1d c0       	rjmp	.+58     	; 0x30a6 <vfprintf+0x37c>
    306c:	01 fd       	sbrc	r16, 1
    306e:	03 c0       	rjmp	.+6      	; 0x3076 <vfprintf+0x34c>
    3070:	88 e7       	ldi	r24, 0x78	; 120
    3072:	90 e0       	ldi	r25, 0x00	; 0
    3074:	0e c0       	rjmp	.+28     	; 0x3092 <vfprintf+0x368>
    3076:	88 e5       	ldi	r24, 0x58	; 88
    3078:	90 e0       	ldi	r25, 0x00	; 0
    307a:	0b c0       	rjmp	.+22     	; 0x3092 <vfprintf+0x368>
    307c:	80 2f       	mov	r24, r16
    307e:	86 78       	andi	r24, 0x86	; 134
    3080:	91 f0       	breq	.+36     	; 0x30a6 <vfprintf+0x37c>
    3082:	01 ff       	sbrs	r16, 1
    3084:	02 c0       	rjmp	.+4      	; 0x308a <vfprintf+0x360>
    3086:	8b e2       	ldi	r24, 0x2B	; 43
    3088:	01 c0       	rjmp	.+2      	; 0x308c <vfprintf+0x362>
    308a:	80 e2       	ldi	r24, 0x20	; 32
    308c:	f7 fc       	sbrc	r15, 7
    308e:	8d e2       	ldi	r24, 0x2D	; 45
    3090:	90 e0       	ldi	r25, 0x00	; 0
    3092:	b3 01       	movw	r22, r6
    3094:	0e 94 a6 18 	call	0x314c	; 0x314c <fputc>
    3098:	06 c0       	rjmp	.+12     	; 0x30a6 <vfprintf+0x37c>
    309a:	80 e3       	ldi	r24, 0x30	; 48
    309c:	90 e0       	ldi	r25, 0x00	; 0
    309e:	b3 01       	movw	r22, r6
    30a0:	0e 94 a6 18 	call	0x314c	; 0x314c <fputc>
    30a4:	9a 94       	dec	r9
    30a6:	d9 14       	cp	r13, r9
    30a8:	c0 f3       	brcs	.-16     	; 0x309a <vfprintf+0x370>
    30aa:	da 94       	dec	r13
    30ac:	f1 01       	movw	r30, r2
    30ae:	ed 0d       	add	r30, r13
    30b0:	f1 1d       	adc	r31, r1
    30b2:	80 81       	ld	r24, Z
    30b4:	90 e0       	ldi	r25, 0x00	; 0
    30b6:	b3 01       	movw	r22, r6
    30b8:	0e 94 a6 18 	call	0x314c	; 0x314c <fputc>
    30bc:	dd 20       	and	r13, r13
    30be:	a9 f7       	brne	.-22     	; 0x30aa <vfprintf+0x380>
    30c0:	06 c0       	rjmp	.+12     	; 0x30ce <vfprintf+0x3a4>
    30c2:	80 e2       	ldi	r24, 0x20	; 32
    30c4:	90 e0       	ldi	r25, 0x00	; 0
    30c6:	b3 01       	movw	r22, r6
    30c8:	0e 94 a6 18 	call	0x314c	; 0x314c <fputc>
    30cc:	ea 94       	dec	r14
    30ce:	ee 20       	and	r14, r14
    30d0:	c1 f7       	brne	.-16     	; 0x30c2 <vfprintf+0x398>
    30d2:	43 ce       	rjmp	.-890    	; 0x2d5a <vfprintf+0x30>
    30d4:	f3 01       	movw	r30, r6
    30d6:	66 81       	ldd	r22, Z+6	; 0x06
    30d8:	77 81       	ldd	r23, Z+7	; 0x07
    30da:	cb 01       	movw	r24, r22
    30dc:	2b 96       	adiw	r28, 0x0b	; 11
    30de:	e2 e1       	ldi	r30, 0x12	; 18
    30e0:	0c 94 4c 19 	jmp	0x3298	; 0x3298 <__epilogue_restores__>

000030e4 <__eerd_block_m328p>:
    30e4:	dc 01       	movw	r26, r24
    30e6:	cb 01       	movw	r24, r22

000030e8 <__eerd_blraw_m328p>:
    30e8:	fc 01       	movw	r30, r24
    30ea:	f9 99       	sbic	0x1f, 1	; 31
    30ec:	fe cf       	rjmp	.-4      	; 0x30ea <__eerd_blraw_m328p+0x2>
    30ee:	06 c0       	rjmp	.+12     	; 0x30fc <__eerd_blraw_m328p+0x14>
    30f0:	f2 bd       	out	0x22, r31	; 34
    30f2:	e1 bd       	out	0x21, r30	; 33
    30f4:	f8 9a       	sbi	0x1f, 0	; 31
    30f6:	31 96       	adiw	r30, 0x01	; 1
    30f8:	00 b4       	in	r0, 0x20	; 32
    30fa:	0d 92       	st	X+, r0
    30fc:	41 50       	subi	r20, 0x01	; 1
    30fe:	50 40       	sbci	r21, 0x00	; 0
    3100:	b8 f7       	brcc	.-18     	; 0x30f0 <__eerd_blraw_m328p+0x8>
    3102:	08 95       	ret

00003104 <__eewr_byte_m328p>:
    3104:	26 2f       	mov	r18, r22

00003106 <__eewr_r18_m328p>:
    3106:	f9 99       	sbic	0x1f, 1	; 31
    3108:	fe cf       	rjmp	.-4      	; 0x3106 <__eewr_r18_m328p>
    310a:	1f ba       	out	0x1f, r1	; 31
    310c:	92 bd       	out	0x22, r25	; 34
    310e:	81 bd       	out	0x21, r24	; 33
    3110:	20 bd       	out	0x20, r18	; 32
    3112:	0f b6       	in	r0, 0x3f	; 63
    3114:	f8 94       	cli
    3116:	fa 9a       	sbi	0x1f, 2	; 31
    3118:	f9 9a       	sbi	0x1f, 1	; 31
    311a:	0f be       	out	0x3f, r0	; 63
    311c:	01 96       	adiw	r24, 0x01	; 1
    311e:	08 95       	ret

00003120 <strnlen_P>:
    3120:	fc 01       	movw	r30, r24
    3122:	05 90       	lpm	r0, Z+
    3124:	61 50       	subi	r22, 0x01	; 1
    3126:	70 40       	sbci	r23, 0x00	; 0
    3128:	01 10       	cpse	r0, r1
    312a:	d8 f7       	brcc	.-10     	; 0x3122 <strnlen_P+0x2>
    312c:	80 95       	com	r24
    312e:	90 95       	com	r25
    3130:	8e 0f       	add	r24, r30
    3132:	9f 1f       	adc	r25, r31
    3134:	08 95       	ret

00003136 <strnlen>:
    3136:	fc 01       	movw	r30, r24
    3138:	61 50       	subi	r22, 0x01	; 1
    313a:	70 40       	sbci	r23, 0x00	; 0
    313c:	01 90       	ld	r0, Z+
    313e:	01 10       	cpse	r0, r1
    3140:	d8 f7       	brcc	.-10     	; 0x3138 <strnlen+0x2>
    3142:	80 95       	com	r24
    3144:	90 95       	com	r25
    3146:	8e 0f       	add	r24, r30
    3148:	9f 1f       	adc	r25, r31
    314a:	08 95       	ret

0000314c <fputc>:
    314c:	0f 93       	push	r16
    314e:	1f 93       	push	r17
    3150:	cf 93       	push	r28
    3152:	df 93       	push	r29
    3154:	8c 01       	movw	r16, r24
    3156:	eb 01       	movw	r28, r22
    3158:	8b 81       	ldd	r24, Y+3	; 0x03
    315a:	81 ff       	sbrs	r24, 1
    315c:	1b c0       	rjmp	.+54     	; 0x3194 <fputc+0x48>
    315e:	82 ff       	sbrs	r24, 2
    3160:	0d c0       	rjmp	.+26     	; 0x317c <fputc+0x30>
    3162:	2e 81       	ldd	r18, Y+6	; 0x06
    3164:	3f 81       	ldd	r19, Y+7	; 0x07
    3166:	8c 81       	ldd	r24, Y+4	; 0x04
    3168:	9d 81       	ldd	r25, Y+5	; 0x05
    316a:	28 17       	cp	r18, r24
    316c:	39 07       	cpc	r19, r25
    316e:	64 f4       	brge	.+24     	; 0x3188 <fputc+0x3c>
    3170:	e8 81       	ld	r30, Y
    3172:	f9 81       	ldd	r31, Y+1	; 0x01
    3174:	01 93       	st	Z+, r16
    3176:	f9 83       	std	Y+1, r31	; 0x01
    3178:	e8 83       	st	Y, r30
    317a:	06 c0       	rjmp	.+12     	; 0x3188 <fputc+0x3c>
    317c:	e8 85       	ldd	r30, Y+8	; 0x08
    317e:	f9 85       	ldd	r31, Y+9	; 0x09
    3180:	80 2f       	mov	r24, r16
    3182:	09 95       	icall
    3184:	89 2b       	or	r24, r25
    3186:	31 f4       	brne	.+12     	; 0x3194 <fputc+0x48>
    3188:	8e 81       	ldd	r24, Y+6	; 0x06
    318a:	9f 81       	ldd	r25, Y+7	; 0x07
    318c:	01 96       	adiw	r24, 0x01	; 1
    318e:	9f 83       	std	Y+7, r25	; 0x07
    3190:	8e 83       	std	Y+6, r24	; 0x06
    3192:	02 c0       	rjmp	.+4      	; 0x3198 <fputc+0x4c>
    3194:	0f ef       	ldi	r16, 0xFF	; 255
    3196:	1f ef       	ldi	r17, 0xFF	; 255
    3198:	c8 01       	movw	r24, r16
    319a:	df 91       	pop	r29
    319c:	cf 91       	pop	r28
    319e:	1f 91       	pop	r17
    31a0:	0f 91       	pop	r16
    31a2:	08 95       	ret

000031a4 <__ultoa_invert>:
    31a4:	fa 01       	movw	r30, r20
    31a6:	aa 27       	eor	r26, r26
    31a8:	28 30       	cpi	r18, 0x08	; 8
    31aa:	51 f1       	breq	.+84     	; 0x3200 <__ultoa_invert+0x5c>
    31ac:	20 31       	cpi	r18, 0x10	; 16
    31ae:	81 f1       	breq	.+96     	; 0x3210 <__ultoa_invert+0x6c>
    31b0:	e8 94       	clt
    31b2:	6f 93       	push	r22
    31b4:	6e 7f       	andi	r22, 0xFE	; 254
    31b6:	6e 5f       	subi	r22, 0xFE	; 254
    31b8:	7f 4f       	sbci	r23, 0xFF	; 255
    31ba:	8f 4f       	sbci	r24, 0xFF	; 255
    31bc:	9f 4f       	sbci	r25, 0xFF	; 255
    31be:	af 4f       	sbci	r26, 0xFF	; 255
    31c0:	b1 e0       	ldi	r27, 0x01	; 1
    31c2:	3e d0       	rcall	.+124    	; 0x3240 <__ultoa_invert+0x9c>
    31c4:	b4 e0       	ldi	r27, 0x04	; 4
    31c6:	3c d0       	rcall	.+120    	; 0x3240 <__ultoa_invert+0x9c>
    31c8:	67 0f       	add	r22, r23
    31ca:	78 1f       	adc	r23, r24
    31cc:	89 1f       	adc	r24, r25
    31ce:	9a 1f       	adc	r25, r26
    31d0:	a1 1d       	adc	r26, r1
    31d2:	68 0f       	add	r22, r24
    31d4:	79 1f       	adc	r23, r25
    31d6:	8a 1f       	adc	r24, r26
    31d8:	91 1d       	adc	r25, r1
    31da:	a1 1d       	adc	r26, r1
    31dc:	6a 0f       	add	r22, r26
    31de:	71 1d       	adc	r23, r1
    31e0:	81 1d       	adc	r24, r1
    31e2:	91 1d       	adc	r25, r1
    31e4:	a1 1d       	adc	r26, r1
    31e6:	20 d0       	rcall	.+64     	; 0x3228 <__ultoa_invert+0x84>
    31e8:	09 f4       	brne	.+2      	; 0x31ec <__ultoa_invert+0x48>
    31ea:	68 94       	set
    31ec:	3f 91       	pop	r19
    31ee:	2a e0       	ldi	r18, 0x0A	; 10
    31f0:	26 9f       	mul	r18, r22
    31f2:	11 24       	eor	r1, r1
    31f4:	30 19       	sub	r19, r0
    31f6:	30 5d       	subi	r19, 0xD0	; 208
    31f8:	31 93       	st	Z+, r19
    31fa:	de f6       	brtc	.-74     	; 0x31b2 <__ultoa_invert+0xe>
    31fc:	cf 01       	movw	r24, r30
    31fe:	08 95       	ret
    3200:	46 2f       	mov	r20, r22
    3202:	47 70       	andi	r20, 0x07	; 7
    3204:	40 5d       	subi	r20, 0xD0	; 208
    3206:	41 93       	st	Z+, r20
    3208:	b3 e0       	ldi	r27, 0x03	; 3
    320a:	0f d0       	rcall	.+30     	; 0x322a <__ultoa_invert+0x86>
    320c:	c9 f7       	brne	.-14     	; 0x3200 <__ultoa_invert+0x5c>
    320e:	f6 cf       	rjmp	.-20     	; 0x31fc <__ultoa_invert+0x58>
    3210:	46 2f       	mov	r20, r22
    3212:	4f 70       	andi	r20, 0x0F	; 15
    3214:	40 5d       	subi	r20, 0xD0	; 208
    3216:	4a 33       	cpi	r20, 0x3A	; 58
    3218:	18 f0       	brcs	.+6      	; 0x3220 <__ultoa_invert+0x7c>
    321a:	49 5d       	subi	r20, 0xD9	; 217
    321c:	31 fd       	sbrc	r19, 1
    321e:	40 52       	subi	r20, 0x20	; 32
    3220:	41 93       	st	Z+, r20
    3222:	02 d0       	rcall	.+4      	; 0x3228 <__ultoa_invert+0x84>
    3224:	a9 f7       	brne	.-22     	; 0x3210 <__ultoa_invert+0x6c>
    3226:	ea cf       	rjmp	.-44     	; 0x31fc <__ultoa_invert+0x58>
    3228:	b4 e0       	ldi	r27, 0x04	; 4
    322a:	a6 95       	lsr	r26
    322c:	97 95       	ror	r25
    322e:	87 95       	ror	r24
    3230:	77 95       	ror	r23
    3232:	67 95       	ror	r22
    3234:	ba 95       	dec	r27
    3236:	c9 f7       	brne	.-14     	; 0x322a <__ultoa_invert+0x86>
    3238:	00 97       	sbiw	r24, 0x00	; 0
    323a:	61 05       	cpc	r22, r1
    323c:	71 05       	cpc	r23, r1
    323e:	08 95       	ret
    3240:	9b 01       	movw	r18, r22
    3242:	ac 01       	movw	r20, r24
    3244:	0a 2e       	mov	r0, r26
    3246:	06 94       	lsr	r0
    3248:	57 95       	ror	r21
    324a:	47 95       	ror	r20
    324c:	37 95       	ror	r19
    324e:	27 95       	ror	r18
    3250:	ba 95       	dec	r27
    3252:	c9 f7       	brne	.-14     	; 0x3246 <__ultoa_invert+0xa2>
    3254:	62 0f       	add	r22, r18
    3256:	73 1f       	adc	r23, r19
    3258:	84 1f       	adc	r24, r20
    325a:	95 1f       	adc	r25, r21
    325c:	a0 1d       	adc	r26, r0
    325e:	08 95       	ret

00003260 <__prologue_saves__>:
    3260:	2f 92       	push	r2
    3262:	3f 92       	push	r3
    3264:	4f 92       	push	r4
    3266:	5f 92       	push	r5
    3268:	6f 92       	push	r6
    326a:	7f 92       	push	r7
    326c:	8f 92       	push	r8
    326e:	9f 92       	push	r9
    3270:	af 92       	push	r10
    3272:	bf 92       	push	r11
    3274:	cf 92       	push	r12
    3276:	df 92       	push	r13
    3278:	ef 92       	push	r14
    327a:	ff 92       	push	r15
    327c:	0f 93       	push	r16
    327e:	1f 93       	push	r17
    3280:	cf 93       	push	r28
    3282:	df 93       	push	r29
    3284:	cd b7       	in	r28, 0x3d	; 61
    3286:	de b7       	in	r29, 0x3e	; 62
    3288:	ca 1b       	sub	r28, r26
    328a:	db 0b       	sbc	r29, r27
    328c:	0f b6       	in	r0, 0x3f	; 63
    328e:	f8 94       	cli
    3290:	de bf       	out	0x3e, r29	; 62
    3292:	0f be       	out	0x3f, r0	; 63
    3294:	cd bf       	out	0x3d, r28	; 61
    3296:	09 94       	ijmp

00003298 <__epilogue_restores__>:
    3298:	2a 88       	ldd	r2, Y+18	; 0x12
    329a:	39 88       	ldd	r3, Y+17	; 0x11
    329c:	48 88       	ldd	r4, Y+16	; 0x10
    329e:	5f 84       	ldd	r5, Y+15	; 0x0f
    32a0:	6e 84       	ldd	r6, Y+14	; 0x0e
    32a2:	7d 84       	ldd	r7, Y+13	; 0x0d
    32a4:	8c 84       	ldd	r8, Y+12	; 0x0c
    32a6:	9b 84       	ldd	r9, Y+11	; 0x0b
    32a8:	aa 84       	ldd	r10, Y+10	; 0x0a
    32aa:	b9 84       	ldd	r11, Y+9	; 0x09
    32ac:	c8 84       	ldd	r12, Y+8	; 0x08
    32ae:	df 80       	ldd	r13, Y+7	; 0x07
    32b0:	ee 80       	ldd	r14, Y+6	; 0x06
    32b2:	fd 80       	ldd	r15, Y+5	; 0x05
    32b4:	0c 81       	ldd	r16, Y+4	; 0x04
    32b6:	1b 81       	ldd	r17, Y+3	; 0x03
    32b8:	aa 81       	ldd	r26, Y+2	; 0x02
    32ba:	b9 81       	ldd	r27, Y+1	; 0x01
    32bc:	ce 0f       	add	r28, r30
    32be:	d1 1d       	adc	r29, r1
    32c0:	0f b6       	in	r0, 0x3f	; 63
    32c2:	f8 94       	cli
    32c4:	de bf       	out	0x3e, r29	; 62
    32c6:	0f be       	out	0x3f, r0	; 63
    32c8:	cd bf       	out	0x3d, r28	; 61
    32ca:	ed 01       	movw	r28, r26
    32cc:	08 95       	ret

000032ce <_exit>:
    32ce:	f8 94       	cli

000032d0 <__stop_program>:
    32d0:	ff cf       	rjmp	.-2      	; 0x32d0 <__stop_program>
